<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="뒤태지존의 끄적거림">
    <title>Java NIO FileChannel 과 DirectByteBuffer - 뒤태지존의 끄적거림</title>
    <meta name="author" content="HomoEfficio">
    <meta name="description" content="뒤태지존의 끄적거림">
    
        <link rel="icon" href="/assets/images/favicon.ico">
    
    
        <link rel="alternative" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="Java 4에서 도입된 NIO 덕분에 FileChannel과 ByteBuffer를 이용해서 File I/O 를 수행할 수 있게 됐다. 그림 출처: https://www.happycoders.eu/java/filechannel-bytebuffer-memory-mapped-file-locks/ NIO의 장점은 https://homoefficio.github.i">
<meta name="keywords" content="Java,Native Memory,DirectBuffer,jcmd,NIO,ByteBuffer,FileChannel,HeapByteBuffer,DirectByteBuffer,Garbage Collection,OutOfMemoryError,Direct buffer memory,BufferCache">
<meta property="og:type" content="blog">
<meta property="og:title" content="Java NIO FileChannel 과 DirectByteBuffer">
<meta property="og:url" content="http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/index.html">
<meta property="og:site_name" content="뒤태지존의 끄적거림">
<meta property="og:description" content="Java 4에서 도입된 NIO 덕분에 FileChannel과 ByteBuffer를 이용해서 File I/O 를 수행할 수 있게 됐다. 그림 출처: https://www.happycoders.eu/java/filechannel-bytebuffer-memory-mapped-file-locks/ NIO의 장점은 https://homoefficio.github.i">
<meta property="og:locale" content="ko">
<meta property="og:image" content="https://i.imgur.com/vEL6ni9.png">
<meta property="og:image" content="https://i.imgur.com/AE4p00B.png">
<meta property="og:image" content="https://i.imgur.com/t9gmDhx.png">
<meta property="og:image" content="https://i.imgur.com/72E8YHH.jpg?1">
<meta property="og:image" content="https://i.imgur.com/Nejwtsv.png">
<meta property="og:updated_time" content="2020-08-11T13:06:28.553Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java NIO FileChannel 과 DirectByteBuffer">
<meta name="twitter:description" content="Java 4에서 도입된 NIO 덕분에 FileChannel과 ByteBuffer를 이용해서 File I/O 를 수행할 수 있게 됐다. 그림 출처: https://www.happycoders.eu/java/filechannel-bytebuffer-memory-mapped-file-locks/ NIO의 장점은 https://homoefficio.github.i">
<meta name="twitter:image" content="https://i.imgur.com/vEL6ni9.png">
    
        <meta rel="publisher" content="https://plus.google.com/+오명운"/>
    
    
    
        <meta property="og:image" content="https://www.gravatar.com/avatar/30f0244ab86396288cdb62c3591c0c30?s=640"/>
    
    
        <meta property="og:image" content="/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/http:/www.allitebooks.com/wp-content/uploads/2016/03/Java-IO-NIO-and-NIO.2.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/http://www.allitebooks.com/wp-content/uploads/2016/03/Java-IO-NIO-and-NIO.2.jpg" />
    
    
        <meta property="og:image" content="/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/cover-filechannel-directbuffer.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/cover-filechannel-directbuffer.png" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-79893978-1']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6494847158566766",
    enable_page_level_ads: true
  });
</script>
</head>

    <body>
        <div id="blog">
            <header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">뒤태지존의 끄적거림</a>
    </h1>
    
        <a class="header-right-picture" href="/#about">
            <img class="header-picture" src="https://www.gravatar.com/avatar/30f0244ab86396288cdb62c3591c0c30?s=90"/>
        </a>
    
</header>
            <nav id="sidebar" data-behavior="1">
    
    <div class="sidebar-profile">
        <a href="/#about">
            
            <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/30f0244ab86396288cdb62c3591c0c30?s=90"/>
            
        </a>
        <span class="sidebar-profile-name">HomoEfficio</span>
    </div>
    
    
    <ul class="sidebar-buttons">
        
        <li class="sidebar-button">
            
                <a  class="sidebar-button-link "
                    href="/ 
                    ">
            
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">Home</span>
                </a>
        </li>
        
        <li class="sidebar-button">
            
                <a  class="sidebar-button-link "
                    href="/all-categories
                            ">
            
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">Categories</span>
                </a>
        </li>
        
        <li class="sidebar-button">
            
                <a  class="sidebar-button-link "
                    href="/all-tags
                            ">
            
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">Tags</span>
                </a>
        </li>
        
        <li class="sidebar-button">
            
                <a  class="sidebar-button-link "
                    href="/all-archives
                            ">
            
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">Archives</span>
                </a>
        </li>
        
        <li class="sidebar-button">
            
                <a  class="sidebar-button-link st-search-show-outputs"
                    href="#search
                            ">
            
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">Search</span>
                </a>
        </li>
        
        <li class="sidebar-button">
            
                <a  class="sidebar-button-link "
                    href="#about
                            ">
            
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">About me</span>
                </a>
        </li>
        
    </ul>
    
    <ul class="sidebar-buttons">
        
        <li class="sidebar-button">
            
                <a  class="sidebar-button-link " href="https://github.com/HomoEfficio" target="_blank">
            
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
        <li class="sidebar-button">
            
                <a  class="sidebar-button-link " href="mailto:homo.efficio@gmail.com" target="_blank">
            
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">Mail</span>
                </a>
        </li>
        
    </ul>
    
    <ul class="sidebar-buttons">
        
        <li class="sidebar-button">
            
                <a  class="sidebar-button-link "
                    href="/atom.xml
                            ">
            
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
    </ul>
    
</nav>
            <div id="main" data-behavior="1">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
        <div class="post-header-cover" style="background-image:url('/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/cover-filechannel-directbuffer.png');">
            <div class="post-header main-content-wrap">
    
        <h1 class="post-title" itemprop="headline">Java NIO FileChannel 과 DirectByteBuffer</h1>
    
    <div class="post-meta">
    <time  itemprop="datePublished" content="Mon Aug 10 2020 23:44:59 GMT+0900">
        Aug 10, 2020
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Technique/">Technique</a>


    
</div>
</div>
        </div>
    
    <div class="post-content markdown main-content-wrap" itemprop="articleBody">
        
            <p>Java 4에서 도입된 NIO 덕분에 <code>FileChannel</code>과 <code>ByteBuffer</code>를 이용해서 File I/O 를 수행할 수 있게 됐다.</p>
<p><img src="https://i.imgur.com/vEL6ni9.png" alt="Imgur"><br>그림 출처: <a href="https://www.happycoders.eu/java/filechannel-bytebuffer-memory-mapped-file-locks/" target="_blank" rel="noopener">https://www.happycoders.eu/java/filechannel-bytebuffer-memory-mapped-file-locks/</a></p>
<p>NIO의 장점은 <a href="https://homoefficio.github.io/2016/08/06/Java-NIO는-생각만큼-non-blocking-하지-않다/">https://homoefficio.github.io/2016/08/06/Java-NIO는-생각만큼-non-blocking-하지-않다/</a> 를 참고하고, 여기에서는 <code>FileChannel</code>과 <code>DirectBuffer</code> 얘기만 다룬다.</p>
<p><code>ByteBuffer</code>는 생성되는 위치를 기준으로 크게 나눠보면 JVM Heap 내에 생성되는 <code>HeapByteBuffer</code>와 JVM Heap 밖에 있는 Native 공간에 생성되는 <code>DirectByteBuffer</code>로 나눌 수 있다. 아래 그림에는 먼저 <code>HeapByteBuffer</code>와 <code>MappedByteBuffer</code>로 구분되는 걸로 보이는데 <code>MappedByteBuffer</code>도 Native 공간에 생성되며 파일 일부를 메모리에 매핑한다는 점 외에는 일반적인 direct byte buffer 와 동작이 다르지 않다고 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/MappedByteBuffer.html" target="_blank" rel="noopener">API 문서</a>에 나와있다.</p>
<p><img src="https://i.imgur.com/AE4p00B.png" alt="Imgur"></p>
<p>위 그림에는 안 나와있지만 <code>DirectByteBuffer</code>는 <code>DirectBuffer</code> 인터페이스를 구현하고 있다.</p>
<p><code>HeapByteBuffer</code>를 사용하면 JVM의 GC에 안전하게 의지할 수 있지만, CPU 개입 없이 I/O를 수행할 수 있고 불필요한 copy 부하가 발생하지 않아 성능적으로 유리한 점이 많은 DMA(DirectMemoryAccess)는 활용할 수 없다.</p>
<p>반대로 <code>DirectByteBuffer</code>를 사용하면 DMA의 혜택을 얻을 수 있지만, JVM의 GC를 벗어나게 되므로 메모리 관리 부담이 생겨난다.</p>
<p>그래서 <code>FileChannel</code> 을 사용할 때 상황에 맞게 <code>HeapByteBuffer</code>나 <code>DirectByteBuffer</code> 중에 골라서 쓰면 될 것 같..지만, 실상은 꼭 그렇지는 않다!</p>
<p>이제부터 코드와 함께 그 내부를 살짝 들여다보자. 앞으로 나오는 내용은 모두 Java 8 기준이다.</p>
<h1 id="FileChannel-write-ByteBuffer"><a href="#FileChannel-write-ByteBuffer" class="headerlink" title="FileChannel.write(ByteBuffer)"></a>FileChannel.write(ByteBuffer)</h1><p><code>HeapByteBuffer</code>에 담겨 있는 내용을 파일에 저장하려면 대략 아래와 같은 코드를 사용하게 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String contents = <span class="string">"abcde"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] byteArr = contents.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.wrap(byteArr);  <span class="comment">// HeapByteBuffer를 반환한다.</span></span><br><span class="line"><span class="comment">// 또는</span></span><br><span class="line"><span class="comment">// ByteBuffer byteBuffer = ByteBuffer.allocate(byteArr.length);    // HeapByteBuffer를 반환한다.</span></span><br><span class="line"><span class="comment">// byteBuffer.put(byteArr);</span></span><br><span class="line"><span class="comment">// byteBuffer.flip();</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"isDirect? "</span> + byteBuffer.isDirect());  <span class="comment">// false</span></span><br><span class="line">fileChannel.write(byteBuffer);</span><br></pre></td></tr></table></figure>
<p>위 코드에는 <code>DirectByteBuffer</code>가 전혀 나오지 않는다.</p>
<p>그런데 막상 실행해서 <a href="https://homoefficio.github.io/2020/04/09/Java-Native-Memory-Tracking/">jcmd로 Native 메모리를 모니터링</a> 해보면, <code>DirectByteBuffer</code>가 사용하는 Native 메모리를 나타내는 Internal 항목이 위 사용한 Buffer의 크기만큼 증가하는 것을 확인할 수 있다. 대략 다음과 같은 내용이 표시된다.</p>
<p><img src="https://i.imgur.com/t9gmDhx.png" alt=""></p>
<p>분명히 <code>HeapByteBuffer</code>를 사용했는데 왜 Native 메모리가 동원되는 걸까?</p>
<h1 id="FileChannelImpl-write-ByteBuffer-와-그-이후"><a href="#FileChannelImpl-write-ByteBuffer-와-그-이후" class="headerlink" title="FileChannelImpl.write(ByteBuffer) 와 그 이후"></a>FileChannelImpl.write(ByteBuffer) 와 그 이후</h1><p>특별히 지정하지 않는다면 인터페이스인 <code>FileChannel</code>의 구현체로 <code>sun.nio.ch.FileChannelImpl</code>이 사용된다. 코드는 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.nio.ch.FileChannelImpl</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (!writable)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NonWritableChannelException();</span><br><span class="line">        <span class="keyword">synchronized</span> (positionLock) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> ti = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                begin();</span><br><span class="line">                ti = threads.add();</span><br><span class="line">                <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    n = IOUtil.write(fd, src, -<span class="number">1</span>, nd);  <span class="comment">//&lt;=== 여기!!!</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class="line">                <span class="keyword">return</span> IOStatus.normalize(n);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                threads.remove(ti);</span><br><span class="line">                end(n &gt; <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>IOUtil.write()</code>는 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.nio.ch.IOUtil</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(FileDescriptor fd, ByteBuffer src, <span class="keyword">long</span> position,</span></span></span><br><span class="line"><span class="function"><span class="params">                     NativeDispatcher nd)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (src <span class="keyword">instanceof</span> DirectBuffer)</span><br><span class="line">            <span class="keyword">return</span> writeFromNativeBuffer(fd, src, position, nd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Substitute a native buffer</span></span><br><span class="line">        <span class="keyword">int</span> pos = src.position();</span><br><span class="line">        <span class="keyword">int</span> lim = src.limit();</span><br><span class="line">        <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">        <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">        ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);  <span class="comment">//&lt;=== 여기!!!</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bb.put(src);</span><br><span class="line">            bb.flip();</span><br><span class="line">            <span class="comment">// Do not update src until we see how many bytes were written</span></span><br><span class="line">            src.position(pos);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> n = writeFromNativeBuffer(fd, bb, position, nd);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// now update src</span></span><br><span class="line">                src.position(pos + n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(bb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>오호 특이한 점이 눈에 들어온다. 인자로 받아온 <code>ByteBuffer</code>의 Type이 <code>DirectBuffer</code>이면 <code>writeFromNativeBuffer()</code>를 호출하고 반환하지만, <code>DirectBuffer</code>가 아니면 <code>Util.getTemporaryDirectBuffer(rem)</code> 이렇게 슬그머니 <code>DirectBuffer</code>를 생성한다!!</p>
<p><img src="https://i.imgur.com/72E8YHH.jpg?1" alt="Imgur"></p>
<p>잠시 곁다리로 빠져보자면, 몰래 대체품을 만들어 쓰기는 하지만 그래도 양심은 있는지 다음과 같이 개발자가 <code>HeapByteBuffer</code> 생성 시 지정한 크기가 아니라 실제 read/write 할 데이터 크기만큼의 <code>DirectByteBuffer</code>만 생성하는 점은 그래도 높이 쳐줄 수 있다. 그런데 이마저도 나중에 살펴볼 <code>BufferCache</code> 동작 방식을 생각해보면 좋다고만 할 수는 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);  <span class="comment">// 버퍼의 크기가 아니라 실제 read/write 해야할 데이터 크기(limit - position)</span></span><br><span class="line">ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);  <span class="comment">//&lt;=== 여기!!!</span></span><br></pre></td></tr></table></figure>
<p>이어서 계속 따라가보자. <code>Util.getTemporaryDirectBuffer(rem)</code>은 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.nio.ch.Util</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">getTemporaryDirectBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If a buffer of this size is too large for the cache, there</span></span><br><span class="line">        <span class="comment">// should not be a buffer in the cache that is at least as</span></span><br><span class="line">        <span class="comment">// large. So we'll just create a new one. Also, we don't have</span></span><br><span class="line">        <span class="comment">// to remove the buffer from the cache (as this method does</span></span><br><span class="line">        <span class="comment">// below) given that we won't put the new buffer in the cache.</span></span><br><span class="line">        <span class="keyword">if</span> (isBufferTooLarge(size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ByteBuffer.allocateDirect(size);  <span class="comment">//&lt;=== 여기!!!</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BufferCache cache = bufferCache.get();</span><br><span class="line">        ByteBuffer buf = cache.get(size);</span><br><span class="line">        <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> buf;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No suitable buffer in the cache so we need to allocate a new</span></span><br><span class="line">            <span class="comment">// one. To avoid the cache growing then we remove the first</span></span><br><span class="line">            <span class="comment">// buffer from the cache and free it.</span></span><br><span class="line">            <span class="keyword">if</span> (!cache.isEmpty()) &#123;</span><br><span class="line">                buf = cache.removeFirst();</span><br><span class="line">                free(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ByteBuffer.allocateDirect(size);  <span class="comment">//&lt;=== 여기!!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>대충 뭔가 재사용을 위해 캐시 개념을 사용하는 것 같은데 여튼 결국에는 <code>ByteBuffer.allocateDirect(size)</code>를 호출해서 <code>DirectByteBuffer</code>를 생성한다. <code>ByteBuffer.allocateDirect(size)</code>는 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.nio.ByteBuffer</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>즉, 특별한 설정 없이 <strong>일반적인 상황에서 <code>FileChannel.write()</code>을 사용하면 개발자가 작성한 프로그램 코드에서 <code>HeapByteBuffer</code>를 사용했더라도 내부적으로는 그 <code>HeapByteBuffer</code>가 사용되지 않고 항상 <code>DirectByteBuffer</code>가 사용된다.</strong> 코드 확인 결과 <strong><code>FileChannel.read()</code>도 마찬가지</strong>다.</p>
<p>상당히 당황스럽다. 게다가 이런 얘기를 왜 API 문서나 기타 자료에서 쉽게 접할 수 없는지는 솔직히 의문이다.</p>
<p>암튼 그래.. 내가 쓰라고 한 건 무시하고 나 몰래 <code>DirectByteBuffer</code>를 만들어서 사용하네.. 근데 뭐가 문제임? 어쨌거나 잘 돌면 되는 거 아님?</p>
<p>이제부터 현장에서 발생했던 사례 얘기를 풀어본다. 만약 늘 아래 사례와 같이 동작한다면 상당히 심각한 버그라고 볼 수 있는데, 워낙 개발을 못 하는지라 어느 부분에선가 내가 코드를 잘못 짰을 수도 있기 때문에 늘 발생하는 상황이라고 단정할 수는 없다. 어쨌든 호기심이 생긴다면 이어서 쭉 보자.</p>
<h1 id="DirectByteBuffer-메모리-회수"><a href="#DirectByteBuffer-메모리-회수" class="headerlink" title="DirectByteBuffer 메모리 회수"></a>DirectByteBuffer 메모리 회수</h1><p>앞에서 <code>DirectByteBuffer</code>를 사용하면 DMA 혜택을 얻지만 메모리 관리 부담이 생긴다고 했다. <code>DirectByteBuffer</code> 메모리는 어떻게 회수되는 걸까? 여러 자료 찾아봤는데 대략 이런 말로 귀결된다.</p>
<blockquote>
<p>Native 메모리를 참조하는 객체는 결국 JVM Heap 안에 생성되며,<br>이 객체가 JVM의 GC에 의해 회수되면 이 객체가 참조하는 Native 메모리는<br>JVM이 아닌 다른 메커니즘에 의해 어쨌든 회수된다.</p>
</blockquote>
<p>요는 <strong><code>DirectByteBuffer</code>를 사용해도 간접적이긴 하지만 결국에는 JVM GC에 의해 회수가 시작된다</strong>는 얘기다. 오 그럼 바로 회수되는 건 아니지만 다행스럽게도 결국 JVM GC가 챙겨주시는 거나 마찬가지네~</p>
<p>그런데 위 설명과는 다르게 어느 정도 시간이 지나면 결국 늘 이 분을 영접하게 되었다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Direct buffer memory</span><br></pre></td></tr></table></figure>
<p>처음에는 ‘아 왜요~~ 저 <code>DirectByteBuffer</code> 쓰지도 않는데 저한테 왜 이러세요 진짜~‘ 였다. 그런데 에러 로그를 따라가보니 위에서 설명한 것처럼 나 몰래 응큼하게 내부적으로 <code>DirectByteBuffer</code>가 사용된다는 것까지는 알게 되었다. 그런데 메모리 반납은? 나 몰래 만들었으면 나 몰래 반납도 해줘야 하는 거 아님? 난 쪼렙 하수지만 넌 신성한 JDK 잖아!</p>
<p>여러 번 테스트 해봤는데 몇 시간, 심지어 며칠이 지나도 반납 안 해주더라.. JDK고 나발이고 나는 분명히 <code>HeapByteBuffer</code>를 전달해줬는데 나 몰래 <code>DirectByteBuffer</code>랑 바람 피우고, 그것도 모자라 지가 쓴 카드값까지 나한테..</p>
<p><img src="https://i.imgur.com/Nejwtsv.png" alt="Imgur"></p>
<p>어쨌든 상황을 정리해보면 다음과 같다.</p>
<blockquote>
<p>일반적으로 <code>FileChannel</code>에 데이터를 write할 때는 결국 항상 <code>DirectByteBuffer</code>가 사용되는데,<br><code>OutOfMemoryError: Direct buffer memory</code>가 계속 발생하는 걸로 봐서는,<br><code>DirectByteBuffer</code>로 사용된 Native 메모리가 제대로 회수되지 않는(것 같)다.</p>
</blockquote>
<p>자바에 내가 명시적으로 GC를 확실하게 유발할 수 있는 수단이 있는 것도 아닌데.. 망했.. 이러면 <code>FileChannel</code>은 못 쓰는 건데.. API 문서에도 다른 자료에도 왜 시원한 해법이 없지? 설마 아무도 <code>FileChannel</code>을 안 쓰는 건가? 그럴리가.. 내가 어딘가 잘못 짠 거겠지..</p>
<p>별 생각이 다 드는 가운데 여기서 대반전!</p>
<h1 id="DirectByteBuffer-메모리-회수-방법"><a href="#DirectByteBuffer-메모리-회수-방법" class="headerlink" title="DirectByteBuffer 메모리 회수 방법"></a>DirectByteBuffer 메모리 회수 방법</h1><p><code>DirectByteBuffer</code> 메모리는, JVM의 Heap 밖에 있어서 JVM GC가 아닌 다른 메커니즘에 의해 회수된다는 그 <strong><code>DirectByteBuffer</code> 메모리는, 놀랍게도 Java 코드로 명시적으로 바로 회수할 수 있는 방법이 있었다.</strong> 아무리 검색해도 찾을 수가 없던 희귀한 내용이지만 바로 공유한다. 위에서 살펴본 코드 중에 답이 있었다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.nio.ch.Util</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">getTemporaryDirectBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If a buffer of this size is too large for the cache, there</span></span><br><span class="line">        <span class="comment">// should not be a buffer in the cache that is at least as</span></span><br><span class="line">        <span class="comment">// large. So we'll just create a new one. Also, we don't have</span></span><br><span class="line">        <span class="comment">// to remove the buffer from the cache (as this method does</span></span><br><span class="line">        <span class="comment">// below) given that we won't put the new buffer in the cache.</span></span><br><span class="line">        <span class="keyword">if</span> (isBufferTooLarge(size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ByteBuffer.allocateDirect(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BufferCache cache = bufferCache.get();</span><br><span class="line">        ByteBuffer buf = cache.get(size);</span><br><span class="line">        <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> buf;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No suitable buffer in the cache so we need to allocate a new</span></span><br><span class="line">            <span class="comment">// one. To avoid the cache growing then we remove the first</span></span><br><span class="line">            <span class="comment">// buffer from the cache and free it.</span></span><br><span class="line">            <span class="keyword">if</span> (!cache.isEmpty()) &#123;</span><br><span class="line">                buf = cache.removeFirst();</span><br><span class="line">                free(buf);            <span class="comment">//&lt;=== 여기!!!</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ByteBuffer.allocateDirect(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>엉? <code>free(buf)</code>가 있네? 어떻게 생겼나 한 번 볼까? 부왘ㅋㅋ 대박!!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.nio.ch.Util</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(ByteBuffer buf)</span> </span>&#123;</span><br><span class="line">        ((DirectBuffer)buf).cleaner().clean();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>응큼하게 바람 피우고 카드값 떠넘기는 <code>HeapByteBuffer</code>와 결별(사실 <code>HeapByteBuffer</code>는 죄가 없다. <code>FileChannel</code> 구현부가 죄인이지)하고 내가 그냥 <code>DirectByteBuffer</code>와 사랑에 빠지기로 했다. 그래서 다음과 같이 <code>HeapByteBuffer</code>를 사용하던 코드를</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf1 = ByteBuffer.allocate(size);</span><br><span class="line">...</span><br><span class="line">buf1.flip();</span><br><span class="line">fileChannel.write(buf1);</span><br><span class="line">...</span><br><span class="line">ByteBuffer buf2 = ByteBuffer.wrap(byteArray);</span><br><span class="line">fileChannel.write(buf2);</span><br></pre></td></tr></table></figure>
<p>다음과 같이 명시적으로 <code>DirectByteBuffer</code>를 생성하고 사용하고 회수하도록 모두 바꾸고나니,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);</span><br><span class="line">  ...</span><br><span class="line">  directBuffer.flip();</span><br><span class="line">  fileChannel.write(directBuffer);</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  ((DirectBuffer)directBuffer).cleaner().clean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>놀랍게도 <strong><code>((DirectBuffer)directBuffer).cleaner().clean()</code>가 호출된 후 <code>jcmd</code>로 확인해보면 Internal 영역이 명시적으로 사용한 <code>DirectByteBuffer</code> 크기만큼 바로 줄어드는 것을 확인할 수 있었다.</strong> 그리고 영 반갑지 않은 <code>java.lang.OutOfMemoryError: Direct buffer memory</code>도 다시 볼 일 없게 됐다.</p>
<p>이렇게 간단하고 직접적인 해결 방법이 이미 존재하는데 왜 그런 게 API 문서에 언급조차 없는지, 그리고 그 해결법도 왜 <code>public static</code>이 아니라 <code>private static</code> 메서드로 선언해둔 건지는 여전히 의문이다. 이 정도면 거의 일부러 감춰둔 정도 같기도 해서 ‘이거 써도 되는 거야?’라는 의문조차 들 정도..</p>
<p>그런데 한 가지 궁금한 게 더 있다.</p>
<p><code>HeapByteBuffer</code>를 전달해줘도 내부적으로 응큼하게 <code>DirectByteBuffer</code>를 몰래 만드는 <code>getTemporaryDirectBuffer()</code> 내부에서, <code>DirectByteBuffer</code> 메모리를 회수할 수 있는 <code>free()</code> 메서드가 호출되고 있음에도 불구하고 몰래 만들어진 <code>DirectByteBuffer</code>가 회수되지 않는 이유는 뭘까? 이건 <code>BufferCache</code>를 보면 알 수 있다.</p>
<h1 id="BufferCache"><a href="#BufferCache" class="headerlink" title="BufferCache"></a>BufferCache</h1><p>코드를 다시 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.nio.ch.Util</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">getTemporaryDirectBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If a buffer of this size is too large for the cache, there</span></span><br><span class="line">        <span class="comment">// should not be a buffer in the cache that is at least as</span></span><br><span class="line">        <span class="comment">// large. So we'll just create a new one. Also, we don't have</span></span><br><span class="line">        <span class="comment">// to remove the buffer from the cache (as this method does</span></span><br><span class="line">        <span class="comment">// below) given that we won't put the new buffer in the cache.</span></span><br><span class="line">        <span class="keyword">if</span> (isBufferTooLarge(size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ByteBuffer.allocateDirect(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BufferCache cache = bufferCache.get();</span><br><span class="line">        ByteBuffer buf = cache.get(size);</span><br><span class="line">        <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> buf;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No suitable buffer in the cache so we need to allocate a new</span></span><br><span class="line">            <span class="comment">// one. To avoid the cache growing then we remove the first</span></span><br><span class="line">            <span class="comment">// buffer from the cache and free it.</span></span><br><span class="line">            <span class="keyword">if</span> (!cache.isEmpty()) &#123;</span><br><span class="line">                buf = cache.removeFirst();  <span class="comment">//&lt;=== 여기!!!</span></span><br><span class="line">                free(buf);            <span class="comment">//&lt;=== 여기!!!</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ByteBuffer.allocateDirect(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>BufferCache</code>에 동일한 크기의 <code>DirectByteBuffer</code>가 있으면 그걸 재사용하고, 없으면 캐시에 있는 다른 크기의 <code>DirectByteBuffer</code>를 <code>free()</code>를 이용해서 하나 삭제한다. 그렇게 해서 캐쉬의 총 갯수가 늘어나지 않게 한다. 실제로도 이렇게 잘 동작한다.</p>
<p>예를 들어 크기가 10M로 모두 같은 <code>HeapByteBuffer</code>를 3개 생성해서 <code>FileChannel.write()</code>에 사용하면 내부적으로 <code>DirectByteBuffer</code>가 생성되므로 10M 짜리 <code>DirectByteBuffer</code> 3개, 총 30M가 사용될 것 같지만, 위에 나오는 BufferCache 덕분에 실제로는 10M 짜리 <code>DirectByteBuffer</code> 한 개만 생성되고 재사용된다.</p>
<p>여기까지는 좋은데 문제는 맨 마지막 부분 <code>return ByteBuffer.allocateDirect(size)</code>에서 새로 생성된 후 반환되는 <code>DirectByteBuffer</code>는 회수되지 않는(걸로 보인)다는 점이다.</p>
<p><code>BufferCache</code>는 아래와 같이 <code>ThreadLocal</code>에 담겨서 per-thread로 존재한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.nio.ch.Util</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-thread cache of temporary direct buffers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;BufferCache&gt; bufferCache =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;BufferCache&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> BufferCache <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BufferCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>위에서 개발자가 명시적으로 생성한 <code>HeapByteBuffer</code> 대신 내부적으로 <code>DirectByteBuffer</code>를 생성할 때 실제 read/write 할 만큼의 <code>DirectByteBuffer</code>를 생성한다고 했다. 필요한 만큼만 새로 생성하므로 메모리 사용량에 있어서는 유리하지만, 그 필요한 만큼이 그때그때 다른 상황에서는 지금 살펴본 <code>BufferCache</code>의 hit율이 떨어져서 <code>DirectByteBuffer</code>의 생성 빈도가 많아질 수 있다. <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" target="_blank" rel="noopener">ByteBuffer API</a> 문서에 따르면 <code>DirectByteBuffer</code>는 메모리 할당/해제 비용이 <code>HeapByteBuffer</code>보다 더 크다고 한다. 따라서 <code>DirectByteBuffer</code> 생성 빈도가 많으면 성능에 악영향을 미칠 수 있다. </p>
<p>정리하면, 하나의 스레드에서 이런 비명시적 방식(개발자가 <code>HeapByteBuffer</code>를 <code>FileChannel.write()</code>에 인자로 전달해줘도 <code>FileChannelImpl</code>이 내부적으로 몰래 <code>DirectByteBuffer</code>를 생성하는 방식)으로 <code>DirectByteBuffer</code>가 생성되면,  </p>
<ul>
<li>크기가 동일한 <code>HeapByteBuffer</code>를 여러개 만들어도  </li>
<li><code>BufferCache</code> 덕분에 해당 스레드 내에서는 <code>DirectByteBuffer</code>가 하나만 만들어지고 재사용될 수는 있지만,  </li>
<li>그 한 개의 <code>DirectByteBuffer</code>가 제대로 회수되지 않으면,</li>
<li>새로운 스레드가 실행될 때마다 계속 누적되다가 결국 OutOfMemory 에러를 맞이하게 된다.</li>
</ul>
<h1 id="XX-MaxDirectMemorySize-옵션"><a href="#XX-MaxDirectMemorySize-옵션" class="headerlink" title="XX:MaxDirectMemorySize 옵션"></a>XX:MaxDirectMemorySize 옵션</h1><p><code>DirectByteBuffer</code>가 사용하는 Native Memory 최대 크기를 지정할 수 있는 옵션이 있다. <code>XX:MaxDirectMemorySize</code>인데 <code>DirectByteBuffer</code> 메모리가 제대로 회수되지 않고 누적되다가 최대 크기를 넘는다면 어떻게 될까?</p>
<ol>
<li>오랫동안 사용되지 않고 메모리만 점유하고 있던 <code>DirectByteBuffer</code>를 알아서 회수한다.</li>
<li><code>java.lang.OutOfMemoryError: Direct buffer memory</code>가 발생한다.</li>
</ol>
<p>혹시 하는 마음에 1을 기대했는데, 현실은 2다.</p>
<h1 id="실제-검증-몰래-만들어진-DirectByteBuffer-메모리도-회수된다"><a href="#실제-검증-몰래-만들어진-DirectByteBuffer-메모리도-회수된다" class="headerlink" title="실제 검증 - 몰래 만들어진 DirectByteBuffer 메모리도 회수된다!!"></a>실제 검증 - 몰래 만들어진 <code>DirectByteBuffer</code> 메모리도 회수된다!!</h1><p>내가 잘못 짰을 수도 있는 로직과 뒤섞인 상태로는, 몰래 만들어지는 <code>DirectByteBuffer</code>가 항상 회수되지 않는다고 확언을 할 수 없으므로 실험용 간단한 프로그램을 만들어서 검증해봤다.</p>
<p><a href="https://github.com/HomoEfficio/scratchpad-bytebuffer" target="_blank" rel="noopener">https://github.com/HomoEfficio/scratchpad-bytebuffer</a> 를 참고하면 직접 요리조리 해볼 수 있다.</p>
<p>README에 있는대로, 프로그램 실행해서 VisualVM 으로 강제 GC를 시킨 후에 <code>jcmd</code>로 확인해보면 Native Memory가 회수되는 것을 확인할 수 있었다.</p>
<p>따라서 <strong>몰래 만들어진 <code>DirectByteBuffer</code>도 정상적인 경우라면 해당 <code>DirectByteBuffer</code>를 참조하는 객체(A라고 하자)가 GC될 때 <code>DirectByteBuffer</code> 메모리도 함께 회수된다.</strong> 라고 결론 지을 수 있겠다.</p>
<p>하지만 그래도 A가 언제 GC 될 지 알 수 없고, GC 전까지 <code>DirectByteBuffer</code>는 계속 Native Memory를 점유하게 된다. 아마도 잘못 작성한 코드 때문이겠지만 알 수 없는 이유로 Native Memory 가 장시간 계속 회수되지 않는다면, 우리에겐 <code>((DirectBuffer)directBuffer).cleaner().clean()</code> 라는 무기가 있다는 사실을 알아두면 좋다.</p>
<h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><blockquote>
<ul>
<li><p>특별한 <code>FileChannel</code> 구현체를 사용하지 않는다면, <code>FileChannel</code>에 read/write 할 때 <code>HeapByteBuffer</code>를 사용해도 내부적으로 <code>DirectByteBuffer</code>가 사용된다.</p>
</li>
<li><p>내부적으로 사용되는 <code>DirectByteBuffer</code>가 제대로 회수되지 않으면 <code>java.lang.OutOfMemoryError: Direct buffer memory</code>가 발생할 수 있다.</p>
</li>
<li><p>이렇게 <code>FileChannel</code>에 read/write 하는 코드에 의해 OOM이 발생한다면,</p>
<ul>
<li><code>HeapByteBuffer</code>을 사용하지 말고 명시적으로 <code>DirectByteBuffer</code>를 사용하고,  </li>
<li><code>((DirectBuffer)directBuffer).cleaner().clean()</code>를 사용해서 명시적으로 해제하자.</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="함께-보기"><a href="#함께-보기" class="headerlink" title="함께 보기"></a>함께 보기</h1><ul>
<li><a href="https://homoefficio.github.io/2016/08/06/Java-NIO는-생각만큼-non-blocking-하지-않다/">Java NIO는 생각만큼 non-blocking 하지 않다</a></li>
<li><a href="https://homoefficio.github.io/2019/02/27/Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기/">Java NIO Direct Buffer를 이용해서 대용량 파일 행 기준으로 쪼개기</a></li>
<li><a href="https://homoefficio.github.io/2016/08/13/대용량-파일을-AsynchronousFileChannel로-다뤄보기/">대용량 파일을 AsynchronousFileChannel로 다뤄보기</a></li>
<li><a href="https://homoefficio.github.io/2020/04/09/Java-Native-Memory-Tracking/">Java Native Memory Tracking</a></li>
</ul>

        
        
            
        
        <hr/>
        <div>
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><a href='https://github.com/homoefficio' target='_blank'>HomoEfficio</a>가 작성한 이 저작물은(는) <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">크리에이티브 커먼즈 저작자표시-비영리-동일조건변경허락 4.0 국제 라이선스</a>에 따라 이용할 수 있습니다.
        </div>
    </div>
    <div class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/BufferCache/">BufferCache</a> <a class="tag tag--primary tag--small t-link" href="/tags/ByteBuffer/">ByteBuffer</a> <a class="tag tag--primary tag--small t-link" href="/tags/Direct-buffer-memory/">Direct buffer memory</a> <a class="tag tag--primary tag--small t-link" href="/tags/DirectBuffer/">DirectBuffer</a> <a class="tag tag--primary tag--small t-link" href="/tags/DirectByteBuffer/">DirectByteBuffer</a> <a class="tag tag--primary tag--small t-link" href="/tags/FileChannel/">FileChannel</a> <a class="tag tag--primary tag--small t-link" href="/tags/Garbage-Collection/">Garbage Collection</a> <a class="tag tag--primary tag--small t-link" href="/tags/HeapByteBuffer/">HeapByteBuffer</a> <a class="tag tag--primary tag--small t-link" href="/tags/Java/">Java</a> <a class="tag tag--primary tag--small t-link" href="/tags/NIO/">NIO</a> <a class="tag tag--primary tag--small t-link" href="/tags/Native-Memory/">Native Memory</a> <a class="tag tag--primary tag--small t-link" href="/tags/OutOfMemoryError/">OutOfMemoryError</a> <a class="tag tag--primary tag--small t-link" href="/tags/jcmd/">jcmd</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2020/08/27/Batch-작업과-Connection-Pool/"  data-tooltip="Batch 작업과 Connection Pool">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2020/08/06/Spring-WebFlux-RequestBody/" data-tooltip="Spring WebFlux RequestBody">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#disqus_thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>
        
            <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2021 HomoEfficio. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="1">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2020/08/27/Batch-작업과-Connection-Pool/"  data-tooltip="Batch 작업과 Connection Pool">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2020/08/06/Spring-WebFlux-RequestBody/" data-tooltip="Spring WebFlux RequestBody">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#disqus_thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>
                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="1">
    <ul class="share-options">
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/">
                <i class="fa fa-google-plus"></i><span class="">Share on Google Plus</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/">
                <i class="fa fa-facebook-official"></i><span>Share on Facebook</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://homoefficio.github.io/2020/08/10/Java-NIO-FileChannel-과-DirectByteBuffer/">
                <i class="fa fa-twitter"></i><span>Share on Twitter</span>
            </a>
        </li>
    </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
            
        </div>
        <div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="https://www.gravatar.com/avatar/30f0244ab86396288cdb62c3591c0c30?s=110"/>
        
            <h4 id="about-card-name">HomoEfficio</h4>
        
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Seoul, Korea.
            </h5>
        
    </div>
</div>
        <div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script.min.js"></script>
<!--SCRIPTS END-->

    <script type="text/javascript">
        var disqus_shortname = 'hanmomhanda';
        (function() {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>



</html>
