<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>뒤태지존의 끄적거림</title>
  
  <subtitle>개발</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://homoefficio.github.io/"/>
  <updated>2020-04-09T07:52:24.184Z</updated>
  <id>http://homoefficio.github.io/</id>
  
  <author>
    <name>HomoEfficio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Native Memory Tracking</title>
    <link href="http://homoefficio.github.io/2020/04/09/Java-Native-Memory-Tracking/"/>
    <id>http://homoefficio.github.io/2020/04/09/Java-Native-Memory-Tracking/</id>
    <published>2020-04-09T07:26:35.000Z</published>
    <updated>2020-04-09T07:52:24.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Native-Memory-Tracking"><a href="#Java-Native-Memory-Tracking" class="headerlink" title="Java Native Memory Tracking"></a>Java Native Memory Tracking</h1><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>자바에서도 <code>DirectBuffer</code>를 이용해서 JVM이 아닌 Native 메모리를 사용하고 DMA(Direct Memory Access)의 장점을 활용할 수 있다.</p><p>구체적인 사용법 등 자세한 내용은 <a href="https://homoefficio.github.io/2019/02/27/Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기/">Java NIO Direct Buffer를 이용해서 대용량 파일 행 기준으로 쪼개기</a>를 참고하고 장단점만 요약하면 다음과 같다.</p><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><ul><li>디스크에 있는 파일을 운영체제 메모리로 읽어들일 때 CPU를 건드리지 않는다.</li><li>운영체제 메모리에 있는 파일 내용을 JVM 내 메모리로 다시 복사할 필요가 없다.</li><li>JVM 내 힙 메모리를 쓰지 않으므로 GC를 유발하지 않는다.(물론 일정 크기를 가진 버퍼가 운영체제 메모리에 생성되는 것이고, 이 버퍼에 대한 참조 자체는 JVM 메모리 내에 생성된다)</li></ul><h3 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h3><ul><li>DMA에 사용할 버퍼 생성 시 시간이 더 소요될 수 있다.</li><li>바이트 단위로 데이터를 취급하므로, 데이터를 행 단위로 취급하기 불편하다.</li><li>일반적인 Java 메모리 분석 방법으로는 추적할 수 없다.</li></ul><p>요는 대용량 파일을 사용할 때 <code>DirectBuffer</code>를 사용하면 DMA의 장점을 누릴 수 있고 단점을 피할 수 있다.</p><h2 id="메모리-사용-추적"><a href="#메모리-사용-추적" class="headerlink" title="메모리 사용 추적"></a>메모리 사용 추적</h2><p>그런데 JVM 메모리가 아닌 Native를 사용하므로 힙 덤프나 스레드 덤프 분석, <code>jstat</code> 등 일반적인 Java 메모리 분석 방법으로는 추적이 안 된다.</p><p>대용량 파일 사용 시 장점이 많다고 하니 아무래도 <code>DirectBuffer</code> 크기도 크게 잡을 수록 성능 상으로는 유리하겠지만, 그 큰 메모리가 어떻게 사용되고 회수되는지 확인이 안 된다면 곤란하다.</p><p>어쩌지?</p><p>뭘 어째.. 검색이지.. 검색해서 찾은 답은 <code>jcmd</code>다. </p><p>간략하게 알아보자.</p><h2 id="Java-실행-옵션-추가"><a href="#Java-실행-옵션-추가" class="headerlink" title="Java 실행 옵션 추가"></a>Java 실행 옵션 추가</h2><p>어떤 Java 애플리케이션의 Native 메모리 사용을 추적하려면 애플리케이션 실행 시 다음 옵션을 추가해줘야 한다.</p><blockquote><p>-XX:NativeMemoryTracking=summary</p></blockquote><h2 id="메모리-사용-현황-베이스라인-지정"><a href="#메모리-사용-현황-베이스라인-지정" class="headerlink" title="메모리 사용 현황 베이스라인 지정"></a>메모리 사용 현황 베이스라인 지정</h2><p>이제부터 알아볼 메모리 사용 추적 방법은 <strong>어떤 기준점 대비 메모리 사용량 증감(diff)을 기반으로 한다.</strong> 따라서 먼저 비교 기준이 될 베이스라인(기준점)을 지정해준다.</p><blockquote><p>jcmd {PID} VM.native_memory baseline</p></blockquote><p>위 명령을 실행하면 PID와 함께 <code>Baseline succeed</code>라는 짤막한 메시지만 출력된다. 비교 기준인 베이스라인이 지정됐다는 뜻이다.</p><h2 id="메모리-사용-현황-출력-초기"><a href="#메모리-사용-현황-출력-초기" class="headerlink" title="메모리 사용 현황 출력 - 초기"></a>메모리 사용 현황 출력 - 초기</h2><p>이제 다음 명령을 실행하면 <strong>메모리 사용 항목별로 베이스라인 대비 사용량 증감(diff)을 보여준다.</strong></p><blockquote><p>jcmd {PID} VM.native_memory summary.diff</p></blockquote><p>지금까지 수행한 베이스라인 지정과 초기 현황 출력 결과는 다음과 같다.</p><p><img src="https://i.imgur.com/SGbIKgm.png" alt="Imgur"></p><p>그리고 Native 메모리는 Internal 항목에 표시되며, 애플리케이션 실행 후 별다른 작업 없는 초기 상태에서 Native 메모리 사용량은 44KB 이다.</p><p>위 명령은 <code>jstat</code>처럼 주기적으로 실행하는 옵션은 없는 것 같고, 필요할 때마다 직접 실행하고 출력 내용을 확인하는 방식으로 진행한다.</p><h2 id="메모리-사용-현황-출력-DirectBuffer-사용-중"><a href="#메모리-사용-현황-출력-DirectBuffer-사용-중" class="headerlink" title="메모리 사용 현황 출력 - DirectBuffer 사용 중"></a>메모리 사용 현황 출력 - DirectBuffer 사용 중</h2><p><code>DirectBuffer</code>를 사용하는 작업을 실행한 후에 다시 <code>jcmd {PID} VM.native_memory summary.diff</code>를 실행하면 다음과 같이 Internal 항목의 사용량이 기존 44KB에서 150MB로 대폭 늘어난 것을 확인할 수 있다.</p><p><img src="https://i.imgur.com/t9gmDhx.png" alt="Imgur"></p><p>실제 코드에서도 다음과 같이 3개의 <code>DirectBuffer</code>를 각 50M 씩 할당했으므로 위 그림에서 출력된 내용과 잘 부합한다.</p><p><img src="https://i.imgur.com/2AfnkJj.png" alt="Imgur"></p><h2 id="메모리-사용-현황-출력-DirectBuffer-사용-완료-후"><a href="#메모리-사용-현황-출력-DirectBuffer-사용-완료-후" class="headerlink" title="메모리 사용 현황 출력 - DirectBuffer 사용 완료 후"></a>메모리 사용 현황 출력 - DirectBuffer 사용 완료 후</h2><p><code>DirectBuffer</code>를 사용하는 작업 완료 후 별다른 조치 없이 다시 <code>jcmd {PID} VM.native_memory summary.diff</code>를 실행하면 다음과 같이 Internal 항목의 사용량이 150MB에서 328KB로 대폭 줄어든 것을 확인할 수 있다.</p><p><img src="https://i.imgur.com/PRG5Nqh.png" alt="Imgur"></p><p>즉 <code>DirectBuffer</code> 사용이 끝난 후에 자동으로 Native 메모리가 정상적으로 회수됐음을 알 수 있다.</p><h2 id="더-읽을-거리"><a href="#더-읽을-거리" class="headerlink" title="더 읽을 거리"></a>더 읽을 거리</h2><ul><li>jcmd 명령 해설(공식 문서보다 훨씬 나음): <a href="https://www.javacodegeeks.com/2016/03/jcmd-one-jdk-command-line-tool-rule.html" target="_blank" rel="noopener">https://www.javacodegeeks.com/2016/03/jcmd-one-jdk-command-line-tool-rule.html</a></li></ul><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><blockquote><ul><li><p>Java에서도 <code>DirectBuffer</code>를 이용해서 DMA를 활용할 수 있다.</p></li><li><p>DMA에 활용된 Native 메모리는 사용 완료 후 JVM GC와 무관하게(즉 다른 절차에 의해) 자동으로 반환된다.</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-Native-Memory-Tracking&quot;&gt;&lt;a href=&quot;#Java-Native-Memory-Tracking&quot; class=&quot;headerlink&quot; title=&quot;Java Native Memory Tracking&quot;&gt;&lt;/a&gt;Java 
      
    
    </summary>
    
      <category term="Performance" scheme="http://homoefficio.github.io/categories/Performance/"/>
    
    
      <category term="DMA" scheme="http://homoefficio.github.io/tags/DMA/"/>
    
      <category term="Direct Memory Access" scheme="http://homoefficio.github.io/tags/Direct-Memory-Access/"/>
    
      <category term="Native Memory" scheme="http://homoefficio.github.io/tags/Native-Memory/"/>
    
      <category term="DirectBuffer" scheme="http://homoefficio.github.io/tags/DirectBuffer/"/>
    
      <category term="jcmd" scheme="http://homoefficio.github.io/tags/jcmd/"/>
    
      <category term="NativeMemoryTracking" scheme="http://homoefficio.github.io/tags/NativeMemoryTracking/"/>
    
      <category term="VM.native_memory" scheme="http://homoefficio.github.io/tags/VM-native-memory/"/>
    
      <category term="baseline" scheme="http://homoefficio.github.io/tags/baseline/"/>
    
      <category term="summary.diff" scheme="http://homoefficio.github.io/tags/summary-diff/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data에서 Batch Insert 최적화</title>
    <link href="http://homoefficio.github.io/2020/01/25/Spring-Data%EC%97%90%EC%84%9C-Batch-Insert-%EC%B5%9C%EC%A0%81%ED%99%94/"/>
    <id>http://homoefficio.github.io/2020/01/25/Spring-Data에서-Batch-Insert-최적화/</id>
    <published>2020-01-25T14:06:24.000Z</published>
    <updated>2020-01-30T16:44:46.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Data에서-Batch-Insert-최적화"><a href="#Spring-Data에서-Batch-Insert-최적화" class="headerlink" title="Spring Data에서 Batch Insert 최적화"></a>Spring Data에서 Batch Insert 최적화</h1><p>Spring Data JPA가 안겨주는 편리함 뒤에는 가끔 성능 손실이 숨어있다. 이번에 알아볼 Batch Insert도 그런 예 중 하나다.</p><p>성능 손실 문제가 발생하는 이유와 2가지 해결 방법을 알아본다.</p><p>전체 코드는 <a href="https://github.com/HomoEfficio/micro-benchmark-spring-boot-batch-insert" target="_blank" rel="noopener">https://github.com/HomoEfficio/micro-benchmark-spring-boot-batch-insert</a> 여기에서 볼 수 있으며 아주 쉽게 직접 테스트해 볼 수도 있다.</p><h1 id="Batch-Insert란"><a href="#Batch-Insert란" class="headerlink" title="Batch Insert란?"></a>Batch Insert란?</h1><p>거창한 거 하나도 없다. 3건의 데이터를 insert 한다고 할 때,</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table1 (col1, col2) <span class="keyword">VALUES</span> (val11, val12);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table1 (col1, col2) <span class="keyword">VALUES</span> (val21, val22);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table1 (col1, col2) <span class="keyword">VALUES</span> (val31, val32);</span><br></pre></td></tr></table></figure><p>이렇게 하면 개별 insert고,</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table1 (col1, col2) <span class="keyword">VALUES</span></span><br><span class="line">(val11, val12),</span><br><span class="line">(val21, val22),</span><br><span class="line">(val31, val32);</span><br></pre></td></tr></table></figure><p>이렇게 하면 batch insert다. 그냥 봐도 batch insert 쪽이 훨씬 효율적임을 쉽게 알 수 있다.</p><p>DB 관점에서보면 간단한데, Spring Data에서 저런 DML이 DB로 전달되게 하는 건 그렇게 간단하지만은 않다.</p><h1 id="Hibernate의-Batch-Insert-제약-사항"><a href="#Hibernate의-Batch-Insert-제약-사항" class="headerlink" title="Hibernate의 Batch Insert 제약 사항"></a>Hibernate의 Batch Insert 제약 사항</h1><p><a href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#batch-session-batch-insert" target="_blank" rel="noopener">Hibernate 레퍼런스 문서 12.2.1. Batch inserts</a>의 바로 위에 다음과 같이 <strong>식별자 생성에 IDENTITY 방식을 사용하면 Hibernate가 JDBC 수준에서 batch insert를 비활성화</strong>한다고 나와있다.</p><blockquote><p>Hibernate disables insert batching at the JDBC level transparently if you use an identity identifier generator.</p></blockquote><p>비활성화하는 이유는 Hibernate 문서에는 없는 것 같아서 다시 찾아보니 StackOverflow에 <a href="https://stackoverflow.com/a/27732138" target="_blank" rel="noopener">Vlad Mihalcea가 올린 댓글</a>에서 단서를 찾을 수 있었다.</p><blockquote><p>The only drawback is that we can’t know the newly assigned value prior to executing the INSERT statement. This restriction is hindering the “transactional write behind” flushing strategy adopted by Hibernate. For this reason, Hibernates disables the JDBC batch support for entities using the IDENTITY generator.</p></blockquote><p>요는 <strong>새로 할당할 Key 값을 미리 알 수 없는 IDENTITY 방식을 사용할 때 Batch Support를 지원하면 Hibernate가 채택한 flush 방식인 ‘Transactional Write Behind’와 충돌이 발생하기 때문</strong>에, IDENTITY 방식에서는 Batch Insert를 비활성화 한다는 얘기다. 따라서 그냥 <strong>일상적으로 가장 널리 사용하는 IDENTITY 방식을 사용하면 Batch Insert는 동작하지 않는다.</strong></p><p>그렇다고 Batch Insert를 적용하기 위해 IDENTITY 방식말고 섣불리 SEQUENCE 방식이나 TABLE 방식을 잘못 사용하면 더 나쁜 결과를 불러올 수 있다. <strong>채번에 따른 부하가 상당히 큰 SEQUENCE 방식이나 TABLE 방식을 별다른 조치 없이 사용하면 Batch Insert를 쓸 수 없는 IDENTITY 방식보다 더 느리다.</strong> 자세한 내용은 <a href="https://github.com/HomoEfficio/dev-tips/blob/master/JPA-GenerationType-별-INSERT-성능-비교.md" target="_blank" rel="noopener">https://github.com/HomoEfficio/dev-tips/blob/master/JPA-GenerationType-별-INSERT-성능-비교.md</a> 를 참고한다. 나름 건질만한 내용이 꽤 있으니 꼭 한 번 보길 권한다.</p><p>문제 발생 원인에서 유추할 수 있는 해결 방법은 2가지가 있다. </p><ol><li>SEQUENCE나 TABLE 방식을 사용하면서 채번 부하를 낮추는 방법</li><li>아예 Spring Data JPA를 벗어나는 방법</li></ol><h1 id="채번-부하-절감"><a href="#채번-부하-절감" class="headerlink" title="채번 부하 절감"></a>채번 부하 절감</h1><p>Batch Insert를 사용할 수 없는 IDENTITY 방식 대신에 SEQUENCE나 TABLE 방식을 사용하면서 채번 부하를 낮추는 방법은 <a href="https://dev.to/smartyansh/best-possible-hibernate-configuration-for-batch-inserts-2a7a" target="_blank" rel="noopener">https://dev.to/smartyansh/best-possible-hibernate-configuration-for-batch-inserts-2a7a</a> 에서 찾을 수 있었다.</p><p>간단하게 정리하면 채번 자체를 Batch 방식으로 처리해서 채번 부하를 낮추는 방식이다.</p><h2 id="일반적인-채번"><a href="#일반적인-채번" class="headerlink" title="일반적인 채번"></a>일반적인 채번</h2><p>SEQUENCE 방식은 일반적으로 다음과 같이 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.SEQUENCE)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 방식을 사용하면 Sequence를 지원하는 DB에서는 Sequence를 이용해서 채번한다. 아래는 Sequence를 지원하는 H2 DB를 사용했을 때 나오는 Hibernate 로그 일부다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Hibernate: call next value for hibernate_sequence</span><br><span class="line">Hibernate: call next value for hibernate_sequence</span><br><span class="line">Hibernate: call next value for hibernate_sequence</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Sequence를 지원하지 않는 DB에서는 Table을 이용해서 채번한다. 아래는 Sequence를 지원하지 않는 MySQL DB의 로그 일부다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">SET autocommit=0</span><br><span class="line">select next_val as id_val from hibernate_sequence for update</span><br><span class="line">update hibernate_sequence set next_val= 2 where next_val=1</span><br><span class="line">commit</span><br><span class="line">autocommit=1</span><br><span class="line">autocommit=0</span><br><span class="line">select next_val as id_val from hibernate_sequence for update</span><br><span class="line">update hibernate_sequence set next_val= 3 where next_val=2</span><br><span class="line">commit</span><br><span class="line">SET autocommit=1</span><br><span class="line">SET autocommit=0</span><br><span class="line">select next_val as id_val from hibernate_sequence for update</span><br><span class="line">update hibernate_sequence set next_val= 4 where next_val=3</span><br><span class="line">commit</span><br><span class="line">SET autocommit=1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>번호 하나 딸 때마다 쿼리를 2개씩 날리게 되므로 꽤 큰 부하가 발생될 것임을 짐작할 수 있다.</p><h2 id="Batch-채번"><a href="#Batch-채번" class="headerlink" title="Batch 채번"></a>Batch 채번</h2><p>채번 자체를 Batch로 처리하면 아래와 같이 500개씩 한꺼번에 채번해서 쿼리 횟수를 대폭 줄이고 성능을 높일 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">SET autocommit=0</span><br><span class="line">select next_val as id_val from hibernate_sequence for update</span><br><span class="line">update hibernate_sequence set next_val= 501 where next_val=1</span><br><span class="line">commit</span><br><span class="line">SET autocommit=1</span><br><span class="line">SET autocommit=0</span><br><span class="line">select next_val as id_val from hibernate_sequence for update</span><br><span class="line">update hibernate_sequence set next_val= 1001 where next_val=501</span><br><span class="line">commit</span><br><span class="line">SET autocommit=1</span><br><span class="line">SET autocommit=0</span><br><span class="line">select next_val as id_val from hibernate_sequence for update</span><br><span class="line">update hibernate_sequence set next_val= 1501 where next_val=1001</span><br><span class="line">commit</span><br><span class="line">SET autocommit=1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Batch 채번은 다음과 같이 다소 복잡한 Hibernate 전용 애너테이션을 지정해야 한다. </p><p>채번 배치 크기도 애너테이션 내에서 지정해야 하므로 배치 크기 설정을 yml 파일로 외부화 할 수 없다는 단점이 있다. 또한 채번 배치 크기는 엔티티 클래스에서 Hibernate 애너테이션으로 지정해야 하고, Batch Insert의 배치 크기는 yml 파일로 지정하므로 두 값이 달라질 가능성이 있다는 것도 운영 상 단점이라고 할 수 있겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GenericGenerator</span>(</span><br><span class="line">            name = <span class="string">"SequenceGenerator"</span>,</span><br><span class="line">            strategy = <span class="string">"org.hibernate.id.enhanced.SequenceStyleGenerator"</span>,</span><br><span class="line">            parameters = &#123;</span><br><span class="line">                    <span class="meta">@Parameter</span>(name = <span class="string">"sequence_name"</span>, value = <span class="string">"hibernate_sequence"</span>),</span><br><span class="line">                    <span class="meta">@Parameter</span>(name = <span class="string">"optimizer"</span>, value = <span class="string">"pooled"</span>),</span><br><span class="line">                    <span class="meta">@Parameter</span>(name = <span class="string">"initial_value"</span>, value = <span class="string">"1"</span>),</span><br><span class="line">                    <span class="meta">@Parameter</span>(name = <span class="string">"increment_size"</span>, value = <span class="string">"500"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@GeneratedValue</span>(</span><br><span class="line">            strategy = GenerationType.SEQUENCE,</span><br><span class="line">            generator = <span class="string">"SequenceGenerator"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Data-JDBC"><a href="#Spring-Data-JDBC" class="headerlink" title="Spring Data JDBC"></a>Spring Data JDBC</h1><p>Spring Data에는 JPA만 있는 것이 아니다. <a href="https://spring.io/projects/spring-data" target="_blank" rel="noopener">https://spring.io/projects/spring-data</a> 에 보면 상당히 다양한 저장소를 지원하는 서브 프로젝트가 많이 있으며, 지금처럼 관계형 데이터베이스에서는 JPA 대신 JDBC를 사용할 수도 있다.</p><h2 id="JdbcTemplate-batchUpdate"><a href="#JdbcTemplate-batchUpdate" class="headerlink" title="JdbcTemplate.batchUpdate()"></a>JdbcTemplate.batchUpdate()</h2><p>JdbcTemplate에는 Batch를 지원하는 <code>batchUpdate()</code> 메서드가 마련돼있다. 여러 가지로 Overloading 돼 있어서 편리한 메서드를 골라서 사용하면 되는데, 여기에서는 batch 크기를 지정할 수 있는 <code>BatchPreparedStatementSetter</code>를 사용하는 아래의 메서드를 사용해서 구현해본다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">batchUpdate(String sql, BatchPreparedStatementSetter pss)</span><br></pre></td></tr></table></figure><h2 id="주요-구현-부분"><a href="#주요-구현-부분" class="headerlink" title="주요 구현 부분"></a>주요 구현 부분</h2><p><code>ItemJdbc</code>라는 객체를 <code>ITEM_JDBC</code> 테이블에 Batch Insert로 저장한다고 가정하고, 주요 구현부를 살펴보면 다음과 같다. </p><p><code>batchSize</code> 변수를 통해 배치 크기를 지정하고, 전체 데이터를 배치 크기로 나눠서 Batch Insert를 실행하고, 자투리 데이터를 다시 Batch Insert로 저장한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemJdbcRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">ItemJdbcRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;batchSize&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> batchSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAll</span><span class="params">(List&lt;ItemJdbc&gt; items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> batchCount = <span class="number">0</span>;</span><br><span class="line">        List&lt;ItemJdbc&gt; subItems = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.size(); i++) &#123;</span><br><span class="line">            subItems.add(items.get(i));</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % batchSize == <span class="number">0</span>) &#123;</span><br><span class="line">                batchCount = batchInsert(batchSize, batchCount, subItems);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!subItems.isEmpty()) &#123;</span><br><span class="line">            batchCount = batchInsert(batchSize, batchCount, subItems);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"batchCount: "</span> + batchCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">batchInsert</span><span class="params">(<span class="keyword">int</span> batchSize, <span class="keyword">int</span> batchCount, List&lt;ItemJdbc&gt; subItems)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.batchUpdate(<span class="string">"INSERT INTO ITEM_JDBC (`NAME`, `DESCRIPTION`) VALUES (?, ?)"</span>,</span><br><span class="line">                <span class="keyword">new</span> BatchPreparedStatementSetter() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                        ps.setString(<span class="number">1</span>, subItems.get(i).getName());</span><br><span class="line">                        ps.setString(<span class="number">2</span>, subItems.get(i).getDescription());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBatchSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> subItems.size();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        subItems.clear();</span><br><span class="line">        batchCount++;</span><br><span class="line">        <span class="keyword">return</span> batchCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="실험-결과"><a href="#실험-결과" class="headerlink" title="실험 결과"></a>실험 결과</h1><p>어느 방식이 가장 빠를까?</p><p>아래와 같은 환경에서 테스트 해 본 결과 <strong>Spring Data JDBC 방식이 가장 빠르다.</strong></p><h2 id="테스트-환경"><a href="#테스트-환경" class="headerlink" title="테스트 환경"></a>테스트 환경</h2><ul><li>Java 11</li><li>Spring Boot 2.2.4</li><li>MySQL 5.7.18</li><li>Sprint Data JPA 2.2.4</li><li>Hibernate Core 5.4.10.Final</li><li>Hibernate Commons Annotations 5.1.0.Final</li><li>Sprint Data JDBC 1.1.4</li></ul><h2 id="성능-비교"><a href="#성능-비교" class="headerlink" title="성능 비교"></a>성능 비교</h2><p>그렇다면 얼마나 차이가 날까?</p><p>연관 관계 없이 단 하나의 엔티티만 저장하는 시나리오에서, 배치 크기를 바꿔가면서 10,000건의 데이터를 저장하는 실험 결과 소요 시간(초 단위) 및 비교 배율은 다음과 같다.</p><table><thead><tr><th>배치 크기</th><th>JDBC(A)</th><th>Batch SEQUENCE(B)</th><th>IDENTITY(C)</th><th>(B)/(A)</th><th>(C)/(A)</th></tr></thead><tbody><tr><td>10</td><td>0.885</td><td>3.072</td><td>5.087</td><td>3.47</td><td>5.748022599</td></tr><tr><td>50</td><td>0.391</td><td>1.007</td><td>4.097</td><td>2.58</td><td>10.47826087</td></tr><tr><td>100</td><td>0.356</td><td>0.808</td><td>5.218</td><td>2.27</td><td>14.65730337</td></tr><tr><td>500</td><td>0.226</td><td>0.515</td><td>5.637</td><td>2.28</td><td>24.94247788</td></tr><tr><td>1000</td><td>0.216</td><td>0.480</td><td>6.241</td><td>2.22</td><td>28.89351852</td></tr><tr><td>5000</td><td>0.189</td><td>0.447</td><td>5.052</td><td>2.37</td><td>26.73015873</td></tr></tbody></table><p>배치 크기에 따라 다르지만, <strong>Spring Data JDBC의 <code>batchUpdate()</code>를 사용하는 방식이 Hibernate Batch Sequence 방식보다 대략 2 ~ 3배 정도 빠르고, Batch Insert가 사용되지 못 하는 Hibernate IDENTITY 방식보다는 5 ~ 25배 정도 빠르다.</strong> </p><p>MySQL에는 Sequence가 없으므로 SEQUENCE 방식을 지정했다고 하더라도 사실 상 TABLE 방식으로 동작했다는 것을 감안하면, <strong>Sequence가 지원되는 DB에서는 TABLE 방식보다 채번 부하가 더 적은 SEQUENCE 방식을 Batch 스타일로 사용하면 Spring Data JDBC 방식과 비슷한 성능을 보일 것 같다.</strong></p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><blockquote><ul><li><p><strong>아주 많은 수의 데이터를 한 꺼번에 입력할 때는 Spring Data JPA를 잠시 뒤로하고 Spring Data JDBC의 <code>batchUpdate()</code>를 활용하는 것도 좋다.</strong></p><ul><li>Spring Data JDBC는 Spring Data JPA와 함께 혼용해서 사용할 수도 있고,</li><li><code>@Transactional</code>을 통해 트랜잭션이 관리될 수 있으므로,</li><li>현실적으로 가장 나은 방법이다.</li></ul></li><li><p><strong>Spring Data JPA를 사용해야만 한다면 IDENTITY 방식 말고 Batch SEQUENCE 방식을 사용하는 것이 좋다.</strong></p><ul><li>그러나 이 방식은 애너테이션 지정이 필요 이상 복잡하고,</li><li>테이블 생성 시부터 적용하면 괜찮지만, 이미 ID 생성 방식이 IDENTITY인 기존 테이블을 SEQUENCE 방식으로 변경해야 하는 부담이 있고,</li><li>batch 크기 지정 관련 운영 상의 단점이 있다.</li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Data에서-Batch-Insert-최적화&quot;&gt;&lt;a href=&quot;#Spring-Data에서-Batch-Insert-최적화&quot; class=&quot;headerlink&quot; title=&quot;Spring Data에서 Batch Insert 최적화&quot;&gt;
      
    
    </summary>
    
      <category term="Performance" scheme="http://homoefficio.github.io/categories/Performance/"/>
    
    
      <category term="Spring Data JPA" scheme="http://homoefficio.github.io/tags/Spring-Data-JPA/"/>
    
      <category term="Hibernate" scheme="http://homoefficio.github.io/tags/Hibernate/"/>
    
      <category term="Spring Data" scheme="http://homoefficio.github.io/tags/Spring-Data/"/>
    
      <category term="Spring Data JDBC" scheme="http://homoefficio.github.io/tags/Spring-Data-JDBC/"/>
    
      <category term="Batch Insert" scheme="http://homoefficio.github.io/tags/Batch-Insert/"/>
    
      <category term="MySQL" scheme="http://homoefficio.github.io/tags/MySQL/"/>
    
      <category term="GenerationType" scheme="http://homoefficio.github.io/tags/GenerationType/"/>
    
      <category term="GenerationType.IDENTITY" scheme="http://homoefficio.github.io/tags/GenerationType-IDENTITY/"/>
    
      <category term="GenerationType.SEQUENCE" scheme="http://homoefficio.github.io/tags/GenerationType-SEQUENCE/"/>
    
      <category term="GenerationType.TABLE" scheme="http://homoefficio.github.io/tags/GenerationType-TABLE/"/>
    
      <category term="GenerationType.AUTO" scheme="http://homoefficio.github.io/tags/GenerationType-AUTO/"/>
    
      <category term="Performance" scheme="http://homoefficio.github.io/tags/Performance/"/>
    
      <category term="IDENTITY column" scheme="http://homoefficio.github.io/tags/IDENTITY-column/"/>
    
      <category term="Auto Increment" scheme="http://homoefficio.github.io/tags/Auto-Increment/"/>
    
      <category term="Sequence" scheme="http://homoefficio.github.io/tags/Sequence/"/>
    
      <category term="Database" scheme="http://homoefficio.github.io/tags/Database/"/>
    
      <category term="Bulk Insert" scheme="http://homoefficio.github.io/tags/Bulk-Insert/"/>
    
  </entry>
  
  <entry>
    <title>GET이냐 POST냐 그것이 문제로다</title>
    <link href="http://homoefficio.github.io/2019/12/25/GET%EC%9D%B4%EB%83%90-POST%EB%83%90-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AC%B8%EC%A0%9C%EB%A1%9C%EB%8B%A4/"/>
    <id>http://homoefficio.github.io/2019/12/25/GET이냐-POST냐-그것이-문제로다/</id>
    <published>2019-12-25T03:04:39.000Z</published>
    <updated>2019-12-27T14:34:12.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GET이냐-POST냐-그것이-문제로다"><a href="#GET이냐-POST냐-그것이-문제로다" class="headerlink" title="GET이냐 POST냐 그것이 문제로다"></a>GET이냐 POST냐 그것이 문제로다</h1><p>며칠 전에 <a href="https://www.facebook.com/hanmomhanda/posts/10221495156952479" target="_blank" rel="noopener">페이스북에 올렸던 질문</a>에 여러분께서 시간 내서 좋은 의견 나눠주셔서, 나만 꿀꺽하고 넘어가면 도리가 아닌 것 같아 다시 정리해본다.</p><p>먼저 이 글은 <strong>나름의 결론이 있기는 하지만, 그것이 정답이라고 단정할 수는 없다.</strong><br>또한 REST와는 아무런 관계가 없으며, 오직 HTTP Method에 대한 얘기다.</p><h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>보통 클라이언트 쪽에서 Contents를 제공하면서 새로운 Resource의 생성을 요청할 때는, 그 Contents를 포함시켜서 POST로 요청을 보내면 된다. 여기에는 별다른 이견이 없다.</p><p>그런데 클라이언트 쪽에서 아무런 Contents를 제공하지 않으면서, 그저 서버로부터 어떤 Resource를 반환받으려 하는데, 실제로 서버에서는 새 Resource를 생성해서 반환해야 하는 경우라면, GET을 써야 하나 아니면 POST를 써야 하나?</p><p>예를 들어 클라이언트가 아무 내용 없이 그냥 ‘퀴즈를 내다오’라고 서버에게 요청하면,<br>즉, 반환되는 퀴즈가 새로 만든 건지 기존에 만들어져 있던 걸 반환하는지 클라이언트는 관심 가질 필요가 없는 상황이라면,</p><ul><li>GET …/quizzes/new 로 보낸다. (GET이지만 서버는 알아서 새 퀴즈를 생성해서 반환)</li><li>POST (내용없이) …/quizzes 로 보낸다. (POST지만 서버는 새로 생성된 퀴즈를 반환)</li></ul><p>GET, POST 둘 중 어느 쪽이 더 환영받는 방법인가? 또는 어느 쪽이 욕을 덜 먹는 방법인가? 또는 다른 더 나은 방안이 있다면 어떤게 있을까?</p><p>의견을 모아서 정리해봤다. 거의 원문에 가깝고 괄호 안은 임의로 추가.</p><h1 id="POST라는-의견"><a href="#POST라는-의견" class="headerlink" title="POST라는 의견"></a>POST라는 의견</h1><blockquote><p>멱등성이 유지될 수 있으면 GET, 없으면 POST 라는 기본 전제를 두고 생각합니다. 그래서 (새 퀴즈가 생성된다면 멱등이 아니므로) POST로 할 것 같습니다.</p></blockquote><blockquote><p>명시적으로 URI는 자원에 대한 것이어야 하는데 없는 자원을 내놓으라면 404를 반환하는 게 맞을 것 같습니다. (새 자원을 만들어 반환해야 하므로 POST로 할 것 같습니다.)</p></blockquote><blockquote><p>디비 상태에 변화를 주는 건 GET을 쓰지 않고 있어요. GET을 사용할 때는 순수함수처럼 같은 인풋은 같은 아웃풋을 내줘야 한다고 생각합니다.</p></blockquote><blockquote><p>http 1.0이후 생겨난 POST, PUT, DELETE…는 서버 내에 있는 자원에 관련된 조작이기 때문에 전 DB의 변화가 있으면 무조건 상태 변경과 관련된 메서드를 사용합니다.(리소스란 측면에서 DB는 일부…) http 프로토콜에서 method 영역을 클라이언트 입장이냐 서버 입장이냐로 다들 관점이 다르게 바라볼수 있겠지만 http 역사를 생각해보면 메서드는 자원과 관련이 크고 자원을 소유한 서버측 관점에 무게를 싣고 있습니다.</p></blockquote><blockquote><p>POST로 하고 생성된 자원에 대한 GET 경로를 Location 헤더에 넣어서 201로 응답하는 게 맞을 것 같습니다.</p></blockquote><h1 id="GET이라는-의견"><a href="#GET이라는-의견" class="headerlink" title="GET이라는 의견"></a>GET이라는 의견</h1><blockquote><p>클라이언트는 퀴즈를 원할 뿐 새로 생성되든 기존에 있던 거든 신경 쓸필요가 없다고 하니, 조회의 의미만 존재한다고 생각해요.</p></blockquote><blockquote><p>클라이언트는 이게 새로 만들어진건지 기존에 있던건지 모르지만 일단 원하는 행위가 퀴즈라는 것을 얻기 위함이기에 GET 이 맞는거 같습니다.<br>빵집을 예로 들어 빵을 산다라는 행위에서 이게 기존에 만들어진것을 사가든 주문과 동시에 만들어진 빵을 사가든 같은 행위지만(GET)<br>이런 빵을 사가려는데 만들어주세요 혹은 이런빵을 만들어주시면 사러 가겠습니다 (POST)는 다른 목적이고 빵집에서도 이에 따라 다른 행동을 취해야 하니까요</p></blockquote><h1 id="둘-다-아니라는-의견"><a href="#둘-다-아니라는-의견" class="headerlink" title="둘 다 아니라는 의견"></a>둘 다 아니라는 의견</h1><blockquote><p>API는 행위 중심이어야지 상태 중심이면 안 된다는 것이 OOP와 DDD를 통한 배움이었습니다.</p></blockquote><h1 id="중간-정리"><a href="#중간-정리" class="headerlink" title="중간 정리"></a>중간 정리</h1><p>이 말도 맞는 것 같고 저 말도 맞는 것 같고, 멱등성(idempotence)이라는 어려운 용어도 나오고 아 현기증나..</p><p>하지만 정신차리고 추려보면 결국 아래와 같이 요약할 수 있다.</p><blockquote><ul><li>요청자인 클라이언트의 의도를 중요하게 보는 입장에서는 GET을 선호  </li><li>HTTP는 결국 자원을 다루는 것이므로 자원을 중요하게 보는 입장에서는 POST를 선호</li></ul></blockquote><h1 id="스펙은-뭐라더냐"><a href="#스펙은-뭐라더냐" class="headerlink" title="스펙은 뭐라더냐?"></a>스펙은 뭐라더냐?</h1><p>이쯤되면 그다지 보고 싶지 않은 스펙을 보지 않을 수 없다. 관련 스펙은 <a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="noopener">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>이며 그 중에서 HTTP Method 관련 내용은 <a href="https://tools.ietf.org/html/rfc7231#section-4" target="_blank" rel="noopener">여기</a>에 있다.</p><p>POST를 지지하는 의견은 한 마디로 요약하면 다음과 같다.</p><blockquote><p>자원 변경이 수반되면 POST여야 한다.</p></blockquote><p>그런데 정말 스펙에서도 ‘자원 변경이 수반되면 POST여야 한다’고 규정하고 있을까?</p><h2 id="Safe-Methods"><a href="#Safe-Methods" class="headerlink" title="Safe Methods"></a>Safe Methods</h2><p>스펙 내용 중에 <a href="https://tools.ietf.org/html/rfc7231#section-4.2.1" target="_blank" rel="noopener">Safe Methods</a> 라는 단원이 있다.</p><blockquote><p>Request methods are considered “safe” if their defined semantics are<br>essentially read-only; i.e., the client does not request, and does<br>not expect, any state change on the origin server as a result of<br>applying a safe method to a target resource.  Likewise, reasonable<br>use of a safe method is not expected to cause any harm, loss of<br>property, or unusual burden on the origin server.</p></blockquote><p>짧게 옮겨 보면 다음과 같다.</p><blockquote><p>클라이언트가 서버 상태의 변경을 요청하지도, 기대하지도 않는 읽기 전용 요청은 Safe하다고 볼 수 있다. 그래서 Safe Method를 바르게 사용하면 서버에게 어떤 해악이나 손실, 일반적이지 않은 부담을 발생시키지 않는다.</p></blockquote><p>여기까지만 보면 자원 변경이 수반되면 GET을 쓰면 안 될 것 같다.</p><p>그런데 바로 다음 문단에는 살짝 결이 다른 내용이 나온다.</p><blockquote><p>This definition of safe methods does not prevent an implementation<br>from including behavior that is potentially harmful, that is not<br>entirely read-only, or that causes side effects while invoking a safe<br>method.  What is important, however, is that the client did not<br>request that additional behavior and cannot be held accountable for<br>it.  For example, most servers append request information to access<br>log files at the completion of every response, regardless of the<br>method, and that is considered safe even though the log storage might<br>become full and crash the server.  Likewise, a safe request initiated<br>by selecting an advertisement on the Web will often have the side<br>effect of charging an advertising account.</p></blockquote><p>역시나 짧게 옮겨 보면,</p><blockquote><p><strong>Safe Method라고해서 사이드 이펙트나 잠재적으로 해가 될 수 있는 동작을 포함해서 구현하는 것을 배제하지는 않는다. 중요한 것은 그 동작을 클라이언트가 요청한 게 아니라는 점이고, 그 동작에 대한 책임을 클라이언트가 부담하지 않는다는 점이다.</strong> 예를 들어 서버는 (Safe든 아니든) 메서드 종류에 관계 없이 모든 요청에 대해 액세스 로그를 기록하는데, 액세스 로그로 하드가 꽉 차서 서버가 깨질 수도 있지만, (로그 기록은 클라이언트가 요청한 것이 아니므로) 이런 호출도 Safe하다고 본다.(이하 광고 사례 생략)</p></blockquote><p>이 외에도 GET, POST를 직접적으로 설명하는 부분도 있지만, 이 글 내용에 크게 영향을 미치는 내용은 없어 보여서 굳이 다루지 않는다.</p><h1 id="그래서-결론은"><a href="#그래서-결론은" class="headerlink" title="그래서 결론은?"></a>그래서 결론은?</h1><p>앞에서도 말했지만 이 글은 나름의 주관적인 결론은 있지만 그게 정답은 아니다.</p><p>이미 꽤 길어졌으니 결론부터 말하면 <strong>GET을 써도 좋겠다</strong>이다.</p><p>이유는,</p><ul><li>API라는 게 결국 쌍방간의 계약이고,  </li><li>클라이언트는 본질적으로 어떤 자원을 얻기를 바랄 뿐 굳이 자원 생성 여부를 알 필요가 없다면,  </li><li>즉, 클라이언트의 본질적인 요구가 ‘생성’이 아니라 ‘획득’이라면,  </li><li>클라이언트의 요청 처리 내부 과정에 ‘생성’이라는 비멱등 과정이 포함된다고 하더라도,  </li><li>서버의 처리 과정보다는 클라이언트의 ‘획득’이라는 요구 본질에 무게를 두어도,</li><li>스펙에 어긋남이 없기 때문이다.</li></ul><p>게다가 다음 같은 상황을 가정해보면 GET을 써도 좋겠다 정도가 아니라 <strong>GET이 더 낫다</strong>라는 생각도 든다.</p><p>퀴즈를 처음에는 클라이언트 요청에 그때그때 생성해서 반환하기로 하고 이건 자원 생성을 유발하니 POST로 하자.. 로 시작했는데,<br>나중에 퀴즈 서비스가 흥해서 클라이언트가 엄청 많아지고 성능이든 뭐든 여타 이유로 ‘가만 퀴즈를 꼭 생성해서 반환할 필요 없지 않아? 미리 왕창 만들어 놓고 임의로 걍 조회만 해서 반환하는 게 나을 것 같은데?’라는 판단이 든다. 그럼 이제 자원 생성이 발생하지 않으므로 GET을 써야 한다.</p><p>클라이언트의 요구는 ‘퀴즈의 획득’으로 변한 게 없는데, 서버의 처리 과정이 신규 자원 생성에서 기존 자원 조회로 바뀌었다고 해서 API를 POST에서 GET으로 바꿔야되나? 수많은 클라이언트에게 GET으로 바꿔달라고 모두 설득할 수 있나?</p><p>애초에 자원 생성과 무관하게 오로지 ‘획득’이었던 클라이언트의 요청 본질에 충실하게 GET으로 시작했다면 이런 큰 변경을 피할 수 있었을 것이다.</p><p>이렇게 보면 <strong>HTTP Method의 사용에서도 ‘비멱등이면 POST’와 같은 원칙보다는, Information Hiding(정보 감춤/숨김) 같은 더 일반적인 상위 차원의 설계 원칙이 유연한 시스템을 구축하는 데 더 중요</strong>한 것 같다.</p><h1 id="추가"><a href="#추가" class="headerlink" title="추가"></a>추가</h1><p>공유하고 나니 의견을 조금 더 받을 수 있었다.</p><blockquote><p>본 문제에서는 User Interface 와 실제 Http Client 가 분리되어 판단해야 한다고 생각합니다. User Interface 에서는 당연히 사람은 문제를 받는 것만 생각할 것이고 내부 Http Client 는 문제 생성을 중간에 넣어줘도 된다고 생각하는 것입니다.(그래서 내부 Http Client는 POST로 요청해서 문제를 생성하도록 하고 다시 GET으로 요청해서 생성된 문제를 받아오라는 의견)</p></blockquote><blockquote><p>혹시 POST로 생성하게 하면 id를 반환하고 그 id로 데이터를 받아오게 API를 나누면 어떨까요?</p></blockquote><p>둘 다 비슷한 의견인데, <strong>클라이언트가 문제 생성에 관심이 없더라도, 문제가 새로 생성되는 것이 맞다면 (UI수준에서는 인지 못 하게 하더라도 내부적으로) POST로 문제 생성 요청 후, 생성된 문제를 GET으로 가져오자는 의견</strong>으로 보인다.</p><p>위 퀴즈 사례에 국한해서라면 여전히 GET이 더 낫다고 생각한다. 이유는 <strong>위 퀴즈 사례는 처음에는 퀴즈 생성으로 시작하지만 나중에 조회 방식으로 변경될 개연성이 꽤 있고, 자원 보다는 클라이언트의 의도에 무게를 두는 GET이 변경 대응에 더 유연하기 때문</strong>이다.</p><p>다만 위 추가 의견을 옮겨온 이유는, 위 의견 덕분에 앞서 GET이 낫다는 결론이 <strong>이와 비슷해 보이는 상황에서 (언제나) GET을 쓰는 게 낫다라는 잘못된 가이드가 될 수 있는 위험</strong>이 있음을 깨닫게 됐기 떄문이다.</p><p>퀴즈 사례와는 달리 <strong>나중에 조회 방식으로 변경될 개연성이 매우 낮은 상황이라면, 위 의견과 같이 POST + GET 방식을 사용하는 게 합당할 수도 있다.</strong> 다만 이런 결론마저도, 한 번의 HTTP 요청이라도 줄여야 하는 상황이라면 GET을 선택하는 편이 낫게 된다. </p><p>결국 글 서두에서 밝힌 대로 이 글 자체로 정답은 될 수 없다. 그저 참고가 될 뿐이고 <strong>주어진 상황에 맞는 결론을 도출하는 것은 언제나 엔지니어의 몫이다.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GET이냐-POST냐-그것이-문제로다&quot;&gt;&lt;a href=&quot;#GET이냐-POST냐-그것이-문제로다&quot; class=&quot;headerlink&quot; title=&quot;GET이냐 POST냐 그것이 문제로다&quot;&gt;&lt;/a&gt;GET이냐 POST냐 그것이 문제로다&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Concepts" scheme="http://homoefficio.github.io/categories/Concepts/"/>
    
    
      <category term="HTTP" scheme="http://homoefficio.github.io/tags/HTTP/"/>
    
      <category term="HTTP API" scheme="http://homoefficio.github.io/tags/HTTP-API/"/>
    
      <category term="HTTP Method" scheme="http://homoefficio.github.io/tags/HTTP-Method/"/>
    
      <category term="Safe Method" scheme="http://homoefficio.github.io/tags/Safe-Method/"/>
    
      <category term="Idempotence" scheme="http://homoefficio.github.io/tags/Idempotence/"/>
    
      <category term="GET" scheme="http://homoefficio.github.io/tags/GET/"/>
    
      <category term="POST" scheme="http://homoefficio.github.io/tags/POST/"/>
    
      <category term="Information Hiding" scheme="http://homoefficio.github.io/tags/Information-Hiding/"/>
    
      <category term="정보 숨김" scheme="http://homoefficio.github.io/tags/%EC%A0%95%EB%B3%B4-%EC%88%A8%EA%B9%80/"/>
    
      <category term="정보 감춤" scheme="http://homoefficio.github.io/tags/%EC%A0%95%EB%B3%B4-%EA%B0%90%EC%B6%A4/"/>
    
      <category term="멱등" scheme="http://homoefficio.github.io/tags/%EB%A9%B1%EB%93%B1/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Pi 3에 Ubuntu 설치 하기</title>
    <link href="http://homoefficio.github.io/2019/12/21/Raspberry-Pi-3%EC%97%90-Ubuntu-%EC%84%A4%EC%B9%98-%ED%95%98%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2019/12/21/Raspberry-Pi-3에-Ubuntu-설치-하기/</id>
    <published>2019-12-21T08:34:41.000Z</published>
    <updated>2019-12-25T15:30:53.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Install-Ubuntu-on-Raspberry-Pi-3"><a href="#Install-Ubuntu-on-Raspberry-Pi-3" class="headerlink" title="Install Ubuntu on Raspberry Pi 3"></a>Install Ubuntu on Raspberry Pi 3</h1><h2 id="준비물"><a href="#준비물" class="headerlink" title="준비물"></a>준비물</h2><ul><li>Raspberry Pi 3 + 전원 장치</li><li>MicroSD 카드</li><li>USB Keyboard</li><li>Monitor + HDMI 케이블</li><li>Ubuntu 이미지를 다운로드 하고 MicroSD에 Ubuntu 이미지를 Flash 할 인터넷 연결 컴퓨터</li></ul><h2 id="Ubuntu-이미지-파일-다운로드"><a href="#Ubuntu-이미지-파일-다운로드" class="headerlink" title="Ubuntu 이미지 파일 다운로드"></a>Ubuntu 이미지 파일 다운로드</h2><ul><li><a href="https://ubuntu.com/download/raspberry-pi" target="_blank" rel="noopener">https://ubuntu.com/download/raspberry-pi</a><ul><li><code>64-bit for Raspberry Pi 3 and 4</code> 다운로드</li></ul></li></ul><p>약 3G 정도로 다운로드에 시간이 좀 걸리므로 그동안 아래의 ‘Image Flash 프로그램 다운로드 및 설치’, ‘MicroSD 메모리 카드 준비’ 수행</p><h2 id="Image-Flash-프로그램-다운로드-및-설치"><a href="#Image-Flash-프로그램-다운로드-및-설치" class="headerlink" title="Image Flash 프로그램 다운로드 및 설치"></a>Image Flash 프로그램 다운로드 및 설치</h2><ul><li><a href="https://sourceforge.net/projects/win32diskimager/files/latest/download" target="_blank" rel="noopener">https://sourceforge.net/projects/win32diskimager/files/latest/download</a></li></ul><h2 id="MicroSD-메모리-카드-준비"><a href="#MicroSD-메모리-카드-준비" class="headerlink" title="MicroSD 메모리 카드 준비"></a>MicroSD 메모리 카드 준비</h2><p>윈도우 10 기준</p><ul><li><p>MicroSD 메모리 카드를 컴퓨터에 연결</p><ul><li>포맷 등의 팝업이 뜨면 모두 무시</li><li><img src="https://i.imgur.com/93adzTR.png" alt="Imgur"></li><li><img src="https://i.imgur.com/UM67S8u.png" alt="Imgur"></li></ul></li><li><p>기존에 사용하던 카드라 파티션이 나뉘어 있는 경우 파티션 삭제</p><ul><li>윈도우 버튼 우클릭 &gt; 디스크 관리자 실행</li><li><img src="https://i.imgur.com/cGeAsxt.png" alt="Imgur"></li><li>MicroSD 메모리에 있던 볼륨(파티션) 모두 삭제</li><li><img src="https://i.imgur.com/hr9w14r.png" alt="Imgur"></li><li>아래와 같이 모두 삭제 되면 준비 완료</li><li><img src="https://i.imgur.com/rPKVxcJ.png" alt="Imgur"></li></ul></li></ul><h2 id="MicroSD-메모리-카드에-Ubuntu-이미지-파일-Flash"><a href="#MicroSD-메모리-카드에-Ubuntu-이미지-파일-Flash" class="headerlink" title="MicroSD 메모리 카드에 Ubuntu 이미지 파일 Flash"></a>MicroSD 메모리 카드에 Ubuntu 이미지 파일 Flash</h2><ul><li>Ubuntu 이미지 파일 압축 해제<ul><li>필요 시 반디집 설치 후 해제</li></ul></li><li>Image Flash 프로그램 실행<ul><li>Ubuntu 이미지 파일 위치 지정 및 Flash 할 대상 디바이스(MicroSD 카드) 지정 후 Write</li><li><img src="https://i.imgur.com/hFTpk31.png" alt="Imgur"></li><li><img src="https://i.imgur.com/p2inqJO.png" alt="Imgur"></li></ul></li><li>사양에 따라 다르겠지만 약 2~3분 후 다음과 같이 Flash 완료<ul><li><img src="https://i.imgur.com/00yqpDc.png" alt="Imgur"></li></ul></li><li>포맷 팝업창이 다시 뜨면 무시<ul><li><img src="https://i.imgur.com/uV31oML.png" alt="Imgur"></li></ul></li><li>탐색기에서 꺼내기 후 MicroSD 메모리 카드를 빼낸다.</li></ul><h2 id="Raspberry-Pi-부팅-설치-완료-및-로그인"><a href="#Raspberry-Pi-부팅-설치-완료-및-로그인" class="headerlink" title="Raspberry Pi 부팅, 설치 완료 및 로그인"></a>Raspberry Pi 부팅, 설치 완료 및 로그인</h2><ul><li>Ubuntu 이미지가 Flash 된 MicroSD 카드, 모니터와 연결된 HDMI 케이블과 키보드를 Raspberry PI 에 연결하고 마지막으로 Raspberry PI 전원 연결<ul><li><img src="https://i.imgur.com/YwBAux3.jpg" alt="Imgur"></li></ul></li><li>Ubuntu 로 부팅되며 몇 분간 자동 설정 후 로그인 프롬프트 나옴<ul><li><img src="https://i.imgur.com/5P5wgZ6.jpg" alt="Imgur"></li><li><img src="https://i.imgur.com/9G6Zqos.jpg" alt="Imgur"></li><li><img src="https://i.imgur.com/JkXmeLR.jpg" alt="Imgur"></li><li><img src="https://i.imgur.com/LV5d4or.jpg" alt="Imgur"></li><li><strong>놀랍게도 위 사진에 나오는 로그인 프롬프트는 페이크..</strong> 여기서 입력해봤자 비번 틀리다는 얘기만 나오며, 그냥 기다리면 다음 사진과 같이 후속 절차가 자동으로 계속 진행된다.</li><li><img src="https://i.imgur.com/dgSIjFH.jpg" alt="Imgur"></li><li><img src="https://i.imgur.com/dggNhk9.jpg" alt="Imgur"></li></ul></li><li>다음과 같이 <strong><code>[  OK  ] Reached target Cloud-init target.</code> 이 보여야 로그인 준비가 완료</strong>된 것이다. 하지만 <strong>자동으로 로그인 프롬프트가 뜨지는 않고 엔터를 눌러줘야 로그인 프롬프트가 뜬다.</strong><ul><li><img src="https://i.imgur.com/oL5bc8f.jpg" alt="Imgur"></li></ul></li><li>초기 아이디/비번은 ubuntu/ubuntu 이며 로그인 후 위 그림과 같이 비번 변경하면 셸 프롬프트가 뜬다.<ul><li><img src="https://i.imgur.com/njltjMN.jpg" alt="Imgur"></li></ul></li><li>이것으로 부팅, 설치, 로그인 완료</li><li>다음 명령으로 리눅스를 종료한다.<ul><li><code>shutdown -h now</code></li></ul></li></ul><h2 id="설치-완료-후-부팅-및-로그인"><a href="#설치-완료-후-부팅-및-로그인" class="headerlink" title="설치 완료 후 부팅 및 로그인"></a>설치 완료 후 부팅 및 로그인</h2><ul><li>전원을 연결하면 산딸기 그림과 함께 부팅 과정이 진행되고 다음과 같이.. 이번에도 페이크성 로그인 프롬프트가 나온다..</li><li>좀더 기다리면 나머지 후속 작업이 진행되고 <code>Up ##.## seconds</code> 라고 표시되는데 이제서야 비로소 부팅 과정이 완료된 것이다. 하지만 이번에도 진행이 완료된 건지 화면만으로는 알 길이 없다.. </li><li>엔터를 누르면 다음과 같이 진정 유효한 로그인 프롬프트가 나오며, 로그인을 하면 셸 프롬프트가 표시된다.<ul><li><img src="https://i.imgur.com/3iU0f8k.jpg" alt="Imgur"></li></ul></li></ul><h2 id="설치-후기"><a href="#설치-후기" class="headerlink" title="설치 후기"></a>설치 후기</h2><ul><li>사실 그냥 <a href="https://ubuntu.com/download/raspberry-pi" target="_blank" rel="noopener">https://ubuntu.com/download/raspberry-pi</a> 여기에 나온 공식 설명을 재연하고 몇 가지 실제 발생하는 상황(MicroSD 초기화)을 추가한 것 뿐이지만..</li><li>위에 나오는 것처럼 어떤 단계가 언제 끝난 건지 잘 알기 어려운 장면들이 있고,</li><li>페이크성 로그인 프롬프트 처럼 살짝 버그스럽게 보이는 지뢰들이 몇 군데 있음을 감안하면,</li><li>남기길 잘했다..</li></ul><h2 id="고정-IP-적용"><a href="#고정-IP-적용" class="headerlink" title="고정 IP 적용"></a>고정 IP 적용</h2><p>IP 주소는 <code>/etc/netplan/50-cloud-init.yaml</code> 파일에서 설정할 수 있으며 기본은 다음과 같이 설정돼있다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is generated from information provided by</span></span><br><span class="line"><span class="comment"># the datasource.  Changes to it will not persist across an instance.</span></span><br><span class="line"><span class="comment"># To disable cloud-init's network configuration capabilities, write a file</span></span><br><span class="line"><span class="comment"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class="line"><span class="comment"># network: &#123;config: disabled&#125;</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line"><span class="attr">    ethernets:</span></span><br><span class="line"><span class="attr">        eth0:</span>            </span><br><span class="line"><span class="attr">            dhcp4:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">            optional:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    version:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="설정-파일-수정"><a href="#설정-파일-수정" class="headerlink" title="설정 파일 수정"></a>설정 파일 수정</h3><p>고정 IP 주소를 적용하려면 <code>sudo vi</code>로 다음과 같이 편집한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is generated from information provided by</span></span><br><span class="line"><span class="comment"># the datasource.  Changes to it will not persist across an instance.</span></span><br><span class="line"><span class="comment"># To disable cloud-init's network configuration capabilities, write a file</span></span><br><span class="line"><span class="comment"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class="line"><span class="comment"># network: &#123;config: disabled&#125;</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line"><span class="attr">    ethernets:</span></span><br><span class="line"><span class="attr">        eth0:</span></span><br><span class="line"><span class="attr">            addresses:</span> <span class="string">[사용할.고정.IP.주소/24]</span></span><br><span class="line"><span class="attr">            gateway4:</span> <span class="string">사용할.내부.게이트웨이.주소</span></span><br><span class="line"><span class="attr">            nameservers:</span></span><br><span class="line"><span class="attr">                addresses:</span> <span class="string">[168.126.63.1,</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span><span class="string">]</span></span><br><span class="line"><span class="attr">            dhcp4:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">            optional:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">    version:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="설정-내용-적용"><a href="#설정-내용-적용" class="headerlink" title="설정 내용 적용"></a>설정 내용 적용</h3><p>다음 명령으로 설정 내용을 적용한다.</p><blockquote><p>sudo netplan apply</p></blockquote><h3 id="설정-내용-확인"><a href="#설정-내용-확인" class="headerlink" title="설정 내용 확인"></a>설정 내용 확인</h3><p>다음 명령으로 IP 주소를 확인한다.</p><blockquote><p>ip addr</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Install-Ubuntu-on-Raspberry-Pi-3&quot;&gt;&lt;a href=&quot;#Install-Ubuntu-on-Raspberry-Pi-3&quot; class=&quot;headerlink&quot; title=&quot;Install Ubuntu on Raspberry 
      
    
    </summary>
    
      <category term="개발 환경 및 도구" scheme="http://homoefficio.github.io/categories/%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EB%B0%8F-%EB%8F%84%EA%B5%AC/"/>
    
    
      <category term="Raspberry Pi" scheme="http://homoefficio.github.io/tags/Raspberry-Pi/"/>
    
      <category term="Ubuntu" scheme="http://homoefficio.github.io/tags/Ubuntu/"/>
    
      <category term="IoT" scheme="http://homoefficio.github.io/tags/IoT/"/>
    
      <category term="라즈베리 파이" scheme="http://homoefficio.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC-%ED%8C%8C%EC%9D%B4/"/>
    
      <category term="우분투" scheme="http://homoefficio.github.io/tags/%EC%9A%B0%EB%B6%84%ED%88%AC/"/>
    
      <category term="IP" scheme="http://homoefficio.github.io/tags/IP/"/>
    
      <category term="Static IP" scheme="http://homoefficio.github.io/tags/Static-IP/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ에서 H2 연결하고 JPA Console 사용하기</title>
    <link href="http://homoefficio.github.io/2019/10/09/IntelliJ%EC%97%90%EC%84%9C-H2-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B3%A0-JPA-Console-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2019/10/09/IntelliJ에서-H2-연결하고-JPA-Console-사용하기/</id>
    <published>2019-10-09T10:00:09.000Z</published>
    <updated>2019-10-13T15:45:27.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IntelliJ에서-H2-연결하고-JPA-Console-사용하기"><a href="#IntelliJ에서-H2-연결하고-JPA-Console-사용하기" class="headerlink" title="IntelliJ에서 H2 연결하고 JPA Console 사용하기"></a>IntelliJ에서 H2 연결하고 JPA Console 사용하기</h1><p>H2는 Web 콘솔도 지원해줘서 로컬 환경에서 웹을 통해 쉽게 데이터를 확인할 수 있다.<br>IntelliJ <strong>Ultimate 버전</strong>에는 DB Client 도구가 포함돼있어서 로컬에서 H2 DB를 사용할 때 편리하게 사용할 수 있다.<br>또한 JPA를 사용하는 경우 JPA Console을 사용할 수 있고, Hibernate Console처럼 JPA 구현체에 따른 콘솔도 지원한다.</p><p>스프링부트 애플리케이션에 H2를 임베디드 모드로 사용하는 케이스를 기준으로 한 번 시도해보자.</p><p>IntelliJ 2019.2.3, 자바 11, Gradle 5.6.2, 스프링부트 버전 2.2.0 RC1, H2 1.4 기준이고, 기본 <code>build.gradle</code>은 다음과 같다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line">    compileOnly <span class="string">'org.projectlombok:lombok'</span></span><br><span class="line">    developmentOnly <span class="string">'org.springframework.boot:spring-boot-devtools'</span></span><br><span class="line">    runtimeOnly <span class="string">'com.h2database:h2'</span></span><br><span class="line">    annotationProcessor <span class="string">'org.springframework.boot:spring-boot-configuration-processor'</span></span><br><span class="line">    annotationProcessor <span class="string">'org.projectlombok:lombok'</span></span><br><span class="line">    testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;</span><br><span class="line">        exclude <span class="string">group:</span> <span class="string">'org.junit.vintage'</span>, <span class="string">module:</span> <span class="string">'junit-vintage-engine'</span></span><br><span class="line">    &#125;</span><br><span class="line">    testImplementation <span class="string">'org.springframework.security:spring-security-test'</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="H2-웹-콘솔"><a href="#H2-웹-콘솔" class="headerlink" title="H2 웹 콘솔"></a>H2 웹 콘솔</h2><p>H2는 기본적으로 웹 콘솔을 지원하며, 스프링부트에서는 다음의 2가지 방법으로 웹 콘솔을 활성화 할 수 있다. </p><ol><li><code>spring-boot-devtools</code> 적용</li><li>application.properties 에 <code>spring.h2.console.enabled=true</code> 명시</li></ol><p>기본 JDBC URL은 <code>jdbc:h2:mem:testdb</code> 이며, 스프링부트 애플리케이션을 실행하면 <code>localhost:8080/h2-console</code>을 통해 웹 콘솔에 접근할 수 있다.</p><p><img src="https://i.imgur.com/V3jgpSb.png" alt="Imgur"></p><p>H2 웹 콘솔은 다음과 같이 여러 웹 브라우저로부터의 접근은 가능하지만,</p><p><img src="https://i.imgur.com/7iSodqX.png" alt="Imgur"><br>&lt;<a href="https://www.h2database.com/html/tutorial.html#tutorial_starting_h2_console" target="_blank" rel="noopener">https://www.h2database.com/html/tutorial.html#tutorial_starting_h2_console</a> 그림 수정&gt;</p><p>웹 콘솔이므로 당연한 말일 수도 있지만 다음과 같이 웹 브라우저가 아닌 다른 클라이언트로부터의 접근은 불가능하다.</p><p><img src="https://i.imgur.com/ZY7UV9y.png" alt="Imgur"><br>&lt;<a href="https://www.h2database.com/html/tutorial.html#tutorial_starting_h2_console" target="_blank" rel="noopener">https://www.h2database.com/html/tutorial.html#tutorial_starting_h2_console</a> 그림 수정&gt;</p><p>따라서 IntelliJ와 같은 다른 클라이언트로에서 접근하려면 먼저 H2 TCP 서버를 별도로 구동해야 한다.</p><h2 id="H2-TCP-서버-생성"><a href="#H2-TCP-서버-생성" class="headerlink" title="H2 TCP 서버 생성"></a>H2 TCP 서버 생성</h2><h3 id="의존-관계-설정-변경"><a href="#의존-관계-설정-변경" class="headerlink" title="의존 관계 설정 변경"></a>의존 관계 설정 변경</h3><p>H2 TCP 서버를 구동하려면 H2가 제공하는 라이브러리를 소스 코드 수준에서 사용해야하므로 H2를 더 이상 <code>runtimeOnly</code>로만 사용할 수 없다. 따라서 <code>build.gradle</code>에서 H2를 다음과 같이 <code>compile</code>로 변경해줘야 한다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    compile <span class="string">'com.h2database:h2'</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="H2-TCP-서버-구동-빈-추가"><a href="#H2-TCP-서버-구동-빈-추가" class="headerlink" title="H2 TCP 서버 구동 빈 추가"></a>H2 TCP 서버 구동 빈 추가</h3><p>다음과 같이 H2 TCP 서버를 구동하는 빈을 추가한다. 스프링이 아니라면 빈 대신 별도의 Java 애플리케이션으로 작성해도 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.homo_efficio.learnmicroservicesspringboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.h2.tools.Server;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2ServerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">h2TcpServer</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Server.createTcpServer().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>H2 TCP 서버의 기본 포트는 9092이며, 포트 등 기타 옵션은 <code>createTcpServer()</code>의 정의 부분을 보면 상세히 알 수 있다.</p><p>이제 스프링부트 애플리케이션을 실행하면 H2 TCP 서버가 함께 구동되고, 스프링부트 애플리케이션이 종료될 때 H2 TCP 서버도 함께 종료된다.</p><p>보통 H2는 개발용으로 로컬에서 사용하므로 빈 설정 시 다음과 같이 프로파일을 지정해두고 스프링부트 애플리케이션 구동 시 적절한 프로파일을 지정해서 실행하는 것이 좋다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"local"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2ServerConfig</span> </span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>이제 IntelliJ 쪽 설정을 알아보자.</p><h2 id="IntelliJ-데이터-소스-설정"><a href="#IntelliJ-데이터-소스-설정" class="headerlink" title="IntelliJ 데이터 소스 설정"></a>IntelliJ 데이터 소스 설정</h2><p>다음과 같이 데이터베이스 설정 메뉴에서 H2를 선택하고,</p><p><img src="https://i.imgur.com/UnochEY.png" alt="Imgur"></p><p>다음과 같이 H2 JDBC 드라이버를 지정한다.</p><p><img src="https://i.imgur.com/1h22PXY.png" alt="Imgur"></p><p>다음과 같이 왼쪽 상단의 ‘Project Data Sources’에 표시된 항목을 클릭하고 URL, User를 입력한다. URL 입력 시 뭔가 오류를 표시하는 듯한 빨간색 세로 막대가 표시되는데 무시하면 된다.</p><p><img src="https://i.imgur.com/H3ASiJO.png" alt="Imgur"></p><p>Test Connection을 클릭하면 다음과 같이 연결에 성공한다.</p><p><img src="https://i.imgur.com/OjIh2EW.png" alt="Imgur"></p><p>H2 TCP 서버는 인메모리 모드, 파일 모드 둘 다 지원하며 URL 형식은 다음을 참고한다.</p><p><img src="https://i.imgur.com/36vMBtK.png" alt="Imgur"><br>&lt;출처: <a href="https://h2database.com/html/features.html#database_url&gt;" target="_blank" rel="noopener">https://h2database.com/html/features.html#database_url&gt;</a></p><p>참고로 다음과 같이 IntelliJ의 드라이버 지정 화면에서도 Connection type 별로 다음과 같이 URL 템플릿을 친절하게 알려준다.</p><p><img src="https://i.imgur.com/Rf6nGyG.png" alt="Imgur"></p><p>데이터 소스 설정 화면에서 Test Connection에 성공한 후 다음과 같이 ‘Schemas’ 탭을 클릭해서 1초 정도 기다린 후 뜨는 목록에서 ‘PUBLIC’ 스키마를 선택한다.</p><p><img src="https://i.imgur.com/9F1V9ks.png" alt="Imgur"></p><p>OK를 클릭하면 IntelliJ 화면이 다음과 같이 바뀐다.</p><p><img src="https://i.imgur.com/iM8KTCQ.png" alt="Imgur"></p><p>console 창에서는 다음과 같이 자동 완성 도움을 받으면서 쿼리를 작성하고 실행할 수 있다.</p><p><img src="https://i.imgur.com/0tpkaJo.png" alt="Imgur"></p><h2 id="JPA-Console-설정"><a href="#JPA-Console-설정" class="headerlink" title="JPA Console 설정"></a>JPA Console 설정</h2><p>IntelliJ Ultimate 버전에서는 DB Client 뿐만 아니라 JPA Console도 제공하며, 여기서 JPQL 쿼리를 직접 실행할 수 있다.</p><p>다음과 같이 ‘Project Structure’ 화면에서 JPA Console을 사용할 모듈의 ‘main’에서 우클릭하고 JPA를 클릭한다.</p><p><img src="https://i.imgur.com/Qo9F6Da.png" alt="Imgur"></p><p>다음과 같이 ‘Default JPA Provider’에서 실제 사용하는 JPA 구현체를 선택한다.</p><p><img src="https://i.imgur.com/h6LUtjB.png" alt="Imgur"></p><p>다음과 같이 ‘Persistence’ 탭을 클릭하고 ‘entityManagerFactory’를 펼치면 엔티티 클래스가 표시된다.</p><p><img src="https://i.imgur.com/gVcR6zH.png" alt="Imgur"></p><p>다음과 같이 ‘entityManagerFactory’를 우클릭하고 ‘Assign Data Sources…’를 클릭한다.</p><p><img src="https://i.imgur.com/7Rixe39.png" alt="Imgur"></p><p>다음과 같이 ‘Data Source’란을 클릭하면 나오는 목록에서 앞에서 설정한 데이터 소스를 선택하고 OK를 클릭한다.</p><p><img src="https://i.imgur.com/PcIGAh2.png" alt="Imgur"></p><p>다음과 같이 ‘entityManagerFactory’에서 우클릭하고 ‘Console’을 클릭하면,</p><p><img src="https://i.imgur.com/GPCA6zX.png" alt="Imgur"></p><p>다음과 같이 Console 선택 메뉴가 표시된다. JPA Console을 클릭하면,</p><p><img src="https://i.imgur.com/wYRCu07.png" alt="Imgur"></p><p>다음과 같이 JPA Console이 화면에 표시된다.</p><p><img src="https://i.imgur.com/6bpkFbW.png" alt="Imgur"></p><p>바로 JPQL을 입력해서 실행할 수 있다. 현재 스프링부트 애플리케이션이 실행 중이지 않아서 H2 TCP 서버가 기동 중인 상태가 아니므로 다음과 같은 에러가 발생한다.</p><p><img src="https://i.imgur.com/OyeIBe8.png" alt="Imgur"></p><p>스프링부트 애플리케이션을 실행해서 H2 TCP 서버가 기동된 후에 다음과 같이 다시 JPQL을 실행하면 결과가 표시된다.</p><p><img src="https://i.imgur.com/E5GlHhN.png" alt="Imgur"></p><h3 id="JPQL-이름-인식-문제"><a href="#JPQL-이름-인식-문제" class="headerlink" title="JPQL 이름 인식 문제"></a>JPQL 이름 인식 문제</h3><p>그런데 JPA Console에서 JPQL 실행 시 Java의 CamelCase 표기법을 snake_case 표기법으로 자동으로 변환하지 않아서 다음과 같이 엔티티 클래스 이름이나 필드 이름에 CamelCase 표기법이 사용된 경우 ‘not found’ 에러가 난다.</p><p>다음 그림을 보면 CamelCase를 사용하면서도 <code>@Table(name = &quot;MULTIPLICATION_ATTEMPT&quot;)</code>나 <code>@Column(name=&quot;MULTIPLICATION_ATTEMPT_ID&quot;)</code>를 명시해준 건 에러가 나지 않지만, <code>resultAttempt</code>처럼 CamelCase이면서도 <code>@Column</code>으로 이름을 지정해주지 않은 건 에러가 발생한다.</p><p><img src="https://i.imgur.com/Bx022sX.png" alt="Imgur"></p><p><del>따라서 현재로는 JPA Console을 통해 JPQL을 문제 없이 사용하려면 CamelCase를 사용하는 엔티티 클래스 이름이나 필드 이름에는 <code>@Table</code>,<code>@Column</code>을 통해 실제 테이블에 사용될 snake_case 이름을 모두 지정해줘야 하는 불편함이 있다.</del></p><h4 id="추가"><a href="#추가" class="headerlink" title="추가"></a>추가</h4><p>이수홍 님께서 이 문제에 대한 해결 방법을 알려주셨다.</p><p>다음과 같이 ‘Persistence’ &gt; ‘entityManagerFactory’ 우클릭 &gt; ‘Assign Naming Strategies…’를 선택하고,</p><p><img src="https://i.imgur.com/fHAERH2.png" alt="Imgur"></p><p>다음과 같이 ‘SpringPhysicalNamingStrategy’를 Naming Strategy로 설정해주면, JPA Console에서 CamelCase로 된 이름도 별다른 처리 없이 사용할 수 있다.</p><p><img src="https://i.imgur.com/1zuu8ez.png" alt="Imgur"></p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><ul><li>IntelliJ Ultimate 버전에서는 DB Client를 사용할 수 있다.  </li><li>스프링부트 애플리케이션에서는 H2 TCP 서버를 빈으로 띄우면 IntelliJ DB Client로 연결해서 사용할 수 있다.  </li><li>Project Structure에서 main 모듈에 JPA를 추가하고 데이터 소스를 설정해주면 JPA Console을 사용할 수 있다.  </li><li>Naming Strategy를 ‘SpringPhysicalNamingStrategy’로 지정해주면 JPA Console에서 CamelCase로 작성된 이름도 그대로 JPQL에서 사용할 수 있다.</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IntelliJ에서-H2-연결하고-JPA-Console-사용하기&quot;&gt;&lt;a href=&quot;#IntelliJ에서-H2-연결하고-JPA-Console-사용하기&quot; class=&quot;headerlink&quot; title=&quot;IntelliJ에서 H2 연결하고 JPA
      
    
    </summary>
    
      <category term="개발 환경 및 도구" scheme="http://homoefficio.github.io/categories/%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EB%B0%8F-%EB%8F%84%EA%B5%AC/"/>
    
    
      <category term="IntelliJ" scheme="http://homoefficio.github.io/tags/IntelliJ/"/>
    
      <category term="H2" scheme="http://homoefficio.github.io/tags/H2/"/>
    
      <category term="H2 TCP Server" scheme="http://homoefficio.github.io/tags/H2-TCP-Server/"/>
    
      <category term="JPA" scheme="http://homoefficio.github.io/tags/JPA/"/>
    
      <category term="JPA Console" scheme="http://homoefficio.github.io/tags/JPA-Console/"/>
    
      <category term="SpringBoot" scheme="http://homoefficio.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java Optional 바르게 쓰기</title>
    <link href="http://homoefficio.github.io/2019/10/03/Java-Optional-%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%93%B0%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2019/10/03/Java-Optional-바르게-쓰기/</id>
    <published>2019-10-03T14:02:59.000Z</published>
    <updated>2019-10-04T00:17:14.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Optional-바르게-쓰기"><a href="#Java-Optional-바르게-쓰기" class="headerlink" title="Java Optional 바르게 쓰기"></a>Java Optional 바르게 쓰기</h1><p>Brian Goetz는 <a href="https://stackoverflow.com/questions/26327957/should-java-8-getters-return-optional-type/26328555#26328555" target="_blank" rel="noopener">스택오버플로우</a>에서 <code>Optional</code>을 만든 의도에 대해 다음과 같이 말했다.</p><blockquote><p>… it was not to be a general purpose Maybe type, as much as many people would have liked us to do so. Our intention was to provide a limited mechanism for library method return types where there needed to be a clear way to represent “no result” …</p><p><code>Optional</code>은 많은 사람들이 우리(자바 언어 설계자)에게 기대했던 범용적인 <code>Maybe</code> 타입과는 다르다. <strong>라이브러리 메서드가 반환할 결과값이 ‘없음’을 명백하게 표현할 필요가 있는 곳에서 제한적으로 사용할 수 있는 메커니즘을 제공하는 것이 <code>Optional</code>을 만든 의도</strong>였다.</p></blockquote><p>뭔 소린지 아리까리하지만 요는 <strong>반환값이 ‘없음’을 나타내는 것이 주목적</strong>이며, (이유야 있겠지만) <strong>사람들이 기대하는 것과는 다르게 만들었다는..</strong><br>그럼에도 불구하고 사람들은 기대했던 대로 사용해버려서 <a href="https://dzone.com/articles/using-optional-correctly-is-not-optional" target="_blank" rel="noopener">주의사항이 26가지</a>나 되었.. (의도와 다른 방식으로 사용되는 것을 허용한 이유는 또 뭘까..)</p><p>참고로 Java9에는 Brian Goetz가 설명한 의도가 다음과 같이 <code>API Note</code>라는 형식으로 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html" target="_blank" rel="noopener">공식 API 문서</a>에도 포함되었다. (알려주신 김인태님 감사드립니다!)</p><blockquote><p>API Note:<br>Optional is primarily intended for use as a method return type where there is a clear need to represent “no result,” and where using null is likely to cause errors. A variable whose type is Optional should never itself be null; it should always point to an Optional instance.</p><p><strong>메서드가 반환할 결과값이 ‘없음’을 명백하게 표현할 필요가 있고, <code>null</code>을 반환하면 에러를 유발할 가능성이 높은 상황에서 메서드의 반환 타입으로 <code>Optional</code>을 사용하자는 것이 <code>Optional</code>을 만든 주된 목적이다.</strong> <code>Optional</code> 타입의 변수의 값은 절대 <code>null</code>이어서는 안 되며, 항상 <code>Optional</code> 인스턴스를 가리켜야 한다.</p></blockquote><p>어쨌든 원래 의도에 맞게 쓰는 것이 가급적 해가 없을 것이고, 우리는 우리가 만드는 시스템에 해를 끼치지 말아야 한다. 그래서 <strong><code>Optional</code> 사용 시 무심결에 잘못 사용하는 안티패턴과 올바른 사용법을 자바8 기준으로 갈무리</strong>해봤다.</p><h2 id="1-isPresent-get-대신-orElse-orElseGet-orElseThrow"><a href="#1-isPresent-get-대신-orElse-orElseGet-orElseThrow" class="headerlink" title="1. isPresent()-get() 대신 orElse()/orElseGet()/orElseThrow()"></a>1. <code>isPresent()-get()</code> 대신 <code>orElse()/orElseGet()/orElseThrow()</code></h2><blockquote><p><strong>이왕에 비싼 <code>Optional</code> 쓰기로 한 거 코드라도 줄이자. 설명보다 그냥 코드를 보는 게 훨씬 낫다.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line">Optional&lt;Member&gt; member = ...;</span><br><span class="line"><span class="keyword">if</span> (member.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> member.get();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line">Optional&lt;Member&gt; member = ...;</span><br><span class="line"><span class="keyword">return</span> member.orElse(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line">Optional&lt;Member&gt; member = ...;</span><br><span class="line"><span class="keyword">if</span> (member.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> member.get();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line">Optional&lt;Member&gt; member = ...;</span><br><span class="line"><span class="keyword">return</span> member.orElseThrow(() -&gt; <span class="keyword">new</span> NoSuchElementException());</span><br></pre></td></tr></table></figure><h2 id="2-orElse-new-대신-orElseGet-gt-new"><a href="#2-orElse-new-대신-orElseGet-gt-new" class="headerlink" title="2. orElse(new ...) 대신 orElseGet(() -&gt; new ...)"></a>2. <code>orElse(new ...)</code> 대신 <code>orElseGet(() -&gt; new ...)</code></h2><blockquote><p><strong><code>orElse(...)</code>에서 <code>...</code>는 <code>Optional</code>에 값이 있든 없든 무조건 실행된다. 따라서 <code>...</code>가 새로운 객체를 생성하거나 새로운 연산을 수행하는 경우에는 <code>orElse()</code> 대신 <code>orElseGet()</code>을 써야한다.</strong></p></blockquote><p>이거 사실 생각해보면 굉장히 당연한 내용이다. <code>method1(method2())</code>이 실행되면 <code>method2()</code>는 <code>method1()</code>보다 먼저 그리고 언제나 실행된다. 따라서 <code>orElse(new ...)</code>에서도 <code>new ...</code>가 무조건 실행되는 것이 당연하다.  </p><p>그런데 아마도 이름 때문이겠지만 묘하게도 무심결에 생각없이 <code>orElse(new ...)</code>를 써보면 <code>new ...</code>는 <code>Optional</code>에 값이 없을 때만 실행될 것 같은 착각이 든다.</p><p>암튼 <code>Optional</code>에 값이 없으면 <code>orElse()</code>의 인자로서 실행된 값이 반환되므로 실행한 의미가 있지만, <strong><code>Optional</code>에 값이 있으면 <code>orElse()</code>의 인자로서 실행된 값이 무시되고 버려진다.</strong> 따라서 <strong><code>orElse(...)</code>는 <code>...</code>가 새 객체 생성이나 새로운 연산을 유발하지 않고 이미 생성되었거나 이미 계산된 값일 때만 사용해야 한다.</strong></p><p><strong><code>orElseGet(Supplier)</code>에서 <code>Supplier</code>는 <code>Optional</code>에 값이 없을 때만 실행된다. 따라서 <code>Optional</code>에 값이 없을 때만 새 객체를 생성하거나 새 연산을 수행하므로 불필요한 오버헤드가 없다.</strong> 물론 람다식이나 메서드참조에 대한 오버헤드는 있겠지만 불필요한 객체 생성이나 연산을 수행하는 것에 비하면 대부분 경미할 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line">Optional&lt;Member&gt; member = ...;</span><br><span class="line"><span class="keyword">return</span> member.orElse(<span class="keyword">new</span> Member());  <span class="comment">// member에 값이 있든 없든 new Member()는 무조건 실행됨</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line">Optional&lt;Member&gt; member = ...;</span><br><span class="line"><span class="keyword">return</span> member.orElseGet(Member::<span class="keyword">new</span>);  <span class="comment">// member에 값이 없을 때만 new Member()가 실행됨</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line">Member EMPTY_MEMBER = <span class="keyword">new</span> Member();</span><br><span class="line">...</span><br><span class="line">Optional&lt;Member&gt; member = ...;</span><br><span class="line"><span class="keyword">return</span> member.orElse(EMPTY_MEMBER);  <span class="comment">// 이미 생성됐거나 계산된 값은 orElse()를 사용해도 무방</span></span><br></pre></td></tr></table></figure><p>참고로 <code>Collections.emptyList()</code>는 호출될 때마다 비어있는 리스트를 반환하는 것이 아니라 이미 생성된 static 변수인 <code>EMPTY_LIST</code>를 반환하므로 <code>orElse(Collections.emptyList())</code>를 써도 괜찮다. 하지만, 이런 용법은 많이 사용되면 <code>orElse(new ...)</code>나 <code>orElse(연산을유발하는메서드())</code> 같은 안티 패턴마저 정상적인 사용법으로 인식되게 하는 좋지 않은 착시 효과가 발생할 수 있으므로 <strong><code>orElseGet(Collections::emptyList)</code>를 사용하는 것이 더 좋다.</strong></p><h2 id="3-단지-값을-얻을-목적이라면-Optional-대신-null-비교"><a href="#3-단지-값을-얻을-목적이라면-Optional-대신-null-비교" class="headerlink" title="3. 단지 값을 얻을 목적이라면 Optional 대신 null 비교"></a>3. 단지 값을 얻을 목적이라면 <code>Optional</code> 대신 <code>null</code> 비교</h2><blockquote><p><strong><code>Optional</code>은 비싸다. 따라서 단순히 값 또는 <code>null</code>을 얻을 목적이라면 <code>Optional</code> 대신 <code>null</code> 비교를 쓰자.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line"><span class="keyword">return</span> Optional.ofNullable(status).orElse(READY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line"><span class="keyword">return</span> status != <span class="keyword">null</span> ? status : READY;</span><br></pre></td></tr></table></figure><h2 id="4-Optional-대신-비어있는-컬렉션-반환"><a href="#4-Optional-대신-비어있는-컬렉션-반환" class="headerlink" title="4. Optional 대신 비어있는 컬렉션 반환"></a>4. <code>Optional</code> 대신 비어있는 컬렉션 반환</h2><blockquote><p><strong><code>Optional</code>은 비싸다. 그리고 컬렉션은 <code>null</code>이 아니라 비어있는 컬렉션을 반환하는 것이 좋을 때가 많다. 따라서 컬렉션은 <code>Optional</code>로 감싸서 반환하지 말고 비어있는 컬렉션을 반환하자.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line">List&lt;Member&gt; members = team.getMembers();</span><br><span class="line"><span class="keyword">return</span> Optional.ofNullable(members);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line">List&lt;Member&gt; members = team.getMembers();</span><br><span class="line"><span class="keyword">return</span> members != <span class="keyword">null</span> ? members : Collections.emptyList();</span><br></pre></td></tr></table></figure><p>마찬가지 이유로 Spring Data JPA Repository 메서드 선언 시 다음과 같이 컬렉션을 <code>Optional</code>로 감싸서 반환하는 것은 좋지 않다. <strong>컬렉션을 반환하는 Spring Data JPA Repository 메서드는 <code>null</code>을 반환하지 않고 비어있는 컬렉션을 반환해주므로 <code>Optional</code>로 감싸서 반환할 필요가 없다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; <span class="keyword">extends</span> <span class="title">JpaRepository</span> </span>&#123;</span><br><span class="line">    Optional&lt;List&lt;Member&gt;&gt; findAllByNameContaining(String part);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; <span class="keyword">extends</span> <span class="title">JpaRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Member&gt; <span class="title">findAllByNameContaining</span><span class="params">(String part)</span></span>;  <span class="comment">// null이 반환되지 않으므로 Optional 불필요</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Optional을-필드로-사용-금지"><a href="#5-Optional을-필드로-사용-금지" class="headerlink" title="5. Optional을 필드로 사용 금지"></a>5. <code>Optional</code>을 필드로 사용 금지</h2><blockquote><p><strong><code>Optional</code>은 필드에 사용할 목적으로 만들어지지 않았으며, <code>Serializable</code>을 구현하지 않았다. 따라서 <code>Optional</code>은 필드로 사용하지 말자.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;String&gt; email = Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Optional을-생성자나-메서드-인자로-사용-금지"><a href="#6-Optional을-생성자나-메서드-인자로-사용-금지" class="headerlink" title="6. Optional을 생성자나 메서드 인자로 사용 금지"></a>6. <code>Optional</code>을 생성자나 메서드 인자로 사용 금지</h2><blockquote><p><strong><code>Optional</code>을 생성자나 메서드 인자로 사용하면, 호출할 때마다 <code>Optional</code>을 생성해서 인자로 전달해줘야 한다. 하지만 호출되는 쪽, 즉 api나 라이브러리 메서드에서는 인자가 <code>Optional</code>이든 아니든 <code>null</code> 체크를 하는 것이 언제나 안전하다. 따라서 굳이 비싼 <code>Optional</code>을 인자로 사용하지 말고 호출되는 쪽에 <code>null</code> 체크 책임을 남겨두는 것이 좋다.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HRManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseSalary</span><span class="params">(Optional&lt;Member&gt; member)</span> </span>&#123;</span><br><span class="line">        member.ifPresent(member -&gt; member.increaseSalary(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">hrManager.increaseSalary(Optional.ofNullable(member));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HRManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseSalary</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (member != <span class="keyword">null</span>) &#123;</span><br><span class="line">            member.increaseSalary(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">hrManager.increaseSalary(member);</span><br></pre></td></tr></table></figure><h2 id="7-Optional을-컬렉션의-원소로-사용-금지"><a href="#7-Optional을-컬렉션의-원소로-사용-금지" class="headerlink" title="7. Optional을 컬렉션의 원소로 사용 금지"></a>7. <code>Optional</code>을 컬렉션의 원소로 사용 금지</h2><blockquote><p><strong>컬렉션에는 많은 원소가 들어갈 수 있다. 따라서 비싼 <code>Optional</code>을 원소로 사용하지 말고 원소를 꺼낼 때나 사용할 때 <code>null</code> 체크하는 것이 좋다. 특히 Map은 <code>getOrDefault()</code>, <code>putIfAbsent()</code>, <code>computeIfAbsent()</code>, <code>computeIfPresent()</code> 처럼 <code>null</code> 체크가 포함된 메서드를 제공하므로, Map의 원소로 <code>Optional</code>을 사용하지 말고 Map이 제공하는 메서드를 활용하는 것이 좋다.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line">Map&lt;String, Optional&lt;String&gt;&gt; sports = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">sports.put(<span class="string">"100"</span>, Optional.of(<span class="string">"BasketBall"</span>));</span><br><span class="line">sports.put(<span class="string">"101"</span>, Optional.ofNullable(someOtherSports));</span><br><span class="line">String basketBall = sports.get(<span class="string">"100"</span>).orElse(<span class="string">"BasketBall"</span>);</span><br><span class="line">String unknown = sports.get(<span class="string">"101"</span>).orElse(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line">Map&lt;String, String&gt; sports = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">sports.put(<span class="string">"100"</span>, <span class="string">"BasketBall"</span>);</span><br><span class="line">sports.put(<span class="string">"101"</span>, <span class="keyword">null</span>);</span><br><span class="line">String basketBall = sports.getOrDefault(<span class="string">"100"</span>, <span class="string">"BasketBall"</span>);</span><br><span class="line">String unknown = sports.computeIfAbsent(<span class="string">"101"</span>, k -&gt; <span class="string">""</span>);</span><br></pre></td></tr></table></figure><h2 id="8-of-ofNullable-혼동-주의"><a href="#8-of-ofNullable-혼동-주의" class="headerlink" title="8. of(), ofNullable() 혼동 주의"></a>8. <code>of()</code>, <code>ofNullable()</code> 혼동 주의</h2><blockquote><p><strong><code>of(X)</code>은 <code>X</code>가 <code>null</code>이 아님이 확실할 때만 사용해야 하며, <code>X</code>가 <code>null</code>이면 NullPointerException 이 발생한다.</strong><br><strong><code>ofNullable(X)</code>은 <code>X</code>가 <code>null</code>일 수도 있을 때만 사용해야 하며, <code>X</code>가 <code>null</code>이 아님이 확실하면 <code>of(X)</code>를 사용해야 한다.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line"><span class="keyword">return</span> Optional.of(member.getEmail());  <span class="comment">// member의 email이 null이면 NPE 발생</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line"><span class="keyword">return</span> Optional.ofNullable(member.getEmail());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line"><span class="keyword">return</span> Optional.ofNullable(<span class="string">"READY"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line"><span class="keyword">return</span> Optional.of(<span class="string">"READY"</span>);</span><br></pre></td></tr></table></figure><h2 id="9-Optional-lt-T-gt-대신-OptionalInt-OptionalLong-OptionalDouble"><a href="#9-Optional-lt-T-gt-대신-OptionalInt-OptionalLong-OptionalDouble" class="headerlink" title="9. Optional&lt;T&gt; 대신 OptionalInt, OptionalLong, OptionalDouble"></a>9. <code>Optional&lt;T&gt;</code> 대신 <code>OptionalInt</code>, <code>OptionalLong</code>, <code>OptionalDouble</code></h2><blockquote><p><strong><code>Optional</code>에 담길 값이 <code>int</code>, <code>long</code>, <code>double</code>이라면 Boxing/Unboxing이 발생하는 <code>Optional&lt;Integer&gt;</code>, <code>Optional&lt;Long&gt;</code>, <code>Optional&lt;Double&gt;</code>을 사용하지 말고, <code>OptionalInt</code>, <code>OptionalLong</code>, <code>OptionalDouble</code>을 사용하자.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안 좋음</span></span><br><span class="line">Optional&lt;Integer&gt; count = Optional.of(<span class="number">38</span>);  <span class="comment">// boxing 발생</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count.get() ; i++) &#123; ... &#125;  <span class="comment">// unboxing 발생</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 좋음</span></span><br><span class="line">OptionalInt count = OptionalInt.of(<span class="number">38</span>);  <span class="comment">// boxing 발생 안 함</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count.getAsInt() ; i++) &#123; ... &#125;  <span class="comment">// unboxing 발생 안 함</span></span><br></pre></td></tr></table></figure><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><ol><li><p><code>isPresent()-get()</code> 대신 <code>orElse()/orElseGet()/orElseThrow()</code></p></li><li><p><code>orElse(new ...)</code> 대신 <code>orElseGet(() -&gt; new ...)</code></p></li><li><p>단지 값을 얻을 목적이라면 <code>Optional</code> 대신 <code>null</code> 비교</p></li><li><p><code>Optional</code> 대신 비어있는 컬렉션 반환</p></li><li><p><code>Optional</code>을 필드로 사용 금지</p></li><li><p><code>Optional</code>을 생성자나 메서드 인자로 사용 금지</p></li><li><p><code>Optional</code>을 컬렉션의 원소로 사용 금지</p></li><li><p><code>of()</code>, <code>ofNullable()</code> 혼동 주의</p></li><li><p><code>Optional&lt;T&gt;</code> 대신 <code>OptionalInt</code>, <code>OptionalLong</code>, <code>OptionalDouble</code></p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-Optional-바르게-쓰기&quot;&gt;&lt;a href=&quot;#Java-Optional-바르게-쓰기&quot; class=&quot;headerlink&quot; title=&quot;Java Optional 바르게 쓰기&quot;&gt;&lt;/a&gt;Java Optional 바르게 쓰기&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="Java8" scheme="http://homoefficio.github.io/tags/Java8/"/>
    
      <category term="Optional" scheme="http://homoefficio.github.io/tags/Optional/"/>
    
      <category term="isPresent" scheme="http://homoefficio.github.io/tags/isPresent/"/>
    
      <category term="ifPresent" scheme="http://homoefficio.github.io/tags/ifPresent/"/>
    
      <category term="orElse" scheme="http://homoefficio.github.io/tags/orElse/"/>
    
      <category term="orElseGet" scheme="http://homoefficio.github.io/tags/orElseGet/"/>
    
      <category term="orElseThrow" scheme="http://homoefficio.github.io/tags/orElseThrow/"/>
    
      <category term="OptionalInt" scheme="http://homoefficio.github.io/tags/OptionalInt/"/>
    
      <category term="OptionalLong" scheme="http://homoefficio.github.io/tags/OptionalLong/"/>
    
      <category term="OptionalDouble" scheme="http://homoefficio.github.io/tags/OptionalDouble/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 스케줄러 적용 아키텍처 개선 - 3</title>
    <link href="http://homoefficio.github.io/2019/09/29/Quartz-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC-%EC%A0%81%EC%9A%A9-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B0%9C%EC%84%A0-3/"/>
    <id>http://homoefficio.github.io/2019/09/29/Quartz-스케줄러-적용-아키텍처-개선-3/</id>
    <published>2019-09-29T13:59:33.000Z</published>
    <updated>2019-09-29T14:49:23.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartz-스케줄러-적용-아키텍처-개선-3"><a href="#Quartz-스케줄러-적용-아키텍처-개선-3" class="headerlink" title="Quartz 스케줄러 적용 아키텍처 개선 - 3"></a>Quartz 스케줄러 적용 아키텍처 개선 - 3</h1><p><a href="https://homoefficio.github.io/2019/09/28/Quartz-스케줄러-적용-아키텍처-개선-1/">1편</a>에서는 Quartz 스케줄러 적용 시 변경 주기가 다른 스케줄러 모듈과 작업 클래스 모듈을 분리해서 클린 아키텍처에 다가가는 방법을 알아봤다.</p><p><a href="https://homoefficio.github.io/2019/09/29/Quartz-스케줄러-적용-아키텍처-개선-2/">2편</a>에서는 Quartz 작업 클래스 모듈에 의존 관계를 주입하는 방법을 알아봤다.</p><p>이렇게 두 개의 고개를 성공적으로 넘었고 마지막으로 <code>@Tranactional</code> 고개가 남았다.</p><p>먼저 일반적인 상황, 즉 스프링부트 애플리케이션인 스케줄러 모듈에서 <code>@Transactional</code>을 사용하는 간단한 코드를 추가해서 <code>@Transactional</code>의 동작을 확인하고, 작업 클래스 모듈에서 <code>@Tranactional</code>을 사용해보자.</p><h1 id="스케줄러-모듈에서의-Transactional-동작-확인"><a href="#스케줄러-모듈에서의-Transactional-동작-확인" class="headerlink" title="스케줄러 모듈에서의 @Transactional 동작 확인"></a>스케줄러 모듈에서의 <code>@Transactional</code> 동작 확인</h1><p><code>@Transactional</code> 동작을 확인하기 위해 스케줄러 모듈에 <code>Member</code> 엔티티와 JPA 리포지토리를 추가한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Member</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Member</span><span class="params">(String name, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HelloService</code>에 <code>@Transactional</code>을 사용하는 메서드를 추가한다. 저장 후 일부러 예외를 발생시켜서 롤백되게 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemberRepository memberRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"OOO &#123;&#125;.sayHello() executed"</span>, <span class="keyword">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Member <span class="title">saveMember</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">        Member dbMember = memberRepository.save(member);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"테스트를 위해 강제로 발생시킨 예외"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dbMember;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InitRunner</code>에 다음과 같이 <code>HelloService.saveMember()</code>를 호출하고 예외를 잡아 처리하는 코드를 추가한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RemoteJobClassLoader remoteJobClassLoader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Init Runner executed."</span>);</span><br><span class="line">        JobKey jobKey = JobKey.jobKey(<span class="string">"jobkey1"</span>, <span class="string">"jobgroup1"</span>);</span><br><span class="line">        JobDetail jobDetail = buildJobDetail(jobKey);</span><br><span class="line">        Trigger trigger = buildJobTrigger(jobKey);</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 여기!!</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Member dbMember = helloService.saveMember(</span><br><span class="line">                <span class="keyword">new</span> Member(<span class="string">"Homo Efficio"</span>, <span class="string">"homo.efficio@gmail.com"</span>));</span><br><span class="line">            log.info(<span class="string">"TTT 회원 [&#123;&#125;] 추가됨"</span>, dbMember);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"TTT 회원 추가 중 예외 발생. 메시지: &#123;&#125;"</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 이하 생략..</span></span><br></pre></td></tr></table></figure><p>실행하고 h2 web console로 확인해보면 롤백되어 레코드가 추가되지 않았음을 확인할 수 있다.</p><p><img src="https://i.imgur.com/ulrRfis.png" alt="Imgur"></p><p><code>HelloService.saveMember()</code>에서 <code>@Transactional</code>을 제거하면 롤백이 실행되지 않으므로 예외가 발생하더라도 레코드가 추가된 채로 남는다.</p><p><img src="https://i.imgur.com/J2aMQsK.png" alt="Imgur"></p><p>이제 작업 클래스 모듈에서도 <code>@Transactional</code>이 적용되는지 알아보자.</p><h1 id="작업-클래스-모듈에서의-Transactional-동작-확인"><a href="#작업-클래스-모듈에서의-Transactional-동작-확인" class="headerlink" title="작업 클래스 모듈에서의 @Transactional 동작 확인"></a>작업 클래스 모듈에서의 <code>@Transactional</code> 동작 확인</h1><p>간단한 확인을 위해 <code>RemoteSimpleJob</code> 클래스에서 직접 <code>MemberRepository</code>를 통해 <code>Member</code>를 저장하는 코드를 작성해보자.</p><p>먼저 JPA 리포지토리를 사용할 수 있도록 <code>build.gradle</code>에 다음과 같이 spring-data-jpa-starter를 추가해준다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile project(<span class="string">':quartz-scheduler'</span>)</span><br><span class="line"></span><br><span class="line">    compileOnly <span class="string">'org.projectlombok:lombok:1.18.8'</span></span><br><span class="line">    annotationProcessor <span class="string">'org.projectlombok:lombok:1.18.8'</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.quartz-scheduler'</span>, <span class="string">name:</span> <span class="string">'quartz'</span>, <span class="string">version:</span> <span class="string">'2.3.1'</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.springframework'</span>, <span class="string">name:</span> <span class="string">'spring-context-support'</span>, <span class="string">version:</span> <span class="string">'5.1.9.RELEASE'</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.springframework.data'</span>, <span class="string">name:</span> <span class="string">'spring-data-jpa'</span>, <span class="string">version:</span> <span class="string">'2.1.10.RELEASE'</span>  <span class="comment">// 여기!!</span></span><br><span class="line"></span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RemoteSimpleJob에서-MemberRepository를-통한-Member-저장"><a href="#RemoteSimpleJob에서-MemberRepository를-통한-Member-저장" class="headerlink" title="RemoteSimpleJob에서 MemberRepository를 통한 Member 저장"></a>RemoteSimpleJob에서 MemberRepository를 통한 Member 저장</h2><p><code>RemoteSimpleJob</code>에 <code>MemberRepository</code>를 주입하고 <code>Member</code>를 저장하는 코드를 추가한다. 아직 <code>@Transactional</code>은 추가하지 않은 상태다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteSimpleJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HelloService helloService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemberRepository memberRepository;  <span class="comment">// 여기!!</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"OOO REMOTE JOB [&#123;&#125;] executed."</span>, <span class="keyword">this</span>.getClass().getSimpleName());</span><br><span class="line">        JobDataMap mergedJobDataMap = context.getMergedJobDataMap();</span><br><span class="line">        mergedJobDataMap.forEach((k, v) -&gt; log.info(<span class="string">"OOOOO &#123;&#125;: &#123;&#125;"</span>, k, v));</span><br><span class="line"></span><br><span class="line">        helloService.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 여기!!</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Member dbMember = memberRepository.save(<span class="keyword">new</span> Member(<span class="string">"Homo Efficio"</span>, <span class="string">"homo.efficio@gmail.com"</span>));</span><br><span class="line">            log.info(<span class="string">"TTT 회원 [&#123;&#125;] 추가됨"</span>, dbMember);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"테스트를 위해 강제로 발생시킨 예외"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"TTT 회원 추가 중 예외 발생. 메시지: &#123;&#125;"</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스케줄러 모듈의 <code>InitRunner</code>에서 <code>HelloService.saveMember()</code> 부분을 다음과 같이 주석처리 한다. 이유는 <code>Member</code> 저장을 <code>RemoteSimpleJob</code> 내에서 처리하기 때문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Init Runner executed."</span>);</span><br><span class="line">        JobKey jobKey = JobKey.jobKey(<span class="string">"jobkey1"</span>, <span class="string">"jobgroup1"</span>);</span><br><span class="line">        JobDetail jobDetail = buildJobDetail(jobKey);</span><br><span class="line">        Trigger trigger = buildJobTrigger(jobKey);</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Member member = new Member("Homo Efficio", "homo.efficio@gmail.com");</span></span><br><span class="line">        <span class="comment">// try &#123;</span></span><br><span class="line">        <span class="comment">//     Member dbMember = helloService.saveMember(member);</span></span><br><span class="line">        <span class="comment">//     log.info("TTT 회원 [&#123;&#125;] 추가됨", dbMember);</span></span><br><span class="line">        <span class="comment">// &#125; catch (Exception e) &#123;</span></span><br><span class="line">        <span class="comment">//     log.error("TTT 회원 추가 중 예외 발생. 메시지: &#123;&#125;",e.getMessage());</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>실행해보면 롤백이 적용되지 않으므로 다음과 같이 저장 후 예외가 발생하더라도 레코드가 추가되는 것을 확인할 수 있다.</p><p><img src="https://i.imgur.com/KOmhtvz.png" alt="Imgur"></p><p><img src="https://i.imgur.com/7cVLJTD.png" alt="Imgur"></p><h2 id="RemoteSimpleJob에서-Transactional-사용"><a href="#RemoteSimpleJob에서-Transactional-사용" class="headerlink" title="RemoteSimpleJob에서 @Transactional 사용"></a>RemoteSimpleJob에서 @Transactional 사용</h2><p>이제 다음과 같이 작업 클래스의 <code>execute()</code> 메서드에 <code>@Transactional</code>을 붙여서 실행해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>  <span class="comment">// 여기!!</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">    log.info(<span class="string">"OOO REMOTE JOB [&#123;&#125;] executed."</span>, <span class="keyword">this</span>.getClass().getSimpleName());</span><br><span class="line">    JobDataMap mergedJobDataMap = context.getMergedJobDataMap();</span><br><span class="line">    mergedJobDataMap.forEach((k, v) -&gt; log.info(<span class="string">"OOOOO &#123;&#125;: &#123;&#125;"</span>, k, v));</span><br><span class="line"></span><br><span class="line">    helloService.sayHello();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Member dbMember = memberRepository.save(<span class="keyword">new</span> Member(<span class="string">"Homo Efficio"</span>, <span class="string">"homo.efficio@gmail.com"</span>));</span><br><span class="line">        log.info(<span class="string">"TTT 회원 [&#123;&#125;] 추가됨"</span>, dbMember);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"테스트를 위해 강제로 발생시킨 예외"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"TTT 회원 추가 중 예외 발생. 메시지: &#123;&#125;"</span>,e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번에는 안타깝게도 다음과 같은 에러를 만나게 된다. 지면을 많이 차지하니 <a href="https://gist.github.com/HomoEfficio/b2c9e030b785827b5eba75a1e719387d" target="_blank" rel="noopener">지스트(Gist) 링크</a>로 대신하고, 주요 부분만 살펴보면 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.SchedulerException: Job instantiation failed</span><br><span class="line"></span><br><span class="line">Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;io.homo_efficio.quartz.job.RemoteSimpleJob&apos;: Initialization of bean failed; nested exception is org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class io.homo_efficio.quartz.job.RemoteSimpleJob: Common causes of this problem include using a final class or a non-visible class; nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.NoClassDefFoundError--&gt;io/homo_efficio/quartz/job/RemoteSimpleJob</span><br><span class="line"></span><br><span class="line">Caused by: org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class io.homo_efficio.quartz.job.RemoteSimpleJob: Common causes of this problem include using a final class or a non-visible class; nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.NoClassDefFoundError--&gt;io/homo_efficio/quartz/job/RemoteSimpleJob</span><br><span class="line"></span><br><span class="line">Caused by: org.springframework.cglib.core.CodeGenerationException: java.lang.NoClassDefFoundError--&gt;io/homo_efficio/quartz/job/RemoteSimpleJob</span><br><span class="line"></span><br><span class="line">Caused by: java.lang.NoClassDefFoundError: io/homo_efficio/quartz/job/RemoteSimpleJob</span><br><span class="line"></span><br><span class="line">Caused by: java.lang.ClassNotFoundException: io.homo_efficio.quartz.job.RemoteSimpleJob</span><br></pre></td></tr></table></figure><p>긴 내용이지만 요약하면 <code>@Transactional</code> 기능을 추가하기 위해서 <code>RemoteSimpleJob</code>의 프록시 객체를 CGLib 라이브러리를 이용해서 생성해야 하는데, 이때 <code>RemoteSimpleJob</code> 클래스를 찾을 수 없다는 얘기다.</p><p><code>@Transactional</code>이 없을 때는 프록시 객체를 만들 필요가 없으므로 <code>RemoteSimpleJob</code>은 우리가 만든 커스텀 클래스로더를 통해 정상적으로 로딩되어 실행된다. 하지만 <strong><code>@Transactional</code>이 붙어서 CGLib을 통해 프록시 객체를 생성할 때는 우리가 만든 커스텀 클래스로더가 사용되지 못하므로 <code>RemoteSimpleJob</code>을 찾지 못하고 위와 같은 에러가 발생하게 된다.</strong> 그림으로 보면 대략 다음과 같다.</p><p><img src="https://i.imgur.com/e7GF1s6.png" alt="Imgur"></p><p>그럼 CGLib이 사용하는 클래스로더가 <code>RemoteSimpleJob</code>을 로딩할 수 있게 만들면 이 문제도 해결될 것 같다. CGLib는 애플리케이션 구동 환경에서 정해진 클래스로더를 사용하는데 대략 다음과 같다.</p><ul><li>Standalone Tomcat 환경이면 <code>WebAppClassLoader</code></li><li>스프링부트에 내장된 Embedded Tomcat 환경이면 <code>LaunchedURLClassLoader</code></li><li>스프링 devtools를 사용하는 로컬 환경이면 <code>RestartClassLoader</code></li></ul><p>Standalone Tomcat 환경이라면 <code>context.xml</code> 파일에 <code>&lt;Loader&gt;</code> 엘리먼트를 통해 커스텀 클래스로더를 지정할 수 있고, 스프링부트 환경이라면 <code>PropertiesLauncher</code> 클래스와 <code>loader.path</code> 속성으로 클래스로더를 지정할 수 있고, 가장 범용적으로는 manifest 파일에 <code>Class-Path</code>로 로딩할 클래스가 포함된 클래스패스를 지정해주면 된다.</p><p>이론적으로는 그런데 실제로는 애플리케이션 구동 환경 자체도 로컬 개발 환경, 서버 환경 모두 다르고, 그에 따라 스프링 내부에서 구동되는 CGLib이 <code>RemoteSimpleJob</code>을 로딩할 수 있게 하려면 스프링 내부에 대한 심도있는 지식이 필요하다. 그걸로 끝나는 게 아니라 <code>RemoteSimpleJob</code>이 참조하는 다른 클래스, 그 클래스가 참조하는 다른 클래스, 그 클래스가 참조하는 다른 클래스… 를 모두 로딩할 수 있어야 한다.</p><p>이것저것 시도해보다가 CGLib이 <code>RemoteSimpleJob</code>에 대한 프록시 객체를 생성하게 만드는 데 간신히 성공했다. TRACE 로그로 확인할 수 있었다. (이건 예전에 했던 내용이라 클래스 이름 등은 현재 예제와 좀 다르다 ;;)</p><p><img src="https://i.imgur.com/Vm9NDZf.png" alt="Imgur"></p><p>그런데 로그를 자세히 보면 <code>&#39;o.s.aop.framework.CglibAopProxy : Unable to apply any optimizations to advised method: [[[@Transactional_붙어있는_메서드]]]&#39;</code> 대략 이런 내용이 찍히고, 실제로도 트랜잭션 롤백이 동작하지 않았다.</p><p>더 결정적인 문제도 있는데 이렇게 <strong>스프링이 제공해주는 프록시 생성 로직을 통해 프록시로 등록되면 해당 프록시는 캐시된다는 점이다. 그래서 나중에 <code>RemoteSimpleJob</code>의 내용을 바꿔서 작업 클래스 모듈의 jar 를 새로 생성한 후에 <code>RemoteSimpleJob</code>을 다시 수행해도 새 프록시가 생성되지 않고 기존 내용을 기준으로 생성되어 캐시된 프록시가 사용될 수 있다.</strong> 이러면 작업 클래스 모듈을 분리한 의도가 퇴색되어 버리는 결과가 된다.</p><p>이런 모든 문제를 해결하려면 할 수도 있겠지만 나는 이 정도에서 멈추기로 한다. 왜냐하면 <strong>스프링에서는 <code>@Transactional</code>이 아니라도 <code>PlatformTransactionManager</code>를 사용해서 트랜잭션 기능을 추가할 수 있기 때문이다.</strong></p><h2 id="PlatformTransactionManager-사용"><a href="#PlatformTransactionManager-사용" class="headerlink" title="PlatformTransactionManager 사용"></a>PlatformTransactionManager 사용</h2><p>다음과 같이 <code>@Transactional</code>을 제거하고 <code>PlatformTransactionManager</code>를 사용하도록 <code>RemoteSimpleJob</code>을 개선한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteSimpleJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HelloService helloService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemberRepository memberRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlatformTransactionManager transactionManager;  <span class="comment">// 여기!!</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"OOO REMOTE JOB [&#123;&#125;] executed."</span>, <span class="keyword">this</span>.getClass().getSimpleName());</span><br><span class="line">        JobDataMap mergedJobDataMap = context.getMergedJobDataMap();</span><br><span class="line">        mergedJobDataMap.forEach((k, v) -&gt; log.info(<span class="string">"OOOOO &#123;&#125;: &#123;&#125;"</span>, k, v));</span><br><span class="line"></span><br><span class="line">        helloService.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 여기!!</span></span><br><span class="line">        TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Member dbMember = memberRepository.save(<span class="keyword">new</span> Member(<span class="string">"Homo Efficio"</span>, <span class="string">"homo.efficio@gmail.com"</span>));</span><br><span class="line">            log.info(<span class="string">"TTT 회원 [&#123;&#125;] 추가됨"</span>, dbMember);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"테스트를 위해 강제로 발생시킨 예외"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            transactionManager.commit(status);  <span class="comment">// 여기!!</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"TTT 회원 추가 중 예외 발생. 메시지: &#123;&#125;"</span>,e.getMessage());</span><br><span class="line">            transactionManager.rollback(status);  <span class="comment">// 여기!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행해보면 다음과 같이 <code>TTT 회원 [{}] 추가됨</code> 로그는 찍히지만 그 이후 예외가 발생한다.</p><p><img src="https://i.imgur.com/l0xcJB8.png" alt="Imgur"></p><p>이제 레코드가 생성되지 않은 것을 h2 web console에서 확인하면 트랜잭션 처리 문제도 해결된다!</p><p><img src="https://i.imgur.com/JDciNBU.png" alt="Imgur"></p><p>오오~ 예상대로 레코드가 생성되지 않았다. 성공!</p><p>세 번째 고개인 <code>@Transactional</code>은 넘지는 못 했지만, 돌아가는 길을 찾아냈다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><ul><li><p>스프링부트 애플리케이션에서 분리되어 나간 작업 클래스 모듈에서는 <code>@Transactional</code>을 일반적인 경우처럼 쉽게 사용할 수 없다.</p></li><li><p>이유는 <code>@Transactional</code> 기능을 추가하기 위해서 <code>RemoteSimpleJob</code>의 프록시 객체를 CGLib 라이브러리를 이용해서 생성해야 하는데, 이때 <code>RemoteSimpleJob</code> 클래스를 찾을 수 없기 때문이다.</p></li><li><p>작업 클래스 모듈에서 <code>@Transactional</code>은 사용할 수 없지만 <code>PlatformTransactionManager</code>를 이용하면 트랜잭션 처리를 할 수 있다.</p></li></ul></blockquote><h1 id="시리즈-마무리"><a href="#시리즈-마무리" class="headerlink" title="시리즈 마무리"></a>시리즈 마무리</h1><p>총 3편에 걸쳐 Quartz 적용 아키텍처를 개선하는 과정을 살펴봤다.</p><p>이를 통해 <strong>변경 주기가 다른 스케줄러와 작업 클래스를 별도의 모듈로 분리하고, 분리된 모듈에 의존 관계를 주입해서 트랜잭션까지 처리할 수 있는 클린 Quartz 아키텍처를 적용할 수 있게 됐다.</strong></p><h2 id="1편-모듈-분리"><a href="#1편-모듈-분리" class="headerlink" title="1편 모듈 분리"></a>1편 모듈 분리</h2><p><a href="https://homoefficio.github.io/2019/09/28/Quartz-스케줄러-적용-아키텍처-개선-1/">1편</a>의 키워드는 <strong>모듈 분리와  <code>URLClassLoader</code></strong></p><p><img src="https://i.imgur.com/5RHsMzy.png" alt="Imgur"></p><h2 id="2편-의존-관계-주입"><a href="#2편-의존-관계-주입" class="headerlink" title="2편 의존 관계 주입"></a>2편 의존 관계 주입</h2><p><a href="https://homoefficio.github.io/2019/09/29/Quartz-스케줄러-적용-아키텍처-개선-2/">2편</a>의 키워드는 <strong>의존 관계 주입과 <code>SpringBeanJobFactory</code></strong></p><p><img src="https://i.imgur.com/mT6CfNb.png" alt="Imgur"></p><h2 id="3편-트랜잭션-처리"><a href="#3편-트랜잭션-처리" class="headerlink" title="3편 트랜잭션 처리"></a>3편 트랜잭션 처리</h2><p><a href="https://homoefficio.github.io/2019/09/29/Quartz-스케줄러-적용-아키텍처-개선-3/">3편</a>의 키워드는 <strong>트랜잭션 처리와 <code>PlatformTransactionManager</code></strong></p><p><img src="https://i.imgur.com/dbHHXDv.png" alt="Imgur"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Quartz-스케줄러-적용-아키텍처-개선-3&quot;&gt;&lt;a href=&quot;#Quartz-스케줄러-적용-아키텍처-개선-3&quot; class=&quot;headerlink&quot; title=&quot;Quartz 스케줄러 적용 아키텍처 개선 - 3&quot;&gt;&lt;/a&gt;Quartz 스케줄러 
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Quartz" scheme="http://homoefficio.github.io/tags/Quartz/"/>
    
      <category term="Scheduler" scheme="http://homoefficio.github.io/tags/Scheduler/"/>
    
      <category term="Clean Architecture" scheme="http://homoefficio.github.io/tags/Clean-Architecture/"/>
    
      <category term="Interface Segregation Principle" scheme="http://homoefficio.github.io/tags/Interface-Segregation-Principle/"/>
    
      <category term="Dependency Inversion Principle" scheme="http://homoefficio.github.io/tags/Dependency-Inversion-Principle/"/>
    
      <category term="Dependency Injection" scheme="http://homoefficio.github.io/tags/Dependency-Injection/"/>
    
      <category term="SpringBeanJobFactory" scheme="http://homoefficio.github.io/tags/SpringBeanJobFactory/"/>
    
      <category term="ApplicationContext" scheme="http://homoefficio.github.io/tags/ApplicationContext/"/>
    
      <category term="ApplicationContextAware" scheme="http://homoefficio.github.io/tags/ApplicationContextAware/"/>
    
      <category term="AdaptableJobFactory" scheme="http://homoefficio.github.io/tags/AdaptableJobFactory/"/>
    
      <category term="AutowireCapableBeanFactory" scheme="http://homoefficio.github.io/tags/AutowireCapableBeanFactory/"/>
    
      <category term="SchedulerFactoryBean" scheme="http://homoefficio.github.io/tags/SchedulerFactoryBean/"/>
    
      <category term="Isolation" scheme="http://homoefficio.github.io/tags/Isolation/"/>
    
      <category term="쿼츠" scheme="http://homoefficio.github.io/tags/%EC%BF%BC%EC%B8%A0/"/>
    
      <category term="스케줄러" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC/"/>
    
      <category term="클린 아키텍처" scheme="http://homoefficio.github.io/tags/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"/>
    
      <category term="인터페이스 분리 원칙" scheme="http://homoefficio.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99/"/>
    
      <category term="의존 관계 역전 원칙" scheme="http://homoefficio.github.io/tags/%EC%9D%98%EC%A1%B4-%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99/"/>
    
      <category term="의존 관계 주입" scheme="http://homoefficio.github.io/tags/%EC%9D%98%EC%A1%B4-%EA%B4%80%EA%B3%84-%EC%A3%BC%EC%9E%85/"/>
    
      <category term="격리" scheme="http://homoefficio.github.io/tags/%EA%B2%A9%EB%A6%AC/"/>
    
      <category term="Transaction" scheme="http://homoefficio.github.io/tags/Transaction/"/>
    
      <category term="Transactional" scheme="http://homoefficio.github.io/tags/Transactional/"/>
    
      <category term="CGLib" scheme="http://homoefficio.github.io/tags/CGLib/"/>
    
      <category term="Proxy" scheme="http://homoefficio.github.io/tags/Proxy/"/>
    
      <category term="PlatformTransactionManager" scheme="http://homoefficio.github.io/tags/PlatformTransactionManager/"/>
    
      <category term="트랜잭션" scheme="http://homoefficio.github.io/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"/>
    
      <category term="프록시" scheme="http://homoefficio.github.io/tags/%ED%94%84%EB%A1%9D%EC%8B%9C/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 스케줄러 적용 아키텍처 개선 - 2</title>
    <link href="http://homoefficio.github.io/2019/09/29/Quartz-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC-%EC%A0%81%EC%9A%A9-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B0%9C%EC%84%A0-2/"/>
    <id>http://homoefficio.github.io/2019/09/29/Quartz-스케줄러-적용-아키텍처-개선-2/</id>
    <published>2019-09-29T03:49:40.000Z</published>
    <updated>2019-10-03T15:05:05.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartz-스케줄러-적용-아키텍처-개선-2"><a href="#Quartz-스케줄러-적용-아키텍처-개선-2" class="headerlink" title="Quartz 스케줄러 적용 아키텍처 개선 - 2"></a>Quartz 스케줄러 적용 아키텍처 개선 - 2</h1><p><a href="https://homoefficio.github.io/2019/09/28/Quartz-스케줄러-적용-아키텍처-개선-1/">1편</a>에서는 Quartz 스케줄러 적용 시 변경 주기가 다른 스케줄러 모듈과 작업 클래스 모듈을 분리해서 클린 아키텍처에 다가가는 방법을 알아봤다.</p><p>분리된 작업 클래스 모듈은 DB 작업을 할 수도 있고, 하둡 인프라 관련 작업을 할 수도 있고, 알림 메일도 보내야하는 등 여러 작업을 할 수 있어야 한다. 그런데 작업 클래스 모듈은 말 그대로 작업 클래스만 모아 놓은 jar 라이브러리일 뿐이라서 JDBC 드라이버나 SMTP 메일 서버 설정 등을 포함하고 있지 않으며, 이런 것들을 스스로 가지고 있는 것 자체도 Single Responsibility Principle 관점에서 보면 적절하지 않다.</p><p>그래서 작업 클래스 모듈을 동적으로 로딩하는 스케줄러 모듈이 작업 클래스가 필요로 하는 컴포넌트를 주입해주는 구조로 구성할 수 있다면 가장 좋다. 즉, 다음과 같이 <code>@Autowire</code>를 통해 작업 클래스에 필요한 의존 관계를 주입해 줄 수 있다면 딱 좋다. </p><p><img src="https://i.imgur.com/mT6CfNb.png" alt="Imgur"></p><p>그런데 보통 <code>@Autowire</code>는 스프링 애플리케이션이 구동되면서 bean을 생성하고 객체 협력망을 구성할 때 작동한다. 지금처럼 스케줄러를 포함한 스프링 애플리케이션이 완전히 구동된 후에 동적으로 작업 클래스를 로딩할 때도 <code>@Autowire</code>를 통해 의존 관계 주입하는 것이 가능할까?</p><h1 id="SpringBeanJobFactory"><a href="#SpringBeanJobFactory" class="headerlink" title="SpringBeanJobFactory"></a>SpringBeanJobFactory</h1><p>결론부터 말하면 <strong>스프링부트가 제공하는 <code>SpringBeanJobFactory</code>를 통해 애플리케이션 구동 완료 후에 동적으로 추가하는 bean에도 의존 관계를 쉽게 주입할 수 있다.</strong></p><p>예제에서는 편의상 스케줄링 직후 작업이 수행되도록 작성했지만, 스케줄러는 일반적으로 작업을 스케줄하는 시점과 작업을 실행하는 시점이 다르다. Quartz 스케줄러도 마찬가지며 스케줄하는 시점에도 작업 클래스를 로딩하지만 작업을 실행하는 시점에도 클래스를 로딩한다. 그리고 작업을 실행하려면 작업 클래스를 인스턴스화 해야 하는데, 이 때 <code>JobFactory</code>가 사용된다. <a href="https://www.quartz-scheduler.org/api/2.3.1-SNAPSHOT/index.html" target="_blank" rel="noopener">문서</a>에도 나와있는 것처럼 <strong><code>JobFactory</code>를 의존 관계 주입 통로로 사용할 수 있다.</strong></p><p>스프링은 꽤 오래 전부터 Quartz를 지원해오고 있으며, 스프링부트에도 quartz starter가 있고 그 안에 <code>JobFactory</code>를 구현한 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/quartz/SpringBeanJobFactory.html" target="_blank" rel="noopener"><code>SpringBeanJobFactory</code></a>가 있다. 애플리케이션 실행 로그를 살펴보면 <code>SpringBeanJobFactory</code>가 사용되고 있음을 알 수 있다.</p><p><img src="https://i.imgur.com/6cElvr0.png" alt="Imgur"></p><p>따라서 <strong>스프링부트를 통해 quartz를 사용하고 있다면, <code>SpringBeanJobFactory</code> 덕분에 작업 클래스도 일반적인 스프링 bean과 마찬가지로 간단하게 의존 관계 주입이 가능하다.</strong> 이제 관련 코드를 작성하면서 알아보자.</p><h2 id="주입할-컴포넌트-생성"><a href="#주입할-컴포넌트-생성" class="headerlink" title="주입할 컴포넌트 생성"></a>주입할 컴포넌트 생성</h2><p>먼저 주입할 컴포넌트를 만들자. 스케줄러 모듈 쪽에 다음과 같이 단순한 <code>HelloService</code>를 추가한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"OOO &#123;&#125;.sayHello() executed"</span>, <span class="keyword">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="모듈-의존-관계-추가"><a href="#모듈-의존-관계-추가" class="headerlink" title="모듈 의존 관계 추가"></a>모듈 의존 관계 추가</h2><p>작업 클래스 모듈에 있는 <code>RemoteSimpleJob</code>가 스케줄러 모듈에 있는 <code>HelloService</code>를 주입 받으려면 다음과 같이 코드 상으로 <code>HelloService</code>가 명시돼야 하는데, 작업 클래스 모듈에서는 <code>HelloService</code>를 인식할 수 없으며, 컴파일 에러가 발생한다.</p><p>따라서 작업 클래스 모듈의 <code>build.gradle</code> 파일에 다음과 같이 스케줄러 모듈(quartz-scheduler)에 대한 의존 관계를 추가한다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile project(<span class="string">':quartz-scheduler'</span>)  <span class="comment">// 여기!!</span></span><br><span class="line"></span><br><span class="line">    compileOnly <span class="string">'org.projectlombok:lombok:1.18.8'</span></span><br><span class="line">    annotationProcessor <span class="string">'org.projectlombok:lombok:1.18.8'</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.quartz-scheduler'</span>, <span class="string">name:</span> <span class="string">'quartz'</span>, <span class="string">version:</span> <span class="string">'2.3.1'</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.springframework'</span>, <span class="string">name:</span> <span class="string">'spring-context-support'</span>, <span class="string">version:</span> <span class="string">'5.1.9.RELEASE'</span></span><br><span class="line"></span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="작업-클래스에-의존-관계-추가"><a href="#작업-클래스에-의존-관계-추가" class="headerlink" title="작업 클래스에 의존 관계 추가"></a>작업 클래스에 의존 관계 추가</h2><p>다음과 같이 스케줄러 모듈에 있는 <code>HelloService</code>를 주입 받아서 사용하는 코드를 <code>RemoteSimpleJob</code>에 추가한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>  <span class="comment">// 여기!!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteSimpleJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HelloService helloService;  <span class="comment">// 여기!!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"OOO REMOTE JOB [&#123;&#125;] executed."</span>, <span class="keyword">this</span>.getClass().getSimpleName());</span><br><span class="line">        JobDataMap mergedJobDataMap = context.getMergedJobDataMap();</span><br><span class="line">        mergedJobDataMap.forEach((k, v) -&gt; log.info(<span class="string">"OOOOO &#123;&#125;: &#123;&#125;"</span>, k, v));</span><br><span class="line"></span><br><span class="line">        helloService.sayHello();  <span class="comment">// 여기!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>작업 클래스 모듈에 추가해둔 <code>deployJar</code>를 실행하고 애플리케이션을 다시 실행하면 <code>RemoteSimpleJob</code>이 <code>HelloService</code>를 주입 받아서 사용함을 확인할 수 있다.</p><p><img src="https://i.imgur.com/wBqMrZP.png" alt="Imgur"></p><p>자 이제 의존 관계 주입이라는 두 번째 고개를 넘었다. 그래서 DB 작업도 할 수 있게 됐다. 그런데 DB 작업을 할 때는 트랜잭션 처리를 해줘야 한다. 스프링에서는 <code>@Transactional</code>을 통해 아주 쉽게 트랜잭션 처리를 할 수 있다. 작업 클래스에서도 <code>@Transactional</code>을 사용할 수 있을까? 마지막 세 번째 고개는 <code>@Transactional</code>이다. <a href="https://homoefficio.github.io/2019/09/29/Quartz-스케줄러-적용-아키텍처-개선-3/">3편</a>에서<br>다룬다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><ul><li><p>Quartz 작업 클래스 모듈이 실무에서 발생하는 다양한 작업을 수행하려면 관련 컴포넌트를 주입 받아야 한다.</p></li><li><p>스프링부트에서 제공하는 <code>SpringBeanJobFactory</code> 덕분에 Quartz 작업 클래스에서도 일반적인 bean과 마찬가지 방식으로 간단하게 의존 관계를 주입 받을 수 있다.</p></li></ul></blockquote><h1 id="번외편-스프링부트가-아닌-그냥-스프링일-경우"><a href="#번외편-스프링부트가-아닌-그냥-스프링일-경우" class="headerlink" title="(번외편) 스프링부트가 아닌 그냥 스프링일 경우"></a>(번외편) 스프링부트가 아닌 그냥 스프링일 경우</h1><p>스프링부트가 아니라 그냥 스프링에서 Quartz를 사용할 때도 의존 관계 주입이 가능하다.</p><p>Quartz에서는 <code>JobFactory</code>라는 의존 관계 주입 통로를 제공하고 있고, 스프링에서는 <code>JobFactory</code>의 구현체인 <code>AdaptableJobFactory</code>를 스프링 2.0부터 제공해오고 있다. 그리고 스프링에는 의존 관계를 주입하면서 bean을 만들어 주는 <code>AutowireCapableBeanFactory</code>가 있다. 따라서 다음과 같은 커스텀 팩토리를 만들어주고, 이를 Quartz 스케줄러에서 사용할 수 있게 설정해주면 된다.</p><h2 id="커스텀-작업-팩토리"><a href="#커스텀-작업-팩토리" class="headerlink" title="커스텀 작업 팩토리"></a>커스텀 작업 팩토리</h2><p>커스텀 작업 팩토리의 역할은 작업 클래스 인스턴스 생성과 의존 관계 주입하기, 이렇게 두 가지다.</p><p>작업 클래스 인스턴스 생성은 <code>AdaptableJobFactory</code>에 이미 있는 기능이다. 여기에 의존 관계 주입 기능만 추가해주면 되므로 <code>AdaptableJobFactory</code>를 상속받아서 해당 부분만 오버라이드 하면 된다.</p><p>의존 관계를 주입하려면 <code>AutowireCapableBeanFactory</code>가 필요하고, <code>AutowireCapableBeanFactory</code>를 얻으려면 <code>ApplicationContext</code>가 필요하다. 어떻게든 <code>ApplicationContext</code>를 주입 받을 수 있으면 그만이지만 딱 이런 역할을 의미하는 <code>ApplicationContextAware</code>라는 인터페이스가 있으니 구현해주자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzJobFactory</span> <span class="keyword">extends</span> <span class="title">AdaptableJobFactory</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createJobInstance</span><span class="params">(TriggerFiredBundle bundle)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object jobInstance = <span class="keyword">super</span>.createJobInstance(bundle);</span><br><span class="line">        autowireBean(jobInstance);</span><br><span class="line">        <span class="keyword">return</span> jobInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">autowireBean</span><span class="params">(Object jobInstance)</span> </span>&#123;</span><br><span class="line">        AutowireCapableBeanFactory autowireCapableBeanFactory = applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line">        autowireCapableBeanFactory.autowireBean(jobInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="커스텀-스케줄러-팩토리-및-Configuration-클래스"><a href="#커스텀-스케줄러-팩토리-및-Configuration-클래스" class="headerlink" title="커스텀 스케줄러 팩토리 및 @Configuration 클래스"></a>커스텀 스케줄러 팩토리 및 @Configuration 클래스</h2><p>스프링부트는 starter를 통해 자동 설정한 Quartz 스케줄러를 제공하지만 스프링이라면 스케줄러도 직접 생성하고 설정해줘야 한다. 그리고 앞에서 만든 커스텀 작업 팩토리를 직접 생성한 스케줄러에 설정해주면 된다.</p><p>스프링에서는 4.1부터 Quartz 스케줄러 생성 작업을 쉽게 해주는 <code>SchedulerFactoryBean</code>도 제공한다. Quartz 2.1.4 이상이면 호환 가능하다. 따라서 다음과 같이 커스텀 스케줄러 팩토리를 만들어서 Autowiring 기능이 탑재된 커스텀 작업 팩토리를 설정해주고, Quartz 스케줄러를 bean으로 반환하는 설정 클래스를 작성하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">scheduler</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        SchedulerFactoryBean schedulerFactoryBean = getSchedulerFactoryBean(applicationContext);</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean.getScheduler();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> SchedulerFactoryBean <span class="title">getSchedulerFactoryBean</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        QuartzJobFactory quartzJobFactory = <span class="keyword">new</span> QuartzJobFactory();</span><br><span class="line">        quartzJobFactory.setApplicationContext(applicationContext);</span><br><span class="line"></span><br><span class="line">        SchedulerFactoryBean schedulerFactoryBean = <span class="keyword">new</span> SchedulerFactoryBean();</span><br><span class="line">        schedulerFactoryBean.setJobFactory(quartzJobFactory);</span><br><span class="line"><span class="comment">//        schedulerFactoryBean.setXXX(...); // 기타 스케줄러 설정값 직접 지정 필요</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Quartz-스케줄러-적용-아키텍처-개선-2&quot;&gt;&lt;a href=&quot;#Quartz-스케줄러-적용-아키텍처-개선-2&quot; class=&quot;headerlink&quot; title=&quot;Quartz 스케줄러 적용 아키텍처 개선 - 2&quot;&gt;&lt;/a&gt;Quartz 스케줄러 
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Quartz" scheme="http://homoefficio.github.io/tags/Quartz/"/>
    
      <category term="Scheduler" scheme="http://homoefficio.github.io/tags/Scheduler/"/>
    
      <category term="Clean Architecture" scheme="http://homoefficio.github.io/tags/Clean-Architecture/"/>
    
      <category term="Interface Segregation Principle" scheme="http://homoefficio.github.io/tags/Interface-Segregation-Principle/"/>
    
      <category term="Dependency Inversion Principle" scheme="http://homoefficio.github.io/tags/Dependency-Inversion-Principle/"/>
    
      <category term="Dependency Injection" scheme="http://homoefficio.github.io/tags/Dependency-Injection/"/>
    
      <category term="SpringBeanJobFactory" scheme="http://homoefficio.github.io/tags/SpringBeanJobFactory/"/>
    
      <category term="ApplicationContext" scheme="http://homoefficio.github.io/tags/ApplicationContext/"/>
    
      <category term="ApplicationContextAware" scheme="http://homoefficio.github.io/tags/ApplicationContextAware/"/>
    
      <category term="AdaptableJobFactory" scheme="http://homoefficio.github.io/tags/AdaptableJobFactory/"/>
    
      <category term="AutowireCapableBeanFactory" scheme="http://homoefficio.github.io/tags/AutowireCapableBeanFactory/"/>
    
      <category term="SchedulerFactoryBean" scheme="http://homoefficio.github.io/tags/SchedulerFactoryBean/"/>
    
      <category term="Isolation" scheme="http://homoefficio.github.io/tags/Isolation/"/>
    
      <category term="쿼츠" scheme="http://homoefficio.github.io/tags/%EC%BF%BC%EC%B8%A0/"/>
    
      <category term="스케줄러" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC/"/>
    
      <category term="클린 아키텍처" scheme="http://homoefficio.github.io/tags/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"/>
    
      <category term="인터페이스 분리 원칙" scheme="http://homoefficio.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99/"/>
    
      <category term="의존 관계 역전 원칙" scheme="http://homoefficio.github.io/tags/%EC%9D%98%EC%A1%B4-%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99/"/>
    
      <category term="의존 관계 주입" scheme="http://homoefficio.github.io/tags/%EC%9D%98%EC%A1%B4-%EA%B4%80%EA%B3%84-%EC%A3%BC%EC%9E%85/"/>
    
      <category term="격리" scheme="http://homoefficio.github.io/tags/%EA%B2%A9%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 스케줄러 적용 아키텍처 개선 - 1</title>
    <link href="http://homoefficio.github.io/2019/09/28/Quartz-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC-%EC%A0%81%EC%9A%A9-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B0%9C%EC%84%A0-1/"/>
    <id>http://homoefficio.github.io/2019/09/28/Quartz-스케줄러-적용-아키텍처-개선-1/</id>
    <published>2019-09-28T09:01:09.000Z</published>
    <updated>2019-10-03T13:43:32.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartz-스케줄러-적용-아키텍처-개선-1"><a href="#Quartz-스케줄러-적용-아키텍처-개선-1" class="headerlink" title="Quartz 스케줄러 적용 아키텍처 개선 - 1"></a>Quartz 스케줄러 적용 아키텍처 개선 - 1</h1><p>Quartz는 스프링에서도 지원하고 있어서 스프링 기반 프로젝트에도 쉽게 통합해서 사용할 수 있으므로 널리 사용되고 있다. 게다가 properties 파일 설정만으로 간단하게 클러스터를 구성해서 부하 분산 및 fail-over가 가능한 것도 장점이다.</p><p>Quartz에 나오는 주요 등장 인물에 대한 설명이나 기본 사용 방법은 검색해보면 많이 나오므로 여기에서는 생략하고 실제 적용할 때 필요한 아키텍처 개선에만 초점을 맞춘다. 관련 코드 역시 주요 부분만 표시하면서 진행한다.</p><p>OpenJDK 9, 그레이들 5.6.2, 스프링부트 2.1.8, 스프링 5.1.9, Quartz 2.3.1 기준이다.</p><h1 id="Quartz-실행-흐름"><a href="#Quartz-실행-흐름" class="headerlink" title="Quartz 실행 흐름"></a>Quartz 실행 흐름</h1><p>Quartz 실행 흐름은 다음 그림에 잘 정리돼 있다. 간단하게 요약하면 <code>Scheduler</code>가 <code>Job</code>의 실행 정보를 통해 정해진 시간이나 정해진 주기로 <code>Job</code>을 실행한다.</p><p><img src="https://i.imgur.com/JB5c5mF.jpg" alt="Imgur"></p><p>그림 출처: <a href="https://examples.javacodegeeks.com/enterprise-java/quartz/java-quartz-architecture-example/" target="_blank" rel="noopener">https://examples.javacodegeeks.com/enterprise-java/quartz/java-quartz-architecture-example/</a></p><h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>그림에서 보듯 실행 흐름 관점에서 보면 <code>Scheduler</code>가 <code>Job</code>을 사용하며 <code>Job</code>에 의존하고 있다. 하지만 <code>Scheduler</code>는 사실 상 Quartz 프레임워크 그 자체로서 안정적인 모듈이고, <code>Job</code>은 <code>Scheduler</code>에 의해 실행될 실제 작업에 대한 로직이 포함돼 있어 변경 빈도가 더 높고, <code>Job</code> 자체가 추가/삭제되는 일도 빈번하므로 불안정하다. 안정적인 모듈이 불안정한 모듈에 의존하는 것은 좋지 않다. Quartz 개발자들이 이런 사실을 모를 리 없다.</p><p>그래서 <code>Job</code>은 사실 인터페이스다. 그리고 <code>Scheduler</code>에 의해 실행되는 실제 작업들은 <code>Job</code> 인터페이스의 구현체 들이다. 즉 Quartz 자체는 <code>Scheduler</code>와 <code>Job</code> 구현체를 분리할 수 있게 잘 설계돼 있다.</p><p>그런데 이렇게 <strong>분리할 수 있음에도 불구하고 <code>Scheduler</code>와 <code>Job</code> 인터페이스의 구현체를 같은 모듈 안에 두면서 문제가 시작된다.</strong> 작업을 추가하려면 스케줄러까지 재배포를 해야 되며, 스케줄러 재배포는 스케줄러의 중단을 의미하므로 실행되는 작업이 없을 때만 가능하며, 많은 작업이 스케줄링 돼 있다면 재배포 타이밍을 잡기가 어려워진다. 따라서 스케줄러 본체인 <code>Scheduler</code>와 작업 클래스인 <code>Job</code> 구현체를 다음과 같이 분리해서 별도로 배포할 수 있으면 이 문제를 해결할 수 있다.</p><p><img src="https://i.imgur.com/5RHsMzy.png" alt="Imgur"></p><p>하지만 인터넷에서 찾을 수 있는 대부분의 Quartz 사용법이나 예제는 <code>Scheduler</code>와 <code>Job</code> 구현체를 동일한 서버 인스턴스에 일체형으로 묶어둔 아키텍처를 기준으로 설명하고 있다. 아마도 Quartz의 사용법 자체에 중점을 두기 때문이겠지만, 이유야 어찌됐든 자료가 그러하므로 결국 실제 프로젝트에 적용할 때도 일체형으로 구성하는 곳이 많은 것 같다.</p><p>이제 스케줄러와 작업 클래스를 분리해서 별도로 배포할 수 있게 만들고 클린 아키텍처에 한 걸음 다가가보자. 3가지 고개를 넘어야 한다.</p><h1 id="클래스로딩"><a href="#클래스로딩" class="headerlink" title="클래스로딩"></a>클래스로딩</h1><p>스케줄러가 작업을 스케줄하려면 작업 클래스를 로딩하고 실행 주기를 지정해야 한다. 대략 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Init Runner executed."</span>);</span><br><span class="line">        JobKey jobKey = JobKey.jobKey(<span class="string">"jobkey1"</span>, <span class="string">"jobgroup1"</span>);</span><br><span class="line">        JobDetail jobDetail = buildJobDetail(jobKey);</span><br><span class="line">        Trigger trigger = buildJobTrigger(jobKey);</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);  <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JobDetail <span class="title">buildJobDetail</span><span class="params">(JobKey jobKey)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        JobDataMap jobDataMap = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">        jobDataMap.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        jobDataMap.put(<span class="string">"key2"</span>, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(SimpleJob.class)  <span class="comment">// (2)</span></span><br><span class="line">                .withIdentity(jobKey)</span><br><span class="line">                .withDescription(<span class="string">"Simple Quartz Job Detail"</span>)</span><br><span class="line">                .usingJobData(jobDataMap)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Trigger <span class="title">buildJobTrigger</span><span class="params">(JobKey jobKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(jobKey)</span><br><span class="line">                .withDescription(<span class="string">"Simple Quartz Job Trigger"</span>)</span><br><span class="line">                .startNow()  <span class="comment">// 스케줄링 되면 바로 실행되는 방식</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"OOO JOB [&#123;&#125;] executed."</span>, <span class="keyword">this</span>.getClass().getSimpleName());</span><br><span class="line">        JobDataMap mergedJobDataMap = context.getMergedJobDataMap();</span><br><span class="line">        mergedJobDataMap.forEach((k, v) -&gt; log.info(<span class="string">"OOOOO &#123;&#125;: &#123;&#125;"</span>, k, v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스케줄러에 의해 실행되는 <code>SimpleJob</code>은 단순하게 <code>JobExecutionContext</code>에 담겨 있는 키-밸류를 출력한다.</p><p>(1)과 같이 <code>JobDetail</code>과 <code>Trigger</code>를 <code>Scheduler</code>에 전달해주면 스케줄링 된다. 실행될 작업의 클래스는 (2)와 같이 클래스 리터럴 형태로 <code>JobDetail</code>에 지정된다. <code>Trigger</code>는 편의상 (3)과 같이 바로 실행되는 방식으로 지정했지만 Cron Expression 등 다양한 방식으로 지정할 수 있다.</p><p>실행해보면 다음과 같이 <code>SimpleJob</code>이 실행된다.</p><p><img src="https://i.imgur.com/XDItlAj.png" alt="Imgur"></p><h2 id="커스텀-클래스로더"><a href="#커스텀-클래스로더" class="headerlink" title="커스텀 클래스로더"></a>커스텀 클래스로더</h2><p>아키텍처 관점에서 중요한 지점은 (2)다. 일체형일 때는 위와 같이 직접 <code>SimpleJob.class</code>로 지정해주면 되지만, 분리돼 있다면 해당 클래스를 외부에서 읽어와야 한다. 따라서 다음과 같이 <code>URLClassLoader</code>를 활용해서 <code>JOB_REPO</code>로 지정된 jar 파일에 있는 작업 클래스를 로딩할 수 있는 커스텀 클래스로더가 필요하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteJobClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JOB_REPO = <span class="string">"/tmp/homo-efficio/quartz/remote-job-repo/quartz-job.jar"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Class&lt;? extends T&gt; loadClass(String name, Class&lt;T&gt; clazz) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Class&lt;? extends T&gt;) getClassLoader().loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> URLClassLoader(</span><br><span class="line">                    <span class="keyword">new</span> URL[] &#123;</span><br><span class="line">                            <span class="keyword">new</span> File(JOB_REPO).toURI().toURL()</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// URLClassLoader 설정 시 parent를 webAppClassLoader로 지정해줘야</span></span><br><span class="line">                    <span class="comment">// org.quartz.Job 등 내부 의존 클래스 로딩 가능</span></span><br><span class="line">                    <span class="keyword">this</span>.getClass().getClassLoader()</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바 클래스로딩은 <a href="https://homoefficio.github.io/2018/10/13/Java-클래스로더-훑어보기/">https://homoefficio.github.io/2018/10/13/Java-클래스로더-훑어보기/</a> 와 <a href="https://homoefficio.github.io/2018/10/14/Java-URLClassLoader로-알아보는-클래스로딩/">https://homoefficio.github.io/2018/10/14/Java-URLClassLoader로-알아보는-클래스로딩/</a> 를 보면 도움이 될 것이다.</p><h2 id="작업-클래스-외부화"><a href="#작업-클래스-외부화" class="headerlink" title="작업 클래스 외부화"></a>작업 클래스 외부화</h2><p>이제 작업 클래스를 외부로 분리해보자. 지금까지 만든 파일은 모두 <code>quartz-scheduler</code>에 있고, 새로 <code>quartz-job</code> 모듈을 만들어서 작업 클래스는 모두 이 모듈에 둔다.</p><p><img src="https://i.imgur.com/4BFS4lx.png" alt="Imgur"></p><p><code>quartz-job</code> 모듈의 <code>build.gradle</code> 파일은 다음과 같이 작성한다. jar 파일을 <code>RemoteJobClassLoader</code>가 읽을 수 있는 위치에 배포하는 <code>deployJar</code> 태스크를 추가했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &apos;java&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">version &apos;unspecified&apos;</span><br><span class="line"></span><br><span class="line">sourceCompatibility = &apos;9&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly &apos;org.projectlombok:lombok:1.18.8&apos;</span><br><span class="line">    annotationProcessor &apos;org.projectlombok:lombok:1.18.8&apos;</span><br><span class="line">    compile group: &apos;org.quartz-scheduler&apos;, name: &apos;quartz&apos;, version: &apos;2.3.1&apos;</span><br><span class="line">    compile group: &apos;org.springframework&apos;, name: &apos;spring-context-support&apos;, version: &apos;5.1.9.RELEASE&apos;</span><br><span class="line"></span><br><span class="line">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task deployJar(type: Copy) &#123;</span><br><span class="line">    dependsOn(&apos;jar&apos;)</span><br><span class="line">    from &quot;$buildDir/libs/quartz-job.jar&quot;</span><br><span class="line">    into &quot;/tmp/homo-efficio/quartz/remote-job-repo/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아까 나왔던 <code>SimpleJob</code>과 거의 동일한 내용의 <code>RemoteSimpleJob</code> 클래스를 <code>quartz-job</code> 아래에 만든다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteSimpleJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"OOO REMOTE JOB [&#123;&#125;] executed."</span>, <span class="keyword">this</span>.getClass().getSimpleName());</span><br><span class="line">        JobDataMap mergedJobDataMap = context.getMergedJobDataMap();</span><br><span class="line">        mergedJobDataMap.forEach((k, v) -&gt; log.info(<span class="string">"OOOOO &#123;&#125;: &#123;&#125;"</span>, k, v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>작업 스케줄링 하는 부분을 다음과 같이 <code>RemoteJobClassLoader</code>를 사용해서 작업 클래스를 로딩하도록 바꾼다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RemoteJobClassLoader remoteJobClassLoader;  <span class="comment">// 여기!!</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Init Runner executed."</span>);</span><br><span class="line">        JobKey jobKey = JobKey.jobKey(<span class="string">"jobkey1"</span>, <span class="string">"jobgroup1"</span>);</span><br><span class="line">        JobDetail jobDetail = buildJobDetail(jobKey);</span><br><span class="line">        Trigger trigger = buildJobTrigger(jobKey);</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JobDetail <span class="title">buildJobDetail</span><span class="params">(JobKey jobKey)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        JobDataMap jobDataMap = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">        jobDataMap.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        jobDataMap.put(<span class="string">"key2"</span>, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 여기!!</span></span><br><span class="line"><span class="comment">//        return JobBuilder.newJob(SimpleJob.class)</span></span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(remoteJobClassLoader.loadClass(<span class="string">"io.homo_efficio.quartz.job.RemoteSimpleJob"</span>, Job.class))</span><br><span class="line">                .withIdentity(jobKey)</span><br><span class="line">                .withDescription(<span class="string">"Simple Quartz Job Detail"</span>)</span><br><span class="line">                .usingJobData(jobDataMap)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Trigger <span class="title">buildJobTrigger</span><span class="params">(JobKey jobKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(jobKey)</span><br><span class="line">                .withDescription(<span class="string">"Simple Quartz Job Trigger"</span>)</span><br><span class="line">                .startNow()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 다시 애플리케이션을 실행해보면 다음과 같이 분리된 별도의 jar 파일에서 작업 클래스를 로딩해서 실행하는 것을 확인할 수 있다.</p><p><img src="https://i.imgur.com/gF10uft.png" alt="Imgur"></p><p>스케줄러쪽에서 <code>io.homo_efficio.quartz.job.RemoteSimpleJob</code>와 같이 외부 jar에 있는 작업 클래스 위치를 문자열로 직접 참조하고 있어서 마치 스케줄러 모듈(quartz-scheduler)이 작업 모듈(quartz-job)에 의존하는 것처럼 보이지만, 실무에서는 작업 클래스 위치나 실행 주기 정보를 DB에서 읽어오므로 실제 환경에서는 <strong>스케줄러 모듈은 작업 클래스 모듈을 모른다. 따라서 이제부터는 <code>RemoteJob2</code>, <code>RemoteJob3</code> 등을 추가하더라도 <code>quartz-job.jar</code>만 빌드/배포하면 되며, 스케줄러는 재배포할 필요가 없는 구조가 만들어졌다.</strong></p><p>이렇게 해서 스케줄러와 작업 클래스를 분리하는데 성공했다. 어렵지 않다. </p><p>그런데 실무에서 사용하는 작업 클래스들이 <code>RemoteSimpleJob</code>처럼 단순할리는 없다. DB 작업도 있을 것이고 하둡 인프라와 관련한 작업도 있을 것이다. 이런 것들이 가능하려면 스케줄러 쪽에 있는 컴포넌트를 <code>@Autowire</code>로 주입 받아야 하는데, 지금처럼 런타임에 로딩되는 방식에서도 가능할까?</p><p>첫번째 고개만으로도 양이 제법되니 일단 여기서 1탄을 마무리하고 <code>@Autowire</code>는 <a href="https://homoefficio.github.io/2019/09/29/Quartz-스케줄러-적용-아키텍처-개선-2/">2탄</a>에서 다룬다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><ul><li><p>스케줄링을 담당하는 스케줄러와 실행되는 작업은 변경 주기가 다르다. 그런데 이를 한 곳에 모아 일체형으로 구성하면 운영이 매우 불편해진다.</p></li><li><p>Quartz는 스케줄러와 작업을 분리할 수 있도록 설계되어 있다.</p></li><li><p>작업 클래스를 별도의 jar로 묶고, 스케줄러 쪽에서 <code>URLClassLoader</code>를 사용해서 작업 클래스를 로딩하도록 개선하면 스케줄러와 작업 클래스의 배포를 분리할 수 있어 운영 부담을 대폭 줄일 수 있다.</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Quartz-스케줄러-적용-아키텍처-개선-1&quot;&gt;&lt;a href=&quot;#Quartz-스케줄러-적용-아키텍처-개선-1&quot; class=&quot;headerlink&quot; title=&quot;Quartz 스케줄러 적용 아키텍처 개선 - 1&quot;&gt;&lt;/a&gt;Quartz 스케줄러 
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Quartz" scheme="http://homoefficio.github.io/tags/Quartz/"/>
    
      <category term="Scheduler" scheme="http://homoefficio.github.io/tags/Scheduler/"/>
    
      <category term="Clean Architecture" scheme="http://homoefficio.github.io/tags/Clean-Architecture/"/>
    
      <category term="Interface Segregation Principle" scheme="http://homoefficio.github.io/tags/Interface-Segregation-Principle/"/>
    
      <category term="Dependency Inversion Principle" scheme="http://homoefficio.github.io/tags/Dependency-Inversion-Principle/"/>
    
      <category term="Isolation" scheme="http://homoefficio.github.io/tags/Isolation/"/>
    
      <category term="쿼츠" scheme="http://homoefficio.github.io/tags/%EC%BF%BC%EC%B8%A0/"/>
    
      <category term="스케줄러" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC/"/>
    
      <category term="클린 아키텍처" scheme="http://homoefficio.github.io/tags/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"/>
    
      <category term="인터페이스 분리 원칙" scheme="http://homoefficio.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99/"/>
    
      <category term="격리" scheme="http://homoefficio.github.io/tags/%EA%B2%A9%EB%A6%AC/"/>
    
      <category term="의존관계 역전 원칙" scheme="http://homoefficio.github.io/tags/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99/"/>
    
  </entry>
  
  <entry>
    <title>객체 지향 프로그래밍과 메시징</title>
    <link href="http://homoefficio.github.io/2019/07/04/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%A9%94%EC%8B%9C%EC%A7%95/"/>
    <id>http://homoefficio.github.io/2019/07/04/객체-지향-프로그래밍과-메시징/</id>
    <published>2019-07-03T15:14:58.000Z</published>
    <updated>2019-11-23T14:23:38.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="객체-지향-프로그래밍과-메시징"><a href="#객체-지향-프로그래밍과-메시징" class="headerlink" title="객체 지향 프로그래밍과 메시징"></a>객체 지향 프로그래밍과 메시징</h1><p>객체 지향 프로그래밍에서 메시징이란 무얼 말하는 걸까? 쉽게는 그냥 메서드 호출이라고 생각해도 될 것 같긴 하지만 그것만을 의미하는 것 같지는 않다. 그럼 도대체 뭘까?</p><h2 id="원조에게-배우자-앨런-케이"><a href="#원조에게-배우자-앨런-케이" class="headerlink" title="원조에게 배우자. 앨런 케이"></a>원조에게 배우자. 앨런 케이</h2><p><code>Object-Oriented</code>라는 말을 처음 사용한 것으로 알려진 사람은 앨런 케이다. <a href="http://www.purl.org/stefan_ram/pub/doc_kay_oop_en" target="_blank" rel="noopener">앨런 케이에게 OOP란?</a>을 보면 끝부분에 다음과 같은 글이 나온다.</p><blockquote><p>OOP to me means only messaging, local retention and protection and<br>hiding of state-process, and extreme late-binding of all things.</p></blockquote><p>우리말로는 대략 다음과 같이 옮길 수 있겠다.</p><blockquote><p>내게 OOP란 오직 다음 3가지를 의미한다.  </p><ul><li>메시지를 주고 받는 것  </li><li>상태 처리가 로컬 범위 내에서만 다뤄지도록 유지하고 상태 처리를 (외부로부터) 보호하고 숨기는 것  </li><li>모든 것에 대한 극단적인 late-binding (또는 모든 것이 가능한 가장 늦은 시점에 결정되는 것)</li></ul></blockquote><p>여기서 첫 번째 꼽는 messaging이 뭔지 잘 모르겠다. 그래서 더 찾아보니 ‘앨런 케이에게 OOP란?’에 이어 <a href="http://wiki.c2.com/?AlanKayOnMessaging" target="_blank" rel="noopener">앨런 케이에게 메시징이란?</a>도 있었다.</p><blockquote><p>The big idea is “messaging” - that is what the kernal of Smalltalk/Squeak<br>is all about (and it’s something that was never quite completed in our<br>Xerox PARC phase). The Japanese have a small word - ma - for “that which<br>is in between” - perhaps the nearest English equivalent is “interstitial”.<br>The key in making great and growable systems is much more to design how its<br>modules communicate rather than what their internal properties and<br>behaviors should be.</p></blockquote><p>대충 줄여서 의역하면 대략 다음과 같은 뜻이다.</p><blockquote><p>중요한 건 (object라기보다는) 메시징이었고, 모듈 내의 속성 및 동작보다 모듈 간의 의사소통을 잘 설계하는 것이 성장 가능한 훌륭한 시스템을 만드는 데 훨씬 더 중요하다.</p></blockquote><p>여기에서도 메시징이 중요하다는 건 알겠지만, 그래서 메시징이 정확하게 또는 구체적으로 뭘 의미하는지에 대한 얘기는 위 글 전체를 읽어봐도 안 나온다. 아니 안 나온다고 단정하긴 어렵고 내 수준에서는 안 보인다. </p><h2 id="작자-미상의-명언"><a href="#작자-미상의-명언" class="headerlink" title="작자 미상의 명언"></a>작자 미상의 명언</h2><p>객체 지향 프로그래밍의 의미는 아무래도 그 용어를 처음 쓴 앨런 케이가 한 말이 가장 정확하겠지만, 부분적이나마 가장 쉽게 이해할 수 있게 해준 말은 바로 이거다.</p><blockquote><p><strong>객체에게 데이터를 요구하지 말고 작업을 요청하라.</strong></p></blockquote><p>누가 한 얘기인지는 모르지만 나는 토비의 스프링에서 저 말을 처음 봤는데, 책을 봐도 내용을 거의 기억 못 하는 뇌를 가지고 있지만 저 말만은 잊히지 않았다. 저 말은 앨런 케이가 짚어준 3가지 중에서 1과 2를 포괄한다고 생각한다.</p><h2 id="거인의-어깨-위에서"><a href="#거인의-어깨-위에서" class="headerlink" title="거인의 어깨 위에서"></a>거인의 어깨 위에서</h2><p>그래서 위 3가지 글을 근거로 메시징에 대한 내 나름의 정의를 내려보면 다음과 같다.</p><blockquote><p><strong>메시징은 데이터를 요구하는 메서드 호출이 아니라 작업을 요청하는 메서드 호출을 의미한다.</strong></p></blockquote><p>이것마저도 조금 모호하게 느껴질 수 있으니 쉽게 풀어 써보자.</p><h3 id="대학-입시-원서-접수-사례"><a href="#대학-입시-원서-접수-사례" class="headerlink" title="대학 입시 원서 접수 사례"></a>대학 입시 원서 접수 사례</h3><p>대학 입시 원서 접수라는 상황을 생각해보자. 일반적으로는 지원자의 주민등록번호를 확인하지만, 주민등록번호가 없는 외국인 지원자는 비자 번호를 확인한다고 하자.</p><p>일반적인 내국인 지원자는 일반 전형을 통해 모집한다고 하고, 코드를 ‘A’라고 하자. 외국인 지원자는 외국인 전형을 통해 모집한다고 하고, 코드를 ‘F’라고 하자. 지원 정보는 <code>application</code>에 담겨있다고 하면, 대략 아래와 같은 코드가 나올 것 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 전형 타입이라는 데이터를 application 객체에게 요청하고,</span></span><br><span class="line">String admissionType = application.getAdmissionType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 외국인 전형 여부를 확인하고 비자번호를 확인하자.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"F"</span>.equals(admissionType))</span><br><span class="line">    verifyVisaNumber(application.getVisaNumber());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>이제 전형을 전기와 후기로 나누어 일 년에 두 번 접수를 받도록 정책이 바뀌었다. 따라서 외국인 전형도 전기 전형은 기존대로 ‘F’ 코드를 쓰고, 후기 전형은 ‘G’ 코드를 쓰게 되었다. 그럼 기존의 코드는 아래와 같이 변경되어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 전형 타입이라는 데이터를 application 객체에게 요청하고,</span></span><br><span class="line">String admissionType = application.getAdmissionType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 추가된 코드를 반영하기 위해 소스를 변경한다.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"F"</span>.equals(admissionType) </span><br><span class="line">    || <span class="string">"G"</span>.equals(admissionType))  <span class="comment">// 후기 전형 추가</span></span><br><span class="line">    verifyVisaNumber(application.getVisaNumber());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>이젠 전기, 후기 뿐아니라 수시 전형이 추가되었다. 외국인 수시 전형 코드는 ‘H’를 쓰게 되었다. 코드가 또 바뀌어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 전형 타입이라는 데이터를 application 객체에게 요청하고,</span></span><br><span class="line">String admissionType = application.getAdmissionType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 추가된 코드를 반영하기 위해 소스를 변경한다.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"F"</span>.equals(admissionType)</span><br><span class="line">    || <span class="string">"G"</span>.equals(admissionType)   <span class="comment">// 후기 전형 추가</span></span><br><span class="line">    || <span class="string">"H"</span>.equals(admissionType))  <span class="comment">//// 수시 전형 추가</span></span><br><span class="line">    verifyVisaNumber(application.getVisaNumber());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>요구사항이 변경될 때마다 기존 코드에도 변경이 필요하다. 이 정도의 변경이라면 그냥 해줄 수도 있다. 하지만, 외국인 전형 여부를 확인하는 코드가 위와 같이 단 한 군데만 존재할까? 그렇지 않다. 외국인 지원자는 본국의 비상연락처도 필요하고, 영어 성적이 면제될 수도 있는 등 외국인 전형 여부 확인 로직은 아마 꽤 여러군데 등장할 것이다. </p><p>그리고 자주 발생하지는 않겠지만 코드가 ‘F’, ‘G’, ‘H’가 아니라 ‘F1’, ‘F2’, ‘F0’ 이렇게 바뀐다면? 전기, 후기, 수시 전형에 또 조기 전형이 추가된다면? 변경은 아주 고달플 것이다. 그리고 변경이 아니더라도 ‘F’, ‘G’, ‘H’가 각각 어떤 전형을 의미하는지 이 코드만 봐서는 알 수 없어 불편하기도 하다.</p><p>이렇게 <code>application</code> 객체에게 <code>admissionType</code>이라는 <strong>데이터를 요구해서 처리하는 방식은 유지관리가 괴롭다</strong>는 단점이 있다. 그럼 작자 미상의 명언처럼 데이터를 요구하지 않고 작업을 요청하면 어떻게 달라질까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 기존 코드</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 전형 타입이라는 데이터를 application 객체에게 요청하고,</span></span><br><span class="line"><span class="comment">String admissionType = application.getAdmissionType();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 외국인 전형 여부를 확인한다.</span></span><br><span class="line"><span class="comment">if ("F".equals(admissionType))</span></span><br><span class="line"><span class="comment">    verifyVisaNumber(application.getVisaNumber());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// application 객체에게 </span></span><br><span class="line"><span class="comment">// 전형 타입이라는 데이터를 요구하지 말고,</span></span><br><span class="line"><span class="comment">// 외국인 전형 여부 확인이라는 작업을 요청하자.</span></span><br><span class="line"><span class="keyword">if</span> (application.isForeignAdmission())  <span class="comment">// &lt;-- 바로 이렇게</span></span><br><span class="line">    verifyVisaNumber(application.getVisaNumber());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>위 코드에서 <code>application.isForeignAdmission()</code>는 <strong>단순히 외국인 전형 코드라는 데이터를 받아오는 게 아니라 외국인 전형 여부 확인이라는 작업을 요청하고 있다.</strong> 그리고 <code>isForeignAdmission()</code>은 외국인 전형 여부 확인이라는 <strong>상태 처리를 로컬에서 수행하고 외부로부터 보호하고 숨기고 있다.</strong> </p><p>많이 들어본 얘기 아닌가? 바로 앨런 케이가 강조했던 3가지 중 2번 항목이다. 이렇게 작업을 요청하는 방식으로 바꾸고 나니 외국인 전형이 후기, 수시로 추가된다 하더라도 <code>isForeignAdmission()</code>의 <strong>내부 구현만 바뀔뿐 작업을 요청하는 <code>application.isForeignAdmission()</code> 이 코드는 바뀔 필요가 없다.</strong> <strong>따라서 내부 구현도 ‘F’, ‘G’, ‘H’ 같은 문자 코드 대신 <code>enum</code>을 쓰는 등 더 나은 로직으로 바꿀 수 있는 자유를 얻게 된다.</strong></p><p>이렇게 <strong>데이터를 요구하는 메서드 호출이 아니라 작업을 요청하는 메서드 호출이 바로 객체 지향이란 용어를 만든 앨런 케이가 가장 강조하고 싶었던 메시징</strong>이 아닐까?</p><hr><p>역시나 허접하게라도 써서 올려야 피드백을 통해 더 알게 된다. 토비님이 앨런 케이의 강연 영상 유튜브 링크를 알려주셨다.</p><p>(물론 여전히 틀릴 수도 있다는 전제하에) 결론부터 말하면 <strong>객체 지향 프로그래밍에서의 메시징은 그냥 일반 명사인 메시지 주고 받기라고 봐도 무방한 것 같다.</strong></p><p>전체적으로 3시간 가까운 분량인데, 이 글과 관련있는 부분은 <a href="https://youtu.be/QjJaFG63Hlo?t=3752" target="_blank" rel="noopener">https://youtu.be/QjJaFG63Hlo?t=3752</a> 여기서부터 보면 된다.</p><p>일단 앨런 케이는 나같은 외국인이 알아듣기에 쉬운 어투를 가진 사람은 아닌 것 같다 ㅠㅜ. 문장이나 말을 명료하게 딱딱 끊는 것도 아니고 발음도 살짝 뭉개는 부분도 많아서, 지금처럼 하나도 남김 없이 완벽하게 들으려고 하면 좌절스러울 뿐이다. 게다가 나는 스몰톡을 전혀 모르기 때문에 정확하게 해석한 것인지도 사실 자신 없다. </p><p>영상을 보면 <strong>메서드를 객체 내부에 존재하면서 외부의 메시지와 대응하는 것으로 설명</strong>하고 있는데, ‘대응하는(corresponding) 것’이라는 모호한 말을 ‘받은 메시지를 처리하는 데 필요한 것’이라고 구체적으로 해석한다고 해도, <strong>받은 메시지를 처리하는 데 메서드를 사용하는 것은 메시지를 받은 객체가 알아서 하는 것일 뿐, 메시징 자체를 메서드 호출과 직접 관련지을 필요조차 없는 걸로 보인다.</strong></p><p>그리고 메시지에 메서드가 아닌 단순한 데이터도 대응된다고 그림과 함께 설명하고 있으므로, <strong>단순히 데이터를 요구하는 것도 앨런 케이가 말하는 메시징에 해당된다</strong>는 점이다.</p><p>메시징을 메서드 호출이라고 볼 수도 없고, 단순히 데이터를 요구하는 것도 메시징에 해당된다면 메시징은 그냥 메시지 주고 받기라는 뜻 이상도 이하도 아니라는 생각이다.</p><p>이 결론이 틀렸다고 생각하는 분들은 위 링크를 클릭해서 직접 보시고 좋은 의견 나눠주시면 정말 감사하겠다.</p><p>이제 영상 주요 부분 후기를 남기면서 알고 보니 별 건더기 없는 주제가 돼버린 글을 마무리지어 버리자.</p><p>아 건진 것도 있다. <strong>원조인 앨런 케이가 말하는 메서드는 자바에서 말하는 메서드와는 다르다</strong>는 걸 알게 됐다. 그러니 <strong>객체 지향을 자바 버전으로 해석할 수는 있겠지만, 객체 지향을 자바 관점으로만 판단하려는 일은 경계해야 한다.</strong></p><p><img src="https://i.imgur.com/9tAlz01.png" alt="Imgur"></p><p>위 캡처는 앨런 케이가 객체 지향 프로그래밍을 설명하면서 그린 그림이다.</p><p>그린 순서대로 각 요소에 대한 설명을 짚어보면 다음과 같다.</p><ol><li>가장 먼저 방울 모양의 테두리를 그려서 내부와 외부를 분리(separate)했고,</li><li>테두리의 바깥쪽에 응답 대상인 메시지(message)를 그렸고,</li><li>테두리의 안쪽에 메시지와 직접 대응되는 메서드(method)를 그렸고,</li><li>테두리의 안쪽에 메시지와 직접 대응되는 데이터 구조를 작은 점으로 그렸고,</li><li>테두리의 안쪽에 메시지와 직접 대응되지는 않는 메서드를 그렸고,</li><li>마지막으로 (외부의) 프로토콜과 (내부의) 메서드를 분리(separate)했다.</li></ol><p>안타깝지만 여기에서도 메시지에 대한 직접적이고 명확한 설명은 나오지 않는다. 아니 들리지 않았다. <code>messages that we are willing to respond to</code>라며 ‘응답 대상이 되는’이라는 수식어를 붙일 뿐이고, <code>in effect, some of the messages that the object might be able to receive aren&#39;t directly characterized in terms of some outside protocols</code>라며 ‘메시지가 외부의 프로토콜에 의해 특징지어지는 것은 아니다’라는 애매한 부연 설명이 있을 뿐이다.</p><p>영상을 보기 전에는 객체 지향은 데이터를 요구하는 대신 작업을 요청하는 것이 중요하고, 앨런 케이가 메시징을 그토록 강조한 것과 연결지으면 메시징은 작업을 요청하는 메서드 호출일 것이라고 결론지었다. 그런데 앨런 케이는 위 그림을 설명하면서 메시지는 객체 내부의 데이터에 대응되기도 한다고 분명히 말하고 있다.</p><p>결국 메시징이 특히 강조되긴 했지만 앨런 케이의 글이나 강연에서 메시징 자체에 대한 구체적인 설명을 찾기 어려웠던 이유는, 메시징이 그냥 일반 명사의 의미라서 별도의 설명이 필요하지 않기 때문인 것 같다.</p><p><strong>메시징 자체의 의미가 중요한 것이 아니라, 내/외부를 분리하고 분리된 객체끼리 상대방의 내부는 모르는 채로 의사소통해야 복잡성을 낮출 수 있다는 점에서 메시징을 강조한 것 같다.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;객체-지향-프로그래밍과-메시징&quot;&gt;&lt;a href=&quot;#객체-지향-프로그래밍과-메시징&quot; class=&quot;headerlink&quot; title=&quot;객체 지향 프로그래밍과 메시징&quot;&gt;&lt;/a&gt;객체 지향 프로그래밍과 메시징&lt;/h1&gt;&lt;p&gt;객체 지향 프로그래밍에서 
      
    
    </summary>
    
      <category term="Concepts" scheme="http://homoefficio.github.io/categories/Concepts/"/>
    
    
      <category term="Object Oriented Programming" scheme="http://homoefficio.github.io/tags/Object-Oriented-Programming/"/>
    
      <category term="OOP" scheme="http://homoefficio.github.io/tags/OOP/"/>
    
      <category term="Object Oriented" scheme="http://homoefficio.github.io/tags/Object-Oriented/"/>
    
      <category term="Messaging" scheme="http://homoefficio.github.io/tags/Messaging/"/>
    
      <category term="Allen Kay" scheme="http://homoefficio.github.io/tags/Allen-Kay/"/>
    
      <category term="객체 지향 프로그래밍" scheme="http://homoefficio.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="객체 지향" scheme="http://homoefficio.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5/"/>
    
      <category term="메시징" scheme="http://homoefficio.github.io/tags/%EB%A9%94%EC%8B%9C%EC%A7%95/"/>
    
      <category term="앨런 케이" scheme="http://homoefficio.github.io/tags/%EC%95%A8%EB%9F%B0-%EC%BC%80%EC%9D%B4/"/>
    
  </entry>
  
  <entry>
    <title>재미로 보는 언어별 스트림 처리 비교</title>
    <link href="http://homoefficio.github.io/2019/05/08/%EC%9E%AC%EB%AF%B8%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EC%96%B8%EC%96%B4%EB%B3%84-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%B2%98%EB%A6%AC-%EB%B9%84%EA%B5%90/"/>
    <id>http://homoefficio.github.io/2019/05/08/재미로-보는-언어별-스트림-처리-비교/</id>
    <published>2019-05-08T13:32:35.000Z</published>
    <updated>2019-05-09T11:30:32.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="재미로-보는-언어별-스트림-처리-비교"><a href="#재미로-보는-언어별-스트림-처리-비교" class="headerlink" title="재미로 보는 언어별 스트림 처리 비교"></a>재미로 보는 언어별 스트림 처리 비교</h1><p>NBA를 즐겨보는데 갑자기 역대 MVP가 궁금해서 찾아보니 <a href="https://www.nba.com/history/awards/mvp" target="_blank" rel="noopener">https://www.nba.com/history/awards/mvp</a> 여기에서 볼 수 있었다. 연도별로 주욱 나열되어 있는데 <strong>수상횟수 기준으로 집계해서 내림차순</strong>으로 보고 싶었다.</p><p>그래서 연습도 할 겸 자바로 먼저 짜봤는데 다른 언어로 짜주신 분들도 계셔서 <strong>재미로 비교</strong>를 해보려 한다. 언어의 전반적인 우열을 가리는 목적이 전혀 아니므로 구경하는 재미로만 참고하면 좋겠다.</p><p>자바 외에 다른 언어에 대한 지식이 많지 않으므로 잘못된 정보가 포함될 수도 있으며 이 부분은 댓글로 바로잡아주시면 정말 감사드리며 바로 반영하겠다.</p><p>자 이제 시작해보자. 연도별 NBA MVP 명단 데이터는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">String MVPS = <span class="string">""</span> +</span><br><span class="line">            <span class="string">"2017-18     James Harden, Houston Rockets (Voting)\n"</span> +</span><br><span class="line">            <span class="string">"2016-17     Russell Westbrook, Oklahoma City Thunder (Voting)\n"</span> +</span><br><span class="line">            <span class="string">"2015-16     Stephen Curry, Golden State Warriors (Voting)\n"</span> +</span><br><span class="line">            <span class="string">"2014-15     Stephen Curry, Golden State Warriors\n"</span> +</span><br><span class="line">            <span class="string">"2013-14     Kevin Durant, Oklahoma City Thunder\n"</span> +</span><br><span class="line">            <span class="string">"2012-13     LeBron James, Miami Heat\n"</span> +</span><br><span class="line">            <span class="string">"2011-12     LeBron James, Miami Heat\n"</span> +</span><br><span class="line">            <span class="string">"2010-11     Derrick Rose, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"2009-10     LeBron James, Cleveland Cavaliers\n"</span> +</span><br><span class="line">            <span class="string">"2008-09     LeBron James, Cleveland Cavaliers\n"</span> +</span><br><span class="line">            <span class="string">"2007-08     Kobe Bryant, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"2006-07     Dirk Nowitzki, Dallas Mavericks\n"</span> +</span><br><span class="line">            <span class="string">"2005-06     Steve Nash, Phoenix Suns\n"</span> +</span><br><span class="line">            <span class="string">"2004-05     Steve Nash, Phoenix Suns\n"</span> +</span><br><span class="line">            <span class="string">"2003-04     Kevin Garnett, Minnesota Timberwolves\n"</span> +</span><br><span class="line">            <span class="string">"2002-03     Tim Duncan, San Antonio Spurs\n"</span> +</span><br><span class="line">            <span class="string">"2001-02     Tim Duncan, San Antonio Spurs\n"</span> +</span><br><span class="line">            <span class="string">"2000-01     Allen Iverson, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1999-00     Shaquille O'Neal, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1998-99     Karl Malone, Utah Jazz\n"</span> +</span><br><span class="line">            <span class="string">"1997-98     Michael Jordan, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"1996-97     Karl Malone, Utah Jazz\n"</span> +</span><br><span class="line">            <span class="string">"1995-96     Michael Jordan, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"1994-95     David Robinson, San Antonio Spurs\n"</span> +</span><br><span class="line">            <span class="string">"1993-94     Hakeem Olajuwon, Houston Rockets\n"</span> +</span><br><span class="line">            <span class="string">"1992-93     Charles Barkley, Phoenix Suns\n"</span> +</span><br><span class="line">            <span class="string">"1991-92     Michael Jordan, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"1990-91     Michael Jordan, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"1989-90     Magic Johnson, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1988-89     Magic Johnson, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1987-88     Michael Jordan, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"1986-87     Magic Johnson, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1985-86     Larry Bird, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1984-85     Larry Bird, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1983-84     Larry Bird, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1982-83     Moses Malone, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1981-82     Moses Malone, Houston Rockets\n"</span> +</span><br><span class="line">            <span class="string">"1980-81     Julius Erving, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1979-80     Kareem Abdul-Jabbar, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1978-79     Moses Malone, Houston Rockets\n"</span> +</span><br><span class="line">            <span class="string">"1977-78     Bill Walton, Portland Trail Blazers\n"</span> +</span><br><span class="line">            <span class="string">"1976-77     Kareem Abdul-Jabbar, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1975-76     Kareem Abdul-Jabbar, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1974-75     Bob McAdoo, Buffalo Braves\n"</span> +</span><br><span class="line">            <span class="string">"1973-74     Kareem Abdul-Jabbar, Milwaukee Bucks\n"</span> +</span><br><span class="line">            <span class="string">"1972-73     Dave Cowens, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1971-72     Kareem Abdul-Jabbar, Milwaukee Bucks\n"</span> +</span><br><span class="line">            <span class="string">"1970-71     Kareem Abdul-Jabbar, Milwaukee Bucks\n"</span> +</span><br><span class="line">            <span class="string">"1969-70     Willis Reed, New York Knicks\n"</span> +</span><br><span class="line">            <span class="string">"1968-69     Wes Unseld, Baltimore Bullets\n"</span> +</span><br><span class="line">            <span class="string">"1967-68     Wilt Chamberlain, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1966-67     Wilt Chamberlain, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1965-66     Wilt Chamberlain, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1964-65     Bill Russell, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1963-64     Oscar Robertson, Cincinnati Royals\n"</span> +</span><br><span class="line">            <span class="string">"1962-63     Bill Russell, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1961-62     Bill Russell, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1960-61     Bill Russell, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1959-60     Wilt Chamberlain, Philadelphia Warriors\n"</span> +</span><br><span class="line">            <span class="string">"1958-59     Bob Pettit, St. Louis Hawks\n"</span> +</span><br><span class="line">            <span class="string">"1957-58     Bill Russell, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1956-57     Bob Cousy, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1955-56     Bob Pettit, St. Louis Hawks"</span>;</span><br></pre></td></tr></table></figure><h1 id="구현-비교"><a href="#구현-비교" class="headerlink" title="구현 비교"></a>구현 비교</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Java 8의 Stream API를 활용해서 작성한 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String[] lines = MVPS.split(<span class="string">"\\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> mvpCount = Stream.of(lines)</span><br><span class="line">            .collect(groupingBy(line -&gt; line.substring(<span class="number">12</span>, line.indexOf(<span class="string">','</span>)), counting()))</span><br><span class="line">            .entrySet().stream()</span><br><span class="line">            .sorted(comparingByValue(reverseOrder()))</span><br><span class="line">            .peek(e -&gt; out.println(e.getKey() + <span class="string">": "</span> + e.getValue()))</span><br><span class="line">            .mapToLong(Map.Entry::getValue)</span><br><span class="line">            .sum();</span><br><span class="line"></span><br><span class="line">    out.println(lines.length == mvpCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>큰 흐름은 <code>키(선수 이름) 추출</code>, <code>groupBy</code>, <code>수상횟수 집계</code>, <code>정렬</code>, <code>출력</code>, <code>전체 합계</code>로 구성된다.</p><p><strong>자바에는 튜플이 없다.</strong> 그래서 <code>groupingBy()</code>의 결과는 Map으로 collect되고 이 과정에서 최초의 스트림이 종결된다. 그리고 Map에서 <code>entrySet().stream()</code>을 통해 새 스트림을 만들고 정렬, 출력, 합계 등을 처리해야 한다. 따라서 <code>수상횟수 집계</code>와 <code>정렬</code> 사이에 스트림 생성이 하나 추가된다고 볼 수 있다.</p><p>값(MVP 수상횟수) 기준 내림차순 정렬은 <code>.sorted(comparingByValue(reverseOrder()))</code>로 깔끔하게 처리할 수는 있지만 조금 장황해보이기도 하다. 앞으로 살펴볼 다른 언어 구현체와 비교하면 실제로도 좀 길긴 하다.</p><p><code>peek()</code>이 있어서 스트림의 데이터를 완전 소비(consume)하지 않으면서도 출력할 수 있어서, 출력과 합계를 하나의 스트림으로 처리할 수 있다.</p><blockquote><p>한 줄 평: Stream API 덕에 깔끔한 구조로 작성할 수 있음에도 불구하고 메서드 이름이 길어서 전반적으로 장황해보인다.</p></blockquote><h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><p>스칼라 버전은 <strong>Kevin Lee 님</strong>께서 작성해주신 걸 살짝 다듬었다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lines = <span class="type">MVPS</span>.split(<span class="string">"\n"</span>)</span><br><span class="line"><span class="keyword">val</span> mvpList = lines</span><br><span class="line">  .groupBy(_.drop(<span class="number">12</span>).takeWhile(_ != ','))  </span><br><span class="line">  .mapValues(_.size)</span><br><span class="line">  .toList</span><br><span class="line">  .sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Int</span>.reverse)</span><br><span class="line"></span><br><span class="line">println(mvpList.map &#123; <span class="keyword">case</span> (name, count) =&gt; <span class="string">s"<span class="subst">$name</span>: <span class="subst">$count</span>"</span> &#125;.mkString(<span class="string">"\n"</span>))</span><br><span class="line">println(lines.size == mvpList.map(_._2).sum)</span><br></pre></td></tr></table></figure><p>스칼라에서도 큰 흐름은 <code>키(선수 이름) 추출</code>, <code>groupBy</code>, <code>수상횟수 집계</code>, <code>정렬</code>, <code>출력</code>, <code>전체 합계</code>로 달라진 것은 없다. </p><p>키 추출이 자바와 조금 다르게 구현되었지만 장황한 점은 비슷해 보이고, 자바의 <code>groupingBy()</code>에서 키 별 분류와 수상횟수 집계를 함께 처리할 수 있었지만, 스칼라의 <code>groupBy()</code>는 키 별 분류만 가능하고 수상횟수의 집계는 <code>mapValues(_.size)</code>를 통해 따로 처리하는 점이 다르다.</p><p>정렬하기 전에 리스트로 만드는 과정(<code>toList</code>)이 하나 추가되는 것도 절차상으로는 <code>entrySet().stream()</code>으로 스트림을 새로 만드는 자바와 비슷하고, 정렬 과정도 자바와 비슷하다. </p><p><strong><code>(_.drop(12))</code>, <code>(_.size)</code>, <code>(_._2)</code> 같은 표현법으로 <code>-&gt;</code> 없이도 람다식을 표현할 수 있고, <code>getKey()</code>, <code>getValue()</code> 대신 <code>._1</code>, <code>._2</code>로 짧게 표현할 수 있어서 비슷한 구조임에도 자바보다 훨씬 간결해보인다.</strong> 하지만 <code>_</code>를 쓰지 않는다면 <code>map { case (name, count) =&gt; ... }</code>에서처럼 <code>=&gt;</code>뿐 아니라 <code>case</code>도 나오면서 조금 복잡해진다.</p><p>자바의 <code>peek()</code> 같은 메서드가 없어서인지 출력과 전체 합계를 하나의 스트림으로 처리하지 못하고 별도로 처리하는 것도 다르다.</p><blockquote><p>한 줄 평: <code>_</code>를 잘 쓰면 자바보다 훨씬 간결하게 짤 수 있다.</p></blockquote><h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><p>코틀린 버전은 <strong>부종민 님</strong>께서 짜주신 걸 살짝 개선해봤다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lines = MVPS.split(<span class="string">"\n"</span>)</span><br><span class="line">    <span class="keyword">val</span> totalCount = lines</span><br><span class="line">        .groupingBy &#123; it.substring(<span class="number">12</span>, it.indexOf(<span class="string">','</span>)) &#125;</span><br><span class="line">        .eachCount()</span><br><span class="line">        .toList()</span><br><span class="line">        .sortedByDescending &#123; it.second &#125;</span><br><span class="line">        .onEach &#123; println(it) &#125;</span><br><span class="line">        .map &#123; it.second &#125;</span><br><span class="line">        .sum()</span><br><span class="line"></span><br><span class="line">    println(lines.size == totalCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린은 흐름이 스칼라와 거의 동일하다.</p><p><code>substring()</code>은 자바와 동일하고 원한다면 스칼라처럼 <code>drop()</code>, <code>takeWhile()</code>을 쓸 수도 있다.</p><p><code>groupingBy {}</code> 에서는 스칼라와 마찬가지로 키 기준 분류만 가능하고 집계는 <code>eachCount()</code>로 따로 해줘야 한다. 정렬하기 전에 <code>toList()</code>로 리스트를 만드는 것도 동일하다. </p><p>스칼라에 튜플이 있다면 <strong>코틀린에는 <code>Pair</code>가 있다. 그래서 자바처럼 <code>getKey()</code>, <code>getValue()</code> 같은 메서드를 쓰지 않고 <code>it.first</code>, <code>it.second</code>와 같은 형식으로 짧게 표현 가능하다.</strong> 그래도 <code>first</code>나 <code>second</code>보다는 <code>_1</code>, <code>_2</code>처럼 더 짧게 표현 가능한 스칼라 쪽이 더 나아 보인다.</p><p>람다식을 <code>{ }</code>를 써서 인자로 받는 것에서 약간의 이질감이 느껴지지만, <strong><code>it</code>라는 built-in 키워드를 써서 <code>-&gt;</code> 없이도 람다식을 짧게 표현할 수 있는 점</strong>도 스칼라와 비슷하다.</p><p>자바의 <code>peek()</code>과 동일한 역할을 하는 <code>onEach()</code>가 있어서 출력과 전체 합계를 하나의 스트림에서 모두 처리할 수 있다는 점은 스칼라와 다르다.</p><blockquote><p>한 줄 평: 스칼라와 거의 비슷한 작성 방식과 간결함을 보여주면서도, 스칼라에 없는 <code>onEach()</code>를 가지고 있어서 자바의 장점도 가지고 있다.</p></blockquote><h2 id="뽕-맞은-자바-feat-jooL"><a href="#뽕-맞은-자바-feat-jooL" class="headerlink" title="뽕 맞은 자바(feat. jooL)"></a>뽕 맞은 자바(feat. jooL)</h2><p><strong>박성철 님</strong>께서 바닐라 자바는 쓰는 게 아니라고 하시면서 <code>jooL 라이브러리</code>(<a href="https://github.com/jOOQ/jOOL" target="_blank" rel="noopener">https://github.com/jOOQ/jOOL</a>) 를 사용해서 작성해주신 버전을 보면 ‘오~~ 이게 정녕 자바란 말씀입니까?’란 소리가 나올 정도로 감동적이다. 스칼라나 코틀린보다 더 간결하다!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String[] lines = MVPS.split(<span class="string">"\\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> mvpCount = Seq.of(lines)</span><br><span class="line">            .grouped(line -&gt; line.substring(<span class="number">12</span>, line.indexOf(<span class="string">','</span>)), counting()))</span><br><span class="line">            .sorted(t -&gt; - t.v2)</span><br><span class="line">            .peek(t -&gt; out.println(t.v1 + <span class="string">": "</span> + t.v2))</span><br><span class="line">            .sumLong(t -&gt; t.v2);</span><br><span class="line"></span><br><span class="line">    out.println(lines.length == mvpCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스칼라나 코틀린처럼 <strong>튜플이 있어서 <code>t.v2</code>같은 간략한 표현이 가능</strong>해졌고, 특히 <strong>값 기준 내림차순 정렬을 <code>sorted(t -&gt; - t.v2)</code>로 간단 명료하게 표현할 수 있는 점이 눈에 띈다.</strong> 그리고 groupBy 후에 <code>entrySet().stream()</code>이나 <code>toList</code> 없이도 클로저처럼 바로 정렬할 수 있다.</p><blockquote><p>한 줄 평: 바닐라 자바는 쓰는 게 아니다.</p></blockquote><h2 id="Clojure"><a href="#Clojure" class="headerlink" title="Clojure"></a>Clojure</h2><p>클로저는 버전이 두 개인데 <code>-&gt;&gt;</code> 매크로를 사용한 버전은 <strong>박상규 님</strong>께서 만들어주셨다.</p><p><strong>짧을 줄은 알았지만 생각보다 더 짧다..</strong></p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">run!</span> prn </span><br><span class="line">    (<span class="name"><span class="builtin-name">sort-by</span></span> val &gt; </span><br><span class="line">        (<span class="name">frequencies</span> (<span class="name"><span class="builtin-name">map</span></span> #(<span class="name">subs</span> % <span class="number">12</span> (<span class="name">index-of</span> % <span class="string">","</span>)) lines))))</span><br></pre></td></tr></table></figure><p>클로저는 앞에서 다룬 언어와는 좀 다르게 Lisp 계열의 언어이며, 함수의 chaining이 아니라 nesting을 사용하므로 <strong>코드의 흐름이 의식의 흐름에 역행하는 것으로 보여서 이질감이 매우 크다.</strong> 하지만 이를 보완할 수 있는 방법이 있으니 바로 <strong><code>-&gt;&gt;</code> 매크로</strong>다.</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">-&gt;&gt;</span></span> lines</span><br><span class="line">  (<span class="name"><span class="builtin-name">map</span></span> #(<span class="name">subs</span> % <span class="number">12</span> (<span class="name">index-of</span> % <span class="string">","</span>)))</span><br><span class="line">  frequencies </span><br><span class="line">  (<span class="name"><span class="builtin-name">sort-by</span></span> val &gt;)</span><br><span class="line">  (<span class="name">run!</span> prn))</span><br></pre></td></tr></table></figure><p>이렇게 <strong><code>-&gt;&gt;</code> 매크로를 사용하면 클로저 특유의 간결함을 유지하면서도 의식의 흐름과 코드 흐름의 불일치를 극복할 수도 있다.</strong></p><p><code>map</code>은 다른 언어와 다를 게 없다. <code>#()</code>를 써서 익명 함수를 만들 수 있고, <code>%</code>로 익명 함수의 인자를 표현할 수 있는데 <code>%1</code>, <code>%2</code>와 같이 두 개 이상의 인자도 표현 가능하다.</p><p><code>frequencies</code><br><code>groupingBy(key, counting())</code><br><code>groupBy(key).mapValues(_.size)</code><br><code>groupingBy { key }.eachCount()</code></p><p>위 네 가지는 모두 동일한 역할을 담당하는데, 코드의 양으로 보나 의미 전달력으로 보나 클로저의 <code>frequencies</code>에 가장 높은 점수를 줄 수 있겠다.</p><p>코드에 나타나지 않은 가장 큰 차이점이 하나 있다. 자바, 스칼라, 코틀린에서는 groupBy를 한 후 다시 리스트로 만들어줘야 정렬을 할 수가 있는데, 클로저에서는 <code>frequencies</code>가 반환하는 <strong>맵 자체를 대상으로 값 기준 정렬이 가능하다.</strong></p><p><code>sort-by val &gt;</code><br><code>sorted(comparingByValue(reverseOrder()))</code><br><code>sortBy(_._2)(Ordering.Int.reverse)</code><br><code>sortedByDescending { it.second }</code></p><p>위 네 가지도 모두 동일한 역할을 하는데, 이번에도 클로저의 <code>sort-by val &gt;</code>에 가장 높은 점수를 줄 수 있겠다. <strong>값(val) 기준 내림차순(&gt;)으로 정렬하라(sort-by)는 의미를 <code>sort-by val &gt;</code>로 정말 간단 명료하게 표현</strong>하고 있다.</p><p>다만 클로저도 스칼라와 마찬가지로 자바의 <code>peek()</code>이나 코틀린의 <code>onEach()</code> 같은 기능의 함수가 없어서 출력과 합계를 하나의 스트림에서 처리하지 못하는 것은 단점이다. 스칼라처럼 Lazy Sequence를 변수에 담아두고 출력에 사용하고, 합계 계산에 사용하면 될텐데 그 부분은 아예 작성을 못 했다. ㅋㅋ</p><blockquote><p>한 줄 평: 간결함으로는 타의 추종을 불허하지만, Lisp에 익숙해지기는 쉽지 않다.</p></blockquote><h2 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h2><p>스택오버플로우 기준 올해까지 4년 연속 가장 사랑받는 언어 러스트도 한 번 시도해봤다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mvps_count = MVPS.lines()</span><br><span class="line">        .map(|line| &amp;line[<span class="number">12</span>..line.find(<span class="string">','</span>).unwrap_or(line.len())])</span><br><span class="line">        .into_iter()</span><br><span class="line">        .sorted()</span><br><span class="line">        .group_by(|name| *name)</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|(key, group)| (key, group.count()))</span><br><span class="line">        .sorted_by(|a, b| (b.<span class="number">1</span>).cmp(&amp;a.<span class="number">1</span>))</span><br><span class="line">        .inspect(|(key, count)| <span class="built_in">println!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, key, count))</span><br><span class="line">        .map(|(_key, count)| count)</span><br><span class="line">        .fold(<span class="number">0</span> <span class="keyword">as</span> <span class="built_in">usize</span>, |a, b| a + b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, MVPS.lines().count() == mvps_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>러스트는.. 자세한 설명은 생략.. 하고 싶지만..</p><p>다른 언어와 가장 크게 다른 점은 <strong><code>group_by</code>전에 반드시 <code>sorted()</code>를 해줘야 제대로 키 기준 분류가 작동</strong>한다는 점이다. 예를 들어 <code>[a, a, b, a, c, a]</code>에 <code>group_by</code>와 <code>map</code>으로 키 별 분류와 집계를 적용하면 <code>[(a, 4), (b, 1), (c, 1)]</code>이 나올 것이 예상되고 다른 언어는 모두 예상대로 동작하지만, 러스트는 <code>[(a, 2), (b, 1), (a, 1), (c, 1), (a, 1)]</code>라는 결과를 반환한다. 따라서 키 기준으로 먼저 정렬을 해줘야 예상대로 동작하게 된다.</p><p>자바의 <code>peek()</code>, 코틀린의 <code>onEach()</code>처럼 러스트에도 <code>inspect()</code>가 있어서 출력과 전체 합계를 하나의 스트림에서 처리할 수 있다.</p><blockquote><p>한 줄 평: 러스트는 사랑스러울지언정 어렵고 어지럽다.</p></blockquote><h1 id="문서-비교"><a href="#문서-비교" class="headerlink" title="문서 비교"></a>문서 비교</h1><p>사실 다른 언어는 잘 모르는 채로 시도해봤던 거라 검색과 문서에 크게 의존할 수 밖에 없었다. 개인 취향에 따라 모두 다를테지만, 이왕 비교한 거 구현 말고 문서도 구경하기 수준으로 비교해보자. 그래도 공정한 비교를 위해 <code>groupBy</code>를 설명하는 문서로 비교한다.</p><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><p><img src="https://i.imgur.com/NyfU0Gq.png" alt="Imgur"></p><p>무시무시한 저 메서드 시그너처로 시작해서 구구절절 설명을 이어간다. 그래도 이 <code>groupingBy</code>는 고맙게도 실제 사용 예제를 하나 던져주셨는데 모든 메서드에 대해 이런 예제가 제공되는 것은 아니다. 그래서 예제가 풍부하게 제공되는 <a href="http://www.baeldung.com" target="_blank" rel="noopener">www.baeldung.com</a> 같은 사이트를 많이 참고하게 된다.</p><h2 id="Scala-1"><a href="#Scala-1" class="headerlink" title="Scala"></a>Scala</h2><p><img src="https://i.imgur.com/iBoGbKT.png" alt="Imgur"></p><p>스칼라는 문서도 간결하다. 너무 간결해서 예제도 없다..</p><h2 id="Kotlin-1"><a href="#Kotlin-1" class="headerlink" title="Kotlin"></a>Kotlin</h2><p><img src="https://i.imgur.com/WVi56uS.png" alt="Imgur"></p><p>코틀린은 <strong>예제를 단순한 텍스트가 아니라 실행 가능한 환경과 함께 제공</strong>한다!! 그래서 요리조리 직접 바꿔가며 실행 결과를 바로 확인해 볼 수 있다!! 이런 참신함에는 높은 점수를 주고 싶다. 그런데 예제가 풍부하지는 않다.</p><p>위에 작성한 코드에는 <code>groupBy</code>가 키 분류만 가능하게 되어 있는데 문서를 보니 키 분류뿐 아니라 항목 집계도 가능한 걸로 보인다. 하지만 관련 예제가 없어서 어떻게 하면 원하는 대로 바꿀 수 있을지 바로 알 수는 없었다.</p><h2 id="Clojure-1"><a href="#Clojure-1" class="headerlink" title="Clojure"></a>Clojure</h2><p><img src="https://i.imgur.com/VWlC5NZ.png" alt="Imgur"></p><p>클로저는 문서도 가장 간결하다. </p><p>그런데 그보다 더 중요한 것은 <strong>다른 언어 문서들과 달리 공식 문서가 오픈 방식</strong>이라는 것이다. 로그인만 하면 사용자가 직접 다양한 예제를 추가할 수 있게 되어 있을뿐 아니라 화면에는 안 나왔지만 질의 응답도 가능하게 완전히 열려있다. </p><p>덕분에 클로저를 거의 모르는 나같은 문외한도 MVP 수상횟수 집계 예제 정도는 클로저 문서 사이트만으로도 그럭저럭 짤 수 있었다. 실용성 면에서는 가장 높은 점수를 줄 만하다.</p><h2 id="Rust-1"><a href="#Rust-1" class="headerlink" title="Rust"></a>Rust</h2><p><img src="https://i.imgur.com/W1rg6ZV.png" alt="Imgur"></p><p>일단 위 예제에서 사용한 <code>group_by</code>는 러스트 자체에 포함된 것은 아니고, <code>itertools</code>라는 크레이트(crate, 그냥 라이브러리 라고 이해해도 크게 틀리지 않음)에서 제공하는 것인데, 문서의 포맷은 러스트의 공식 문서 사이트와 동일하다.</p><p>적절한 설명과 함께 예제가 제공된다. 예제에 주석으로 고마운 설명이 달려있긴 하지만 클로저처럼 오픈 방식이 아니라서 예제가 다양하지는 않다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;재미로-보는-언어별-스트림-처리-비교&quot;&gt;&lt;a href=&quot;#재미로-보는-언어별-스트림-처리-비교&quot; class=&quot;headerlink&quot; title=&quot;재미로 보는 언어별 스트림 처리 비교&quot;&gt;&lt;/a&gt;재미로 보는 언어별 스트림 처리 비교&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Language" scheme="http://homoefficio.github.io/categories/Language/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Stream" scheme="http://homoefficio.github.io/tags/Stream/"/>
    
      <category term="스트림" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"/>
    
      <category term="Scala" scheme="http://homoefficio.github.io/tags/Scala/"/>
    
      <category term="Kotlin" scheme="http://homoefficio.github.io/tags/Kotlin/"/>
    
      <category term="Clojure" scheme="http://homoefficio.github.io/tags/Clojure/"/>
    
      <category term="Rust" scheme="http://homoefficio.github.io/tags/Rust/"/>
    
      <category term="groupBy" scheme="http://homoefficio.github.io/tags/groupBy/"/>
    
      <category term="groupingBy" scheme="http://homoefficio.github.io/tags/groupingBy/"/>
    
      <category term="sort by value" scheme="http://homoefficio.github.io/tags/sort-by-value/"/>
    
      <category term="map" scheme="http://homoefficio.github.io/tags/map/"/>
    
      <category term="reduce" scheme="http://homoefficio.github.io/tags/reduce/"/>
    
      <category term="fold" scheme="http://homoefficio.github.io/tags/fold/"/>
    
      <category term="peek" scheme="http://homoefficio.github.io/tags/peek/"/>
    
      <category term="onEach" scheme="http://homoefficio.github.io/tags/onEach/"/>
    
      <category term="inspect" scheme="http://homoefficio.github.io/tags/inspect/"/>
    
      <category term="Tuple" scheme="http://homoefficio.github.io/tags/Tuple/"/>
    
      <category term="Pair" scheme="http://homoefficio.github.io/tags/Pair/"/>
    
      <category term="it" scheme="http://homoefficio.github.io/tags/it/"/>
    
      <category term="_" scheme="http://homoefficio.github.io/tags//"/>
    
      <category term="jooL" scheme="http://homoefficio.github.io/tags/jooL/"/>
    
      <category term="reference doc" scheme="http://homoefficio.github.io/tags/reference-doc/"/>
    
      <category term="스칼라" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%EC%B9%BC%EB%9D%BC/"/>
    
      <category term="코틀린" scheme="http://homoefficio.github.io/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/"/>
    
      <category term="클로저" scheme="http://homoefficio.github.io/tags/%ED%81%B4%EB%A1%9C%EC%A0%80/"/>
    
      <category term="러스트" scheme="http://homoefficio.github.io/tags/%EB%9F%AC%EC%8A%A4%ED%8A%B8/"/>
    
      <category term="변환" scheme="http://homoefficio.github.io/tags/%EB%B3%80%ED%99%98/"/>
    
      <category term="집계" scheme="http://homoefficio.github.io/tags/%EC%A7%91%EA%B3%84/"/>
    
      <category term="튜플" scheme="http://homoefficio.github.io/tags/%ED%8A%9C%ED%94%8C/"/>
    
      <category term="페어" scheme="http://homoefficio.github.io/tags/%ED%8E%98%EC%96%B4/"/>
    
      <category term="값으로 정렬" scheme="http://homoefficio.github.io/tags/%EA%B0%92%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A0%AC/"/>
    
      <category term="값 기준 정렬" scheme="http://homoefficio.github.io/tags/%EA%B0%92-%EA%B8%B0%EC%A4%80-%EC%A0%95%EB%A0%AC/"/>
    
  </entry>
  
  <entry>
    <title>JPA 일대다 단방향 매핑 잘못 사용하면 벌어지는 일</title>
    <link href="http://homoefficio.github.io/2019/04/28/JPA-%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A8%EB%B0%A9%ED%96%A5-%EB%A7%A4%ED%95%91-%EC%9E%98%EB%AA%BB-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EB%B2%8C%EC%96%B4%EC%A7%80%EB%8A%94-%EC%9D%BC/"/>
    <id>http://homoefficio.github.io/2019/04/28/JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일/</id>
    <published>2019-04-28T01:30:35.000Z</published>
    <updated>2019-05-09T13:03:14.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일"><a href="#JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일" class="headerlink" title="JPA 일대다 단방향 매핑 잘못 사용하면 벌어지는 일"></a>JPA 일대다 단방향 매핑 잘못 사용하면 벌어지는 일</h1><p><code>Parent : Child = 1 : N</code> 의 관계가 있으면 일대다 단방향으로 매핑하는 것보다 일대다 양방향으로 매핑하는 것이 좋다. 왜 그런지 구체적으로 살펴보자.</p><h1 id="조인테이블-방식의-일대다-단방향-매핑"><a href="#조인테이블-방식의-일대다-단방향-매핑" class="headerlink" title="조인테이블 방식의 일대다 단방향 매핑"></a>조인테이블 방식의 일대다 단방향 매핑</h1><p>그런데 어떤 특별한 이유가 있을 수도 있고, 그냥 별 생각없이 작성된 레거시 일 수도 있고, 아니면 JPA에 살짝 서툴러서도 있고, 여튼 다음과 같이 직관적으로 단순하게 <strong><code>@OneToMany</code>만 달랑 붙여서 매핑하면 조인테이블 방식의 일대다 단방향 방식으로 매핑된다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(cascade = CascadeType.ALL, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name, List&lt;Child&gt; children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.children.addAll(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 작성하면 조인테이블인 <code>parent_children</code>라는 테이블이 새로 생긴다. 뭐 테이블 하나 생기면 어때.. 큰일 나겠어? 라고 생각할 수도 있지만, <strong><code>children</code>이 많지 않을 때만 큰 일이 안 나고, 많으면 제법 큰 일이 난다.</strong></p><h1 id="시나리오"><a href="#시나리오" class="headerlink" title="시나리오"></a>시나리오</h1><p>위와 같이 매핑된 상태에서 다음과 같은 간단한 시나리오를 생각해보자.</p><ol><li><code>parent</code>가 10개의 Child를 포함하는 <code>children</code>을 가진다.</li><li><code>parent.children</code>에서 Child의 id가 1, 2인 것 2개만 삭제한다.</li></ol><p>1번은 뭐 처음 생성이니 <code>parent</code> 1개에 대해 <code>parent</code> 테이블에 insert 1회, <code>children</code> 10개에 대해 <code>child</code> 테이블에 insert 10회 실행된다. 그리고 조인테이블 방식으로 동작하므로 <code>parent_children</code> 테이블에도 insert 10회 실행된다.</p><p>2번에서 <code>children</code> 중에서 2개를 지우므로 <code>parent_children</code> 테이블에서 delete 2회 실행되고, <code>orphanRemoval = true</code>로 설정되어 있으므로 <code>child</code> 테이블에서 delete 2회 실행될 것이다.</p><p>하지만 직접 실행해보면 2번은 예상과 완전히 다르게 동작한다!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(onConstructor = @__(<span class="meta">@Autowired</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneToManyRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> ParentRepository parentRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Parent parent1 = <span class="keyword">new</span> Parent(<span class="string">"parent 1"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            parent1.getChildren().add(</span><br><span class="line">                    <span class="keyword">new</span> Child(<span class="string">"child "</span> + i)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Parent dbParent = <span class="keyword">this</span>.parentRepository.saveAndFlush(parent1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****************************"</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Child&gt; children = dbParent.getChildren();</span><br><span class="line">        children.removeIf(child -&gt; </span><br><span class="line">                child.getId() == <span class="number">1L</span> || child.getId() == <span class="number">2L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="실행-결과"><a href="#실행-결과" class="headerlink" title="실행 결과"></a>실행 결과</h1><p><code>parent_children</code> 테이블에서 delete 2회, <code>orphanRemoval = true</code>로 설정되어 있으므로 <code>child</code> 테이블에서 delete 2회 실행될 것으로 예상했지만 실제로는,</p><ul><li><strong><code>parent.children</code> 10개 모두 delete 되면서 <code>parent_children</code> 테이블에서 <code>children_id</code>가 1, 2인 것을 제외한 8개의 레코드에 대해 모두 8회의 insert가 실행</strong>되고, </li><li>마지막에 <code>child</code> 테이블에서 2회의 delete가 실행된다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">parent</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">parent</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">2</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">3</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">4</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">5</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">6</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">7</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">8</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">9</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">10</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">3</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">6</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">7</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">8</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">9</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">10</span>]</span><br><span class="line">*****************************</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> parent_children <span class="keyword">where</span> parent_id=?  &lt;== 헉!! 형이 왜 여기서 나와!!</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">3</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">6</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">7</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">8</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">9</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">10</span>]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>앞에서 <code>children</code>의 갯수가 많지 않을 때만 큰 일이 안 생긴다고 한 이유가 여기에 있다. 위의 사례에서는 <code>children</code>이 10개 밖에 되지 않으므로 insert를 10개 쯤 한다고 해도 사실 거의 티가 나지 않는다. 하지만 10개가 아니라 1000개, 10000개 그 이상이라면? <strong>고작 레코드 2개 삭제하려는 것 뿐인데 1000회, 10000회의 insert가 실행된다.</strong> ㄷㄷㄷ</p><p>그런데 왜 이렇게 동작하는 걸까?</p><h1 id="나름의-사연"><a href="#나름의-사연" class="headerlink" title="나름의 사연"></a>나름의 사연</h1><p>실행한 후 <code>parent_children</code> 테이블을 보면 다음과 같다.</p><table><thead><tr><th>parent_id</th><th>children_id</th></tr></thead><tbody><tr><td>1</td><td>3</td></tr><tr><td>1</td><td>4</td></tr><tr><td>1</td><td>5</td></tr><tr><td>1</td><td>6</td></tr><tr><td>1</td><td>7</td></tr><tr><td>1</td><td>8</td></tr><tr><td>1</td><td>9</td></tr><tr><td>1</td><td>10</td></tr></tbody></table><p>나: 뭐야, <code>1 | 1</code>인 행이랑 <code>1 | 2</code>인 행 2개만 지울 수 있었을 것 같은데, 왜 <code>parent_id</code>가 1인 걸 몽땅 지워?</p><p>Hibernate: 허허.. 그게 말이야.. 허허.. 테이블로 보기엔 저런데.. 허허.. <strong>일대다 단방향이잖아.. 허허.. 그래서.. 허허.. <code>parent_id</code>가 1이라는 것을 개별 행에 대한 조건으로 줄 수가 없어..</strong> 허허.. 그래서 <code>parent_id</code>가 1인 걸 몽땅 지우고 다시 채웠어.. 허허..</p><p>나: 뭐래냐..</p><p>이것도 말보다 코드가 더 쉽고 명확한 케이스다. id가 1, 2인 <code>child</code>를 삭제하는 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Child&gt; children = dbParent.getChildren();</span><br><span class="line">children.removeIf(child -&gt; </span><br><span class="line">        child.getId() == <span class="number">1L</span> || child.getId() == <span class="number">2L</span>);  <span class="comment">// &lt;-- 여기!!</span></span><br></pre></td></tr></table></figure><p>위에 <code>여기</code>로 표시한 부분에서 <code>parent_id</code>에 대한 조건을 줄 수가 없다. 왜냐고? 위에 Hibernate가 얘기해 준대로 <strong>일대일 단방향이라서 <code>child</code>는 <code>parent</code>를 모른다. 따라서 <code>parent_id</code>를 <code>children</code>의 개별 행에 대한 삭제 조건으로 지정할 수가 없다.</strong></p><p>대신에 <code>dbParent.getChildren()</code>의 <code>dbParent</code>에는 <code>parent_id</code>가 1이라는 정보가 있다. 그래서 <strong><code>children</code>를 개별 행 단위로 삭제할 수는 없지만 <code>parent_children</code> 테이블에서는 <code>parent_id</code>가 1인 행을 모두 삭제할 수는 있다.</strong> 그래서 <code>parent_id</code>가 1인 레코드를 모두 delete 한 후에 다시 insert를 반복하는 노가다를 한 것이다.</p><p>결국 Hibernate는 주어진 환경에서 최선을 다한 셈이고 아무 죄가 없다. 모두 delete 후 다시 모두 insert 반복으로만 해결할 수 있게 코드를 짠 사람이 잘못이다.</p><h1 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h1><p>이제 문제를 바로잡아보자. 조인테이블 방식의 일대다 단방향 매핑때문에 <code>children</code> 쪽에서 행 단위로 <code>parent_id</code>를 알 수 없다는 게 원인이었으므로, <strong>어떻게든 <code>children</code> 쪽에서 행 단위로 <code>parent_id</code>를 알 수 있게 해주면 된다. 즉 테이블 상에서 <code>children</code> 쪽에 <code>parent_id</code> 컬럼이 추가되도록 매핑하면 된다.</strong></p><p>방법은 두 가지가 있다. 조인테이블이 아닌 조인컬럼 방식의 일대다 단방향 매핑과 일대다 양방향 매핑이다.</p><p>먼저 조인컬럼 방식의 일대다 단방향 매핑부터 알아보자.</p><h2 id="조인컬럼-방식의-일대다-단방향-매핑"><a href="#조인컬럼-방식의-일대다-단방향-매핑" class="headerlink" title="조인컬럼 방식의 일대다 단방향 매핑"></a>조인컬럼 방식의 일대다 단방향 매핑</h2><p>이 방식은 Parent에 단 한 줄의 코드만 추가하면 된다. 물론 예제 코드에서만..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OneToMany</span>(cascade = CascadeType.ALL, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"parent_id"</span>)  <span class="comment">// &lt;-- 여기!!</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>위와 같이 Parent 엔티티에 <code>@JoinColumn(name = &quot;parent_id&quot;)</code>만 추가해주면 된다.</p><p>이제 조인테이블 방식이 아니므로 <code>parent_children</code> 테이블은 필요 없고, <code>child</code> 테이블에 <code>parent_id</code> 컬럼이 추가되고, <code>child</code> 테이블의 행 단위로 <code>parent_id</code>를 알 수 있으므로 몽창 delete 후 몽창 insert 하는 노가다는 발생하지 않고 id가 1, 2인 <code>child</code>만 삭제할 수 있을 것이다.</p><p>실행해보면 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">parent</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">parent</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">2</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">3</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">4</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">5</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">6</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">7</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">8</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">9</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">10</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">3</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">6</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">7</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">8</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">9</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">10</span>]</span><br><span class="line">*****************************</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=<span class="literal">null</span> <span class="keyword">where</span> parent_id=? <span class="keyword">and</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=<span class="literal">null</span> <span class="keyword">where</span> parent_id=? <span class="keyword">and</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>오 역시나 <code>*****</code> 아래에 10번의 불필요한 insert 가 모두 사라지고 맨 아래 delete 2회만 실행된 것을 확인할 수 있다.</p><p>그런데 <code>*****</code> 바로 위에 10번의 update는 또 왜 실행된거지?</p><p>이유는 이번에도 단방향이기 때문이다. <strong>조인컬럼 방식으로 변환하면서 <code>child</code> 테이블에 <code>parent_id</code> 컬럼이 추가되기는 했지만, 단방향이라서 <code>child</code>는 <code>parent</code>의 존재를 모르므로 <code>parent_id</code>의 값을 알 수는 없다.</strong> 뭐랄까 냉장고는 사놨는데 뭘로 채워야할지 모르는..</p><p>그래서 <strong>개별 행 단위로는 <code>parent_id</code> 컬럼에 값이 없는 채로 insert 되고, insert 된 10개의 행의 <code>parent_id</code> 컬럼에는 <code>dbParent.getChildren()</code>에서 알아낼 수 있는 <code>parent_id</code> 값을 update 를 통해 설정</strong>한다. 하지만 이건 최초에 데이터가 세팅될 때 1회만 그런거고, 이렇게 <code>parent_id</code> 값이 저장된 후에는 삭제를 원하는 레코드만 삭제할 수 있게 되므로 조인테이블 방식의 문제는 해결했다고 볼 수 있다.</p><p>이제 <code>*****</code> 아래에 실행된 쿼리를 살펴보자. update가 2회, delete가 2회 실행됐다. delete 2회만 실행되기를 예상했지만 update 2회가 먼저 실행됐다. 이 부분은 자세히 살펴볼 필요가 있다.</p><p><strong>신동민 님의 도움</strong>으로 정확히 알게 되었는데, 일대다 조인컬럼 방식에서 <code>children.remove(child)</code>를 실행해서 <code>children</code> 쪽의 레코드 삭제를 시도하면 실제 쿼리는 delete가 아니라 해당 레코드의 <code>parent_id</code>에 null을 저장하는 update가 실행된다. 의도와 다르게 동작한 것 같아서 이상해보이지만, 일대다 단방향 매핑에서 <strong><code>children.remove(child)</code>는 사실 <code>child</code> 자체를 삭제하라는 게 아니라 <code>child</code>가 <code>parent</code>의 <code>children</code>의 하나로 존재하는 관계를 remove 하라는 것이다. 따라서 <code>child</code> 자체를 delete 하는 게 아니라 <code>parent_id</code>에 null 값을 넣는 update를 실행하는 게 정확히 맞다.</strong> 이 부분의 코드도 신동민 님이 알려주셨는데 <a href="https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/persister/collection/OneToManyPersister.java" target="_blank" rel="noopener">여기</a>에서 확인할 수 있다. </p><p>결국 이번에도 Hibernate는 정확히 동작한다. 관계의 remove를 레코드의 delete로 넘겨짚은 사람이 문제지..</p><p><strong>그럼 마지막에 실행된 2회의 delete는 뭘까? 이건 <code>orphanRemoval = true</code>로 설정되어 있기 때문에 2개의 <code>child</code> 자체를 delete 한 것</strong>이다.</p><p>그런데 사실 Hibernate가 어찌 동작하든 간에, 데이터 처리 관점에서 보자면 원했던 것은 2개의 레코드를 delete 하는 것이었는데, 2회의 update와 2회의 delete가 실행되는 것은 여전히 불필요한 작업이 추가된 것 같다. 하지만 <strong>이를 불필요한 오버헤드라고 부르는 것은 적합하지 않아 보인다.</strong> </p><p><strong>RDB 관점에서 보면 테이블 사이의 관계는 언제나 양방향이지만 JPA의 엔티티 사이의 관계는 단방향과 양방향이 분명히 다르다.</strong> 따라서 RDB 관점에서야 이걸 오버헤드라고 부를 수도 있겠지만, <strong>단방향으로 매핑된 JPA에서는 레코드의 delete가 아니라 관계의 remove로 동작하는 것이 정확하고 따라서 delete가 아니라 update로 실행되는 것이 맞으므로 불필요한 오버헤드라고 부르는 것은 적합하지 않다.</strong></p><p>그래도 여전히 2회의 delete만으로 끝날 일을 2회의 update와 <code>orphanRemoval</code>을 동원해서 2회의 delete로 실행하는 것이 마음에 안 든다면, <strong>RDB 처럼 양방향으로 만들어 주면 JPA도 RDB 처럼 2회의 delete만으로 끝낸다.</strong> 그럼 이제 일대다 양방향 매핑을 살펴보자.</p><p>그 전에, 앞에서 조인커럼 방식으로의 전환을 단 한 줄로 적용가능 한 것은 예제 코드라서 가능하다고 했는데, 구체적으로 말하면 <code>*****</code> 위에서 update로 값을 자동 세팅해주는 것도 예제 코드라서, <strong><code>spring.jpa.properties.hibernate.hbm2ddl.auto</code> 옵션을 <code>create</code> 등 마음대로 줄 수 있기 때문에 가능한 것이고, 실 운영 환경에서는 저렇게 수행할 수 없다.</strong></p><p>운영 환경에서는 <code>child</code> 테이블에 <code>parent_id</code> 컬럼도 직접 추가해줘야 하고 다음과 같이 update 쿼리를 만들어서 <strong>기존에 <code>parent_children</code> 테이블에 있던 값을 기준으로 <code>child</code> 테이블의 <code>parent_id</code> 컬럼에 수동으로 입력해줘야 한다.</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> a</span><br><span class="line"><span class="keyword">set</span> a.parent_id = (</span><br><span class="line">    <span class="keyword">select</span> b.parent_id </span><br><span class="line">    <span class="keyword">from</span> parent_children b</span><br><span class="line">    <span class="keyword">where</span> a.id = b.children_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="일대다-양방향-매핑"><a href="#일대다-양방향-매핑" class="headerlink" title="일대다 양방향 매핑"></a>일대다 양방향 매핑</h2><p>앞에서 살펴본 것처럼 RDB와 똑같이 동작하기를 원한다면 JPA에서도 양방향으로 매핑을 해줘야 한다. 조인컬럼 방식으로 전환할 때보다는 조금 손이 더 가지만 작업량은 그리 많지 않다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mappedBy 추가</span></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"parent"</span>, cascade = CascadeType.ALL, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name, List&lt;Child&gt; children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.children.addAll(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent 필드 추가</span></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"parent_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Parent parent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자에 Parent 추가</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String name, Parent parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(onConstructor = @__(<span class="meta">@Autowired</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneToManyRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> ParentRepository parentRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Parent parent1 = <span class="keyword">new</span> Parent(<span class="string">"parent 1"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            parent1.getChildren().add(</span><br><span class="line">                    <span class="keyword">new</span> Child(<span class="string">"child "</span> + i, parent1)  <span class="comment">// 생성 시 parent1 추가</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        Parent dbParent = <span class="keyword">this</span>.parentRepository.saveAndFlush(parent1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****************************"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Child&gt; children = dbParent.getChildren();</span><br><span class="line">        children.removeIf(child -&gt; </span><br><span class="line">                child.getId() == <span class="number">1L</span> || child.getId() == <span class="number">2L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행 결과는 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">parent</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">parent</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">2</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">3</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">4</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">5</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">6</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">7</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">8</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">9</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">10</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">*****************************</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>오! 처음에 원했던 그대로 delete 만 2회 실행될 뿐 아무런 오버헤드도 발생하지 않는다!</p><p><strong>일대다 양방향 매핑과 일대다 단방향 조인컬럼 매핑의 결과로 나타나는 테이블 구조는 두 방식에서 모두 동일</strong>하다. <strong>두 방식 모두 <code>child</code>에 <code>parent_id</code> FK 컬럼</strong>을 두게 된다. </p><p>일대다 양방향 매핑과 일대다 단방향 조인컬럼 매핑의 차이점은 다음과 같다.</p><ul><li>조인컬럼 일대다 단방향 매핑은 <code>child</code>가 <code>parent</code>를 모르기 때문에, 앞에서 설명한 것처럼 1회성이긴 하지만 <code>parent_id</code> 값을 저장하기 위해 update 오버헤드가 발생한다.</li><li>일대다 양방향 매핑은 <code>child</code>가 <code>parent</code>를 알기 때문에 불필요한 오버헤드가 발생하지 않는다.</li></ul><p>다만 <strong>일대다 양방향 매핑은 도메인 로직 상에서 <code>parent</code>를 몰라도 되는 <code>child</code>에게 굳이 <code>parent</code>를 강제로 알게 만드는 것이 단점</strong>인데, 이 단점은 <strong><code>parent</code>에 대한 public getter 메서드를 만들지 않거나 또는 극단적으로 아예 <code>parent</code>에 대한 getter 메서드를 만들지 않는 방식으로 보완할 수 있다.</strong></p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><p>일대다 단방향 매핑은 직관적으로는 단순해서 좋지만,<br>조인테이블 방식은 insert가, 조인컬럼 방식은 1회성이긴 하지만 update가 오버헤드로 작용한다.</p><p>따라서 1:N에서 N이 큰 상황에서는,</p><ul><li>오버헤드가 없는 일대다 양방향 매핑을 사용하는 것이 가장 좋고,  </li><li>그 다음은 일대다 단방향 조인컬럼 방식,  </li><li>그리고 parent 쪽에 <code>@OneToMany</code>만 달랑 붙이는 일대다 단방향 조인테이블 방식은 사용하지 않는 것이 좋다.</li></ul><p>더 축약하자면, <strong>1:N에서 N이 클 때는 웬만하면 일대다 양방향 매핑을 사용하자.</strong></p></blockquote><h1 id="부록-응용편"><a href="#부록-응용편" class="headerlink" title="부록 - 응용편"></a>부록 - 응용편</h1><p>다음과 같이 하나의 Parent에서 2개의 Child에 대해 1:1, 1:N 연관관계 매핑이 필요하면 어떻게 할까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 이게 추가된다면?</span></span><br><span class="line">    <span class="keyword">private</span> Child singleChild;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(cascade = CascadeType.ALL, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name, Child singleChild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.singleChild = singleChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name, Child singleChild, List&lt;Child&gt; children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.singleChild = singleChild;</span><br><span class="line">        <span class="keyword">this</span>.children.addAll(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 경우에는 일대일 단방향 매핑을 위해 다음과 같이 Parent 에 <code>@JoinColumn</code>을 지정해서 Child를 위한 FK 컬럼을 추가하면, 일대일 단방향 + 일대다 양방향을 함께 쓸 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이게 추가된다면?</span></span><br><span class="line"><span class="comment">//// 일대일 단방향을 쓰되 Child를 가리키는 FK 컬럼을 Parent에 둔다</span></span><br><span class="line"><span class="meta">@OneToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"single_child_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Child singleChild;</span><br></pre></td></tr></table></figure><p>그럼 <code>parent</code> 테이블은 다음과 같이 되고,</p><p><code>id | name | single_child_id</code></p><p><code>child</code> 테이블은 다음과 같이 되고, <code>single_child</code>와 <code>children</code>에 해당하는 데이터가 모두 <code>child</code> 테이블에 저장된다.</p><p><code>id | name | parent_id</code></p><p>그런데 이렇게 한 테이블에 저장되면 혼동이 될 수도 있을 것 같아 걱정이 된다.</p><p>하지만, <strong>일대일 단방향에 의해 저장된 레코드에만 <code>parent_id</code> 값이 <code>NULL</code>인 상태가 되고,</strong><br><strong>일대다 양방향에 의해 저장된 레코드에는 <code>parent_id</code>에 정상적인 값이 들어가므로 구분 가능</strong>하며 혼동 없이 사용할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일&quot;&gt;&lt;a href=&quot;#JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일&quot; class=&quot;headerlink&quot; title=&quot;JPA 일대다 단방향 매핑 잘못 사용하면 벌어지는 일&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="JPA" scheme="http://homoefficio.github.io/tags/JPA/"/>
    
      <category term="Spring Data JPA" scheme="http://homoefficio.github.io/tags/Spring-Data-JPA/"/>
    
      <category term="Java Persistence API" scheme="http://homoefficio.github.io/tags/Java-Persistence-API/"/>
    
      <category term="ORM" scheme="http://homoefficio.github.io/tags/ORM/"/>
    
      <category term="Object Relation Mapping" scheme="http://homoefficio.github.io/tags/Object-Relation-Mapping/"/>
    
      <category term="Hibernate" scheme="http://homoefficio.github.io/tags/Hibernate/"/>
    
      <category term="하이버네이트" scheme="http://homoefficio.github.io/tags/%ED%95%98%EC%9D%B4%EB%B2%84%EB%84%A4%EC%9D%B4%ED%8A%B8/"/>
    
      <category term="1:N" scheme="http://homoefficio.github.io/tags/1-N/"/>
    
      <category term="OneToMany" scheme="http://homoefficio.github.io/tags/OneToMany/"/>
    
      <category term="ManyToOne" scheme="http://homoefficio.github.io/tags/ManyToOne/"/>
    
      <category term="일대다" scheme="http://homoefficio.github.io/tags/%EC%9D%BC%EB%8C%80%EB%8B%A4/"/>
    
      <category term="unidirectional" scheme="http://homoefficio.github.io/tags/unidirectional/"/>
    
      <category term="단방향" scheme="http://homoefficio.github.io/tags/%EB%8B%A8%EB%B0%A9%ED%96%A5/"/>
    
      <category term="bidirectional" scheme="http://homoefficio.github.io/tags/bidirectional/"/>
    
      <category term="양방향" scheme="http://homoefficio.github.io/tags/%EC%96%91%EB%B0%A9%ED%96%A5/"/>
    
      <category term="association" scheme="http://homoefficio.github.io/tags/association/"/>
    
      <category term="연관관계" scheme="http://homoefficio.github.io/tags/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"/>
    
      <category term="매핑" scheme="http://homoefficio.github.io/tags/%EB%A7%A4%ED%95%91/"/>
    
      <category term="엔티티" scheme="http://homoefficio.github.io/tags/%EC%97%94%ED%8B%B0%ED%8B%B0/"/>
    
      <category term="Entity" scheme="http://homoefficio.github.io/tags/Entity/"/>
    
      <category term="JoinColumn" scheme="http://homoefficio.github.io/tags/JoinColumn/"/>
    
      <category term="JoinTable" scheme="http://homoefficio.github.io/tags/JoinTable/"/>
    
      <category term="mappedBy" scheme="http://homoefficio.github.io/tags/mappedBy/"/>
    
      <category term="cascade" scheme="http://homoefficio.github.io/tags/cascade/"/>
    
      <category term="orphanRemoval" scheme="http://homoefficio.github.io/tags/orphanRemoval/"/>
    
      <category term="스프링 데이터 JPA" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA/"/>
    
      <category term="Overhead" scheme="http://homoefficio.github.io/tags/Overhead/"/>
    
      <category term="오버헤드" scheme="http://homoefficio.github.io/tags/%EC%98%A4%EB%B2%84%ED%97%A4%EB%93%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO Direct Buffer를 이용해서 대용량 파일 행 기준으로 쪼개기</title>
    <link href="http://homoefficio.github.io/2019/02/27/Java-NIO-Direct-Buffer%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%8C%8C%EC%9D%BC-%ED%96%89-%EA%B8%B0%EC%A4%80%EC%9C%BC%EB%A1%9C-%EC%AA%BC%EA%B0%9C%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2019/02/27/Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기/</id>
    <published>2019-02-26T15:23:43.000Z</published>
    <updated>2019-04-28T17:03:55.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기"><a href="#Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기" class="headerlink" title="Java NIO Direct Buffer를 이용해서 대용량 파일 행 기준으로 쪼개기"></a>Java NIO Direct Buffer를 이용해서 대용량 파일 행 기준으로 쪼개기</h1><p>기가 단위의 파일을 외부에 전송할 일이 생겼다. </p><p>한 방에 보내기엔 너무 커서 파일을 쪼개서(split) 보내려고 하는데, 그마저도 쉽지 않다. 쪼개기 위해 대용량 파일을 읽을 때 이미 수십분 동안 CPU를 너무 잡아 먹어서 이 쪼개는 배치 작업을 스케줄링하는 스케줄러(Quartz)에 문제를 일으킨다.</p><p>DMA(Direct Memory Access)를 사용하는 것이 좋겠다.</p><h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><p><img src="https://i.imgur.com/LNHHp8h.png" alt="Imgur"></p><p>(그림 출처: <a href="https://howtodoinjava.com/java/io/how-java-io-works-internally-at-lower-level/" target="_blank" rel="noopener">https://howtodoinjava.com/java/io/how-java-io-works-internally-at-lower-level/</a>)</p><p>디스크 컨트롤러는 DMA를 통해 CPU를 건드리지 않고 직접 운영체제 메모리에 접근할 수 있고, 응용 프로그램은 Direct Buffer를 활용해서 JVM 메모리가 아닌 운영체제 메모리에 직접 접근할 수 있다.</p><p>장점은 다음과 같다.</p><ol><li>디스크에 있는 파일을 운영체제 메모리로 읽어들일 때 CPU를 건드리지 않는다.</li><li>운영체제 메모리에 있는 파일 내용을 JVM 내 메모리로 다시 복사할 필요가 없다.</li><li>JVM 내 힙 메모리를 쓰지 않으므로 GC를 유발하지 않는다.(물론 일정 크기를 가진 버퍼가 운영체제 메모리에 생성되는 것이고, 이 버퍼에 대한 참조 자체는 JVM 메모리 내에 생성된다)</li></ol><p>단점은 다음과 같다.</p><ol><li>DMA에 사용할 버퍼 생성 시 시간이 더 소요될 수 있다.</li><li>바이트 단위로 데이터를 취급하므로, <strong>데이터를 행 단위로 취급하기 불편하다.</strong></li></ol><p>Aㅏ.. 파일 쪼개기 할 때 행 기준으로 쪼개야 하는데.. 일단 불편한 것일 뿐 아예 안 되는 것은 아니므로 시도해보자.</p><p>종합해보면 <strong>파일의 크기가 대단히 클 때 DMA의 장점을 누릴 수 있고 단점을 피할 수 있다.</strong></p><h1 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h1><p>Java 1.4 부터 도입된 NIO에 <code>FileChannel</code>이 포함되어 있는데, <code>ByteBuffer</code>를 통해 File I/O를 수행할 수 있다.</p><p>대략 다음과 같은 방식으로 사용할 수 있다.</p><h2 id="파일-읽기-용-FileChannel"><a href="#파일-읽기-용-FileChannel" class="headerlink" title="파일 읽기 용 FileChannel"></a>파일 읽기 용 FileChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileChannel srcFileChannel = Files.open(Paths.get(<span class="string">"/home/homo-efficio/tmp/LargeFile"</span>), StandardOpenOption.READ);</span><br></pre></td></tr></table></figure><h2 id="파일-쓰기-용-FileChannel"><a href="#파일-쓰기-용-FileChannel" class="headerlink" title="파일 쓰기 용 FileChannel"></a>파일 쓰기 용 FileChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileChannel destFileChannel = Files.open(Paths.get(<span class="string">"/home/homo-efficio/tmp/LargeFile"</span>), StandardOpenOption.WRITE);</span><br></pre></td></tr></table></figure><p><code>Path</code> 말고 <code>RandomAccessFile</code>을 활용하는 방법도 있고, 파일 열기 모드에도 <code>TRUNCATE_EXIST</code>, <code>CREATE</code>, <code>CREATE_NEW</code> 등 여러가지가 있고 혼합해서 사용할 수 있다.</p><h1 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h1><p>실제 데이터를 담는 바이트 버퍼 클래스로서 JVM 힙을 사용하는 일반(Non-Direct) 버퍼와 운영체제 메모리에 직접 접근할 수 있는 Direct Buffer를 생성할 수 있다. Direct Buffer는 다음과 같이 간단하게 생성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>버퍼가 Direct 인지 아닌지 <code>buffer.isDirect()</code>를 통해 판별할 수도 있다.</p><h2 id="위치-관련-속성"><a href="#위치-관련-속성" class="headerlink" title="위치 관련 속성"></a>위치 관련 속성</h2><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>버퍼 내에서 값을 읽거나 쓸 수 있는 <strong>시작 위치</strong>를 나타낸다. 버퍼 내로 1 바이트의 데이터가 추가될 때마다 <code>position</code> 값도 1 증가한다.</p><p><code>buffer.position()</code>, <code>buffer.position(int)</code></p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>버퍼 내에서 값을 읽거나 쓸 수 있는 <strong>끝 위치</strong>를 나타낸다. <code>limit - 1</code> 위치까지의 데이터가 읽거나 써진다.</p><p><code>buffer.limit()</code>, <code>buffer.limit(int)</code></p><h3 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h3><p>현재 <code>position</code> 위치에 <strong>표시</strong>를 해두고, 나중에 <code>reset()</code>을 호출하면 표시해둔 위치로 <code>position</code>이 이동한다.</p><p><code>buffer.mark()</code></p><h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><p>버퍼의 용량(담을 수 있는 데이터의 크기)를 나타내며, 버퍼 생성 시 <code>ByteBuffer.allocate(capacity)</code> 나 <code>ByteBuffer.allocateDirect(capacity)</code> 로 지정할 수 있다.</p><p><code>buffer.capacity()</code></p><h2 id="위치-관련-메서드"><a href="#위치-관련-메서드" class="headerlink" title="위치 관련 메서드"></a>위치 관련 메서드</h2><h3 id="flip"><a href="#flip" class="headerlink" title="flip()"></a>flip()</h3><p><code>position</code>을 0으로, <code>limit</code>을 읽어들인 데이터의 마지막 바이트+1 위치로 세팅한다. </p><p>버퍼에 있는 데이터를 처음부터 모두 읽을 때 사용한다.</p><h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h3><p><code>position</code>을 0으로, <code>limit</code>은 현재 그대로 유지한다.</p><p>버퍼에 있는 데이터를 처음부터 현재 <code>limit</code> 위치 바로 앞까지 읽을 때 사용한다.</p><h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p><code>position</code>을 <code>mark</code> 위치로 세팅한다.</p><h3 id="compact"><a href="#compact" class="headerlink" title="compact()"></a>compact()</h3><p>현재 <code>position</code>부터 <code>limit - 1</code> 까지의 데이터를 버퍼의 맨 앞으로 복사한 후에, <code>position</code>을 복사한 데이터 바로 다음 위치로 이동시키고, <code>limit</code>는 <code>capacity</code>로 이동한다. 행 기준으로 데이터를 다룰 때 핵심 역할을 담당한다. </p><h2 id="읽고-쓰는-값-관련-메서드"><a href="#읽고-쓰는-값-관련-메서드" class="headerlink" title="읽고 쓰는 값 관련 메서드"></a>읽고 쓰는 값 관련 메서드</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>position</code> 에 있는 값을 읽어서 반환한다.</p><h3 id="put-byte"><a href="#put-byte" class="headerlink" title="put(byte)"></a>put(byte)</h3><p><code>byte</code>를 <code>position</code> 위치에 쓴다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><p>Direct Buffer를 생성하는 것 자체는 그저 전용 메서드 하나 호출하는 것밖에 없어 단순하다. 다만, 줄 바꿈 처리에 좀 신경을 써야 한다.</p><p>대용량 파일 대상이므로 행의 크기 보다 버퍼 크기가 크다고 가정했다. 버퍼가 작을 때도 적용되도록 구현할 수는 있겠지만 불필요하게 로직만 복잡해지므로 이 때는 그냥 예외를 던지게 했다.</p><p>쉽게 요약하면,</p><ol><li>파일에서 버퍼만큼 읽어들인 후,</li><li>버퍼에서 LF가 나올 때까지 1 바이트씩 뒤로 이동,</li><li>LF가 나오면(0 ~ position 내의 마지막 LF) 버퍼의 시작부터 position 위치 내의 마지막 LF까지를 target 파일에 쓰고,</li><li>마지막 LF 뒤에서 버퍼 끝까지의 내용을 <code>compact()</code> 메서드를 이용해서 버퍼의 시작 위치로 복사하고,</li><li>그 이후의 내용은 다시 1번으로 돌아가서 버퍼에 읽어들이면서 반복</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">splitFileIntoDir</span><span class="params">(String srcFilePath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String destDirPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String splittedFileNameFormat,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String header,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    ByteBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span> LINE_FEED = <span class="number">0x0A</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span> CARRIAGE_RETURN = <span class="number">0x0D</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fileCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> totalReadBytes = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> totalWriteBytes = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> readBytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Path path = Paths.get(srcFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> FileChannel srcFileChannel = FileChannel.open(path, StandardOpenOption.READ)) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((readBytes = srcFileChannel.read(buffer)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            totalReadBytes += readBytes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> contentLength = buffer.position();</span><br><span class="line">            <span class="keyword">int</span> newLinePosition = buffer.position();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> (<span class="keyword">final</span> FileChannel splittedFileChannel =</span><br><span class="line">                         FileChannel.open(Paths.get(destDirPath, String.format(splittedFileNameFormat, ++fileCounter)),</span><br><span class="line">                                 StandardOpenOption.TRUNCATE_EXISTING,</span><br><span class="line">                                 StandardOpenOption.CREATE,</span><br><span class="line">                                 StandardOpenOption.WRITE)) &#123;</span><br><span class="line">                writeHeader(header, readBytes, splittedFileChannel);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> hasLineFeed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">boolean</span> needCompact = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span> (newLinePosition &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (buffer.get(--newLinePosition) == LINE_FEED) &#123;  <span class="comment">// 1 byte 씩 뒤로 가면서 줄바꿈 탐색</span></span><br><span class="line">                        <span class="keyword">if</span> (newLinePosition + <span class="number">1</span> == buffer.capacity()) &#123;  <span class="comment">// 버퍼 끝에 줄바꿈이 있으면 compact 불필요</span></span><br><span class="line">                            needCompact = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        buffer.position(<span class="number">0</span>);  <span class="comment">// buffer의 처음부터</span></span><br><span class="line">                        buffer.limit(++newLinePosition);  <span class="comment">// LINE_FEED 까지 포함해서 write 되도록 limit 조정</span></span><br><span class="line">                        <span class="comment">// 버퍼의 [0, limit)의 내용을 splittedFileChannel이 바인딩된 파일에 write</span></span><br><span class="line">                        totalWriteBytes += splittedFileChannel.write(buffer);</span><br><span class="line">                        splittedFileChannel.close();</span><br><span class="line">                        hasLineFeed = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!hasLineFeed) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"버퍼 안에 줄바꿈이 없습니다. 버퍼 크기는 한 행의 길이보다 커야 합니다."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (needCompact) &#123;</span><br><span class="line">                    <span class="comment">// compact()를 위해 원래 읽었던 내용의 마지막 바이트 위치+1(==contentLength) 로 limit 설정</span></span><br><span class="line">                    buffer.limit(contentLength);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 버퍼의 [position, limit) 의 내용을 [0, limit - position) 으로 복사</span></span><br><span class="line">                    buffer.compact();</span><br><span class="line">                    <span class="comment">// 복사 후 position은 limit에 위치하며 다음에 파일에서 읽어오는 내용이 position 부터 이어짐</span></span><br><span class="line">                    <span class="comment">// limit는 capacity로 이동</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// compact()가 필요없다면 파일을 읽어서 버퍼의 처음 위치부터 저장하도록 초기화</span></span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"File Split 도중 예외 발생"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Total Read  Bytes: "</span> + totalReadBytes);</span><br><span class="line">    System.out.println(<span class="string">"Total Write Bytes: "</span> + totalWriteBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeHeader</span><span class="params">(String header, <span class="keyword">long</span> readBytes, FileChannel splittedFileChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readBytes &gt; <span class="number">0</span> &amp;&amp; !StringUtils.isEmpty(header)) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] headerBytes = (header + System.lineSeparator()).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        splittedFileChannel.write(ByteBuffer.wrap(headerBytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="친절한-그림"><a href="#친절한-그림" class="headerlink" title="친절한 그림"></a>친절한 그림</h2><p>아무래도 그림으로 안 남겨놓으면 까먹은 후에 다시 봐도 이해가 안 될까봐..</p><p><img src="https://i.imgur.com/cYyw6I8.png" alt="Imgur"></p><p><img src="https://i.imgur.com/HNfdlTe.png" alt="Imgur"></p><p><img src="https://i.imgur.com/Nvllq5N.png" alt="Imgur"></p><p><img src="https://i.imgur.com/o8NvA8H.png" alt="Imgur"></p><p><img src="https://i.imgur.com/wSxPPi9.png" alt="Imgur"></p><p><img src="https://i.imgur.com/4VSL4vQ.png" alt="Imgur"></p><p><img src="https://i.imgur.com/nU1371g.png" alt="Imgur"></p><p><img src="https://i.imgur.com/8RSW7Me.png" alt="Imgur"></p><p><img src="https://i.imgur.com/QspJzSw.png" alt="Imgur"></p><p><img src="https://i.imgur.com/o8eFQ94.png" alt="Imgur"></p><p><img src="https://i.imgur.com/1oydbLu.png" alt="Imgur"></p><p><img src="https://i.imgur.com/i5LSNpn.png" alt="Imgur"></p><h1 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h1><p>한 행 당 70바이트 이내, 4,096,000행, 263MB 짜리 csv 파일을 1M, 10M, 50M, 100M 버퍼 크기 단위로 쪼개서 비교해 본 결과는 다음과 같다.</p><h2 id="수행-시간-비교"><a href="#수행-시간-비교" class="headerlink" title="수행 시간 비교"></a>수행 시간 비교</h2><p>버퍼 크기를 1M, 10M, 50M, 100M 를 한 사이클로 해서 2 사이클을 실행해서 수행 시간(초)을 비교해 본 결과,<br>전반적으로 Direct Buffer는 일반 Buffer보다 약 10% 정도 빠르고,<br>Direct Buffer는 readLine() 방식보다 적게는 약 2배, 많게는 약 5배 정도 빠르다.</p><table><thead><tr><th>버퍼 크기</th><th>회차</th><th>Direct Buffer</th><th>Buffer</th><th>readLine</th></tr></thead><tbody><tr><td>1M</td><td>1</td><td>1.62</td><td>1.87</td><td>3.85</td></tr><tr><td>1M</td><td>2</td><td>1.39</td><td>1.52</td><td>3.47</td></tr><tr><td>10M</td><td>1</td><td>0.46</td><td>0.52</td><td>2.41</td></tr><tr><td>10M</td><td>2</td><td>0.33</td><td>0.47</td><td>2.37</td></tr><tr><td>50M</td><td>1</td><td>1.23</td><td>2.65</td><td>2.33</td></tr><tr><td>50M</td><td>2</td><td>1.12</td><td>1.34</td><td>2.32</td></tr><tr><td>100M</td><td>1</td><td>1.37</td><td>1.51</td><td>2.42</td></tr><tr><td>100M</td><td>2</td><td>1.40</td><td>1.46</td><td>2.32</td></tr></tbody></table><p>FileChannel과 버퍼를 사용하는 방식은 버퍼 크기가 10M 일 때 다른 크기일 때에 비해 약 3 ~ 4배 정도 빨라지는 것이 특이하다.</p><h2 id="CPU-메모리-사용량-비교"><a href="#CPU-메모리-사용량-비교" class="headerlink" title="CPU, 메모리 사용량 비교"></a>CPU, 메모리 사용량 비교</h2><p>Direct Buffer, Buffer, readLine() 방식을 순서대로 실행해서 VisualVM으로 측정했다. 그래프에 표시된 것도 맨 왼쪽부터 Direct Buffer, Buffer, readLine() 방식이다.</p><p>예상대로 Direct Buffer는 JVM 메모리를 사용하지 않고 운영체제 메모리에 직접 접근하므로 JVM의 힙 메모리 사용량은 거의 없다. 물론 JVM 관점에서나 힙을 쓰지 않기 때문에 사용량이 적어 보이는 것이고, 운영체제 관점에서는 여전히 버퍼 크기 만큼의 메모리를 더 사용한다.<br>일반 Buffer는 버퍼 크기에 따라 JVM 힙 메모리 사용량도 비례해서 커지며,<br>readLine()은 1M, 10M, 50M 단위로 파일을 쪼개더라도 JVM 힙 메모리 사용량은 100M를 넘나든다.</p><p>CPU는 Direct Buffer와 Buffer는 아주 큰 차이는 없이 모두 10% 이내다. readLine()에 비해 약 1/3 정도에 불과할 정도로 절감 효과가 크지만, readLine() 방식도 30%에 미치지 않은 걸 보면 역시 263MB 짜리 파일은 Direct Buffer 효과가 두드러질 정도로 큰 파일은 아니라고 볼 수 있다.</p><h3 id="1M-버퍼-1M-단위로-자르기"><a href="#1M-버퍼-1M-단위로-자르기" class="headerlink" title="1M 버퍼, 1M 단위로 자르기"></a>1M 버퍼, 1M 단위로 자르기</h3><p><img src="https://i.imgur.com/6BET1z3.png" alt="Imgur"></p><p><img src="https://i.imgur.com/7dkgJCg.png" alt="Imgur"></p><h3 id="10M-버퍼-10M-단위로-자르기"><a href="#10M-버퍼-10M-단위로-자르기" class="headerlink" title="10M 버퍼, 10M 단위로 자르기"></a>10M 버퍼, 10M 단위로 자르기</h3><p><img src="https://i.imgur.com/wdWRADA.png" alt="Imgur"></p><p><img src="https://i.imgur.com/sdaNr3t.png" alt="Imgur"></p><h3 id="50M-버퍼-50M-단위로-자르기"><a href="#50M-버퍼-50M-단위로-자르기" class="headerlink" title="50M 버퍼, 50M 단위로 자르기"></a>50M 버퍼, 50M 단위로 자르기</h3><p><img src="https://i.imgur.com/G14IWFv.png" alt="Imgur"></p><p><img src="https://i.imgur.com/kEmfUja.png" alt="Imgur"></p><h3 id="100M-버퍼-100M-단위로-자르기"><a href="#100M-버퍼-100M-단위로-자르기" class="headerlink" title="100M 버퍼, 100M 단위로 자르기"></a>100M 버퍼, 100M 단위로 자르기</h3><p><img src="https://i.imgur.com/axhhB1Z.png" alt="Imgur"></p><p><img src="https://i.imgur.com/gJAbo3g.png" alt="Imgur"></p><h1 id="그런데-메모리-해제는"><a href="#그런데-메모리-해제는" class="headerlink" title="그런데 메모리 해제는?"></a>그런데 메모리 해제는?</h1><p>Direct Buffer는 JVM 힙이 아니라 운영체제 메모리를 사용하므로 GC를 유발하지 않는다고 했는데, GC를 유발하지 않는다고 마냥 좋아할 것이 아니다. GC가 안 되면 메모리 해제는 어떻게 이루어지는지 걱정해보는 센스가 필요하다.</p><p>아쉽게도 Java API 문서에는 Direct Buffer 로 사용한 메모리 해제 관련한 내용이 기술되어 있지 않다. 검색을 해보니 그나마 가장 있어보이는 질의응답은 <a href="https://stackoverflow.com/questions/36077641/java-when-does-direct-buffer-released" target="_blank" rel="noopener">https://stackoverflow.com/questions/36077641/java-when-does-direct-buffer-released</a> 여기에 있다. 공식 문서 내용은 아니므로 이게 정말 답인지는 알 수 없다.</p><p>요는 운영체제 메모리에 생성된 Direct Buffer 를 가리키는 참조는 JVM 메모리 내에 생성되는데, 이 참조가 GC가 되면 일반적인 GC 스레드가 아닌 다른 특정 스레드에 의해 버퍼 메모리가 해제된다고 한다.</p><p><code>DirectByteBuffer.Deallocator</code>에 대한 얘기가 나오는데 Java API 문서에는 없는 클래스지만, IntelliJ에서 클래스 검색을 해보면 나오긴 한다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><p>읽을 소스 파일이 기가 단위로 매우 크면 BufferedReader.readLine()은 CPU와 메모리를 엄청 잡아먹는다.</p><p>이 때 Java NIO의 FileChannel과 Direct Buffer를 활용하면 자원 사용량을 줄일 수 있다.</p><p>Buffer를 사용하면 자원 사용량과 속도 관점에서는 좋지만 행 기준으로 데이터를 처리하는데 불편함이 있다.</p><p>Buffer가 제공하는 메서드(position, mark, limit, flip, reset, rewind, compact)를 잘 활용하면 행 기준 처리도 가능하다.</p><p>Direct Buffer 를 가리키는 참조가 GC되면 운영체제 메모리에 생성된 Direct Buffer도 해제된다고 한다.(공식 API에 있는 내용은 아님)</p></blockquote><h2 id="읽을거리"><a href="#읽을거리" class="headerlink" title="읽을거리"></a>읽을거리</h2><ul><li><p>Java I/O를 Low Level에서 아주 잘 설명한 글: <a href="https://howtodoinjava.com/java/io/how-java-io-works-internally-at-lower-level/" target="_blank" rel="noopener">https://howtodoinjava.com/java/io/how-java-io-works-internally-at-lower-level/</a></p></li><li><p>Buffer의 사용법을 그림과 함께 아주 잘 설명한 글: <a href="https://palpit.tistory.com/641" target="_blank" rel="noopener">https://palpit.tistory.com/641</a></p></li><li><p>NIO2에 도입된 AsynchronousFileChannel 관련 글: <a href="https://homoefficio.github.io/2016/08/13/대용량-파일을-AsynchronousFileChannel로-다뤄보기/">https://homoefficio.github.io/2016/08/13/대용량-파일을-AsynchronousFileChannel로-다뤄보기/</a></p></li></ul><h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><p>Direct Buffer를 사용하더라도 channel의 read/write 메서드가 아니라 buffer의 get/put을 쓰면 DMA가 작동하지 않는다는 글을 봤는데 확인해보진 않았다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기&quot;&gt;&lt;a href=&quot;#Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="NIO" scheme="http://homoefficio.github.io/tags/NIO/"/>
    
      <category term="DMA" scheme="http://homoefficio.github.io/tags/DMA/"/>
    
      <category term="Direct Memory Access" scheme="http://homoefficio.github.io/tags/Direct-Memory-Access/"/>
    
      <category term="Direct Buffer" scheme="http://homoefficio.github.io/tags/Direct-Buffer/"/>
    
      <category term="ByteBuffer" scheme="http://homoefficio.github.io/tags/ByteBuffer/"/>
    
      <category term="Buffer" scheme="http://homoefficio.github.io/tags/Buffer/"/>
    
      <category term="FileChannel" scheme="http://homoefficio.github.io/tags/FileChannel/"/>
    
      <category term="Large File" scheme="http://homoefficio.github.io/tags/Large-File/"/>
    
      <category term="Split" scheme="http://homoefficio.github.io/tags/Split/"/>
    
      <category term="New Line" scheme="http://homoefficio.github.io/tags/New-Line/"/>
    
      <category term="Carriage Return" scheme="http://homoefficio.github.io/tags/Carriage-Return/"/>
    
      <category term="CR" scheme="http://homoefficio.github.io/tags/CR/"/>
    
      <category term="Line Feed" scheme="http://homoefficio.github.io/tags/Line-Feed/"/>
    
      <category term="LF" scheme="http://homoefficio.github.io/tags/LF/"/>
    
      <category term="readLine" scheme="http://homoefficio.github.io/tags/readLine/"/>
    
      <category term="직접 메모리 접근" scheme="http://homoefficio.github.io/tags/%EC%A7%81%EC%A0%91-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A0%91%EA%B7%BC/"/>
    
      <category term="다이렉트 버퍼" scheme="http://homoefficio.github.io/tags/%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%8A%B8-%EB%B2%84%ED%8D%BC/"/>
    
      <category term="바이트버퍼" scheme="http://homoefficio.github.io/tags/%EB%B0%94%EC%9D%B4%ED%8A%B8%EB%B2%84%ED%8D%BC/"/>
    
      <category term="버퍼" scheme="http://homoefficio.github.io/tags/%EB%B2%84%ED%8D%BC/"/>
    
      <category term="파일 채널" scheme="http://homoefficio.github.io/tags/%ED%8C%8C%EC%9D%BC-%EC%B1%84%EB%84%90/"/>
    
      <category term="스플릿" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%94%8C%EB%A6%BF/"/>
    
      <category term="대용량" scheme="http://homoefficio.github.io/tags/%EB%8C%80%EC%9A%A9%EB%9F%89/"/>
    
      <category term="대용량 파일" scheme="http://homoefficio.github.io/tags/%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%8C%8C%EC%9D%BC/"/>
    
      <category term="줄 바꿈" scheme="http://homoefficio.github.io/tags/%EC%A4%84-%EB%B0%94%EA%BF%88/"/>
    
  </entry>
  
  <entry>
    <title>Back to the Essence - Concurrency vs Parallelism</title>
    <link href="http://homoefficio.github.io/2019/02/02/Back-to-the-Essence-Concurrency-vs-Parallelism/"/>
    <id>http://homoefficio.github.io/2019/02/02/Back-to-the-Essence-Concurrency-vs-Parallelism/</id>
    <published>2019-02-02T14:29:47.000Z</published>
    <updated>2019-07-10T13:21:10.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Back-to-the-Essence-Concurrency-vs-Parallelism"><a href="#Back-to-the-Essence-Concurrency-vs-Parallelism" class="headerlink" title="Back to the Essence - Concurrency vs Parallelism"></a>Back to the Essence - Concurrency vs Parallelism</h1><blockquote><p>동시성이 뭐냐?<br>복수의 태스크를 동시에 실행하는 거 아니냐?</p><p>병렬성이 뭐냐?<br>복수의 태스크를 동시에 실행하는 거 아니냐?</p><p>그럼 동시성과 병렬성이 뭐가 다른 거냐?<br>…</p></blockquote><p>비슷하지만 다른 개념이라는 건 알겠는데, 설명하라면 또 명확하게 답하기가 쉽지 않다.</p><p>명확하게 답하기 쉽지 않은 이유는 몇 가지 관점에 따라 다르게 설명되어야 할 필요가 있는 것을 그냥 뭉뚱그려서 얘기해왔기 때문이다. 이제 관점에 따라 나눠서 살펴보자.</p><h2 id="시간-관점"><a href="#시간-관점" class="headerlink" title="시간 관점"></a>시간 관점</h2><h3 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h3><p>일단 <strong>동시성에서 말하는 동시는 물리적으로 완전히 동일한 한 시점만을 말하는 것이 아니라 사실 상 동시라고 간주할 수 있는 시점(virtually at the same time)도 포함</strong>한다. 물리적으로 미세하게 다른 시점일지라도 애플리케이션 관점에서 동시라고 간주할 수 있는 시간 간격에서 복수의 태스크가 수행된다면 동시성이 있다.</p><p>그래서 <strong>동시성은 CPU(또는 코어)가 1개인 상황에서도 가능</strong>하다. 시분할 시스템을 통해 사실 상 동시라고 간주해도 무방한 시간에 여러 개의 태스크를 진행시키고 있다면 동시성이 있다.</p><h3 id="Parallelism"><a href="#Parallelism" class="headerlink" title="Parallelism"></a>Parallelism</h3><p><strong>병렬성에서 말하는 동시는 물리적으로 완전히 동일한 시점(physically and literally at the same time)</strong> 이다.</p><p>그래서 <strong>CPU(또는 코어)가 1개인 상황에서는 병렬성을 가질 수 없다.</strong></p><h2 id="작업-독립성-관점"><a href="#작업-독립성-관점" class="headerlink" title="작업 독립성 관점"></a>작업 독립성 관점</h2><p>독립성은 관점에 따라 다르게 해석될 수 있지만, 그런 상대성을 용인하고 바라보면 다음과 같이 비교할 수도 있다.</p><h3 id="Concurrency-1"><a href="#Concurrency-1" class="headerlink" title="Concurrency"></a>Concurrency</h3><p><strong>동시성에서는 독립적인 복수 개의 태스크를 순서를 고려하지 않고 동시에 실행</strong>한다.</p><p>1에서 100까지 더하는 태스크와 1에서 100까지 곱하는 태스크를 동시(완전한 동시가 아니라 동시성에서 말하는 동시)에 실행한다면 이 두 태스크는 독립적이며, 이런 태스크를 동시(완전한 동시가 아니라 동시성에서 말하는 동시)에 처리한다면 동시성이 있다.</p><p>순서를 고려하지 않는다는 것은 순서를 지키는 경우와 지키지 않는 경우 모두를 포괄한다.</p><h3 id="Parallelism-1"><a href="#Parallelism-1" class="headerlink" title="Parallelism"></a>Parallelism</h3><p><strong>병렬성에서는 하나의 태스크를 여러 부분으로 쪼개서 동시에 실행</strong>한다.</p><p>1에서 100까지 더하는 하나의 태스크를 1-30, 31-50, 51-70, 71-100 이렇게 4개의 구간합으로 나누고, 이를 4개의 CPU(또는 코어)에서 각각 동시에 실행하면 병렬성이 있다.</p><h2 id="동시성과-병렬성의-조합"><a href="#동시성과-병렬성의-조합" class="headerlink" title="동시성과 병렬성의 조합"></a>동시성과 병렬성의 조합</h2><h3 id="동시성이-있으면서-병렬성은-없을-수-있다"><a href="#동시성이-있으면서-병렬성은-없을-수-있다" class="headerlink" title="동시성이 있으면서 병렬성은 없을 수 있다?"></a>동시성이 있으면서 병렬성은 없을 수 있다?</h3><p>어떤 관점에서든 CPU(또는 코어)가 1개인 상황에서는 병렬성이 있을 수 없으므로, 이건 자명하다.</p><h3 id="동시성은-없으면서-병렬성은-있을-수-있다"><a href="#동시성은-없으면서-병렬성은-있을-수-있다" class="headerlink" title="동시성은 없으면서 병렬성은 있을 수 있다?"></a>동시성은 없으면서 병렬성은 있을 수 있다?</h3><p>위에서 다룬 더하기 구간합은 병렬성이 분명히 있지만, 동시성이 있다고 보는 것은 관점에 따라 다르다. </p><p>구간합 자체를 별개의 태스크로 본다면 동시성이 있다고 볼 수 있고,<br>구간합을 별개의 태스크가 아니라 전체합이라는 하나의 태스크를 나눈 것으로만 본다면 동시성이 없다고 볼 수 있다.</p><h3 id="동시성과-병렬성-모두-있을-수-있다"><a href="#동시성과-병렬성-모두-있을-수-있다" class="headerlink" title="동시성과 병렬성 모두 있을 수 있다?"></a>동시성과 병렬성 모두 있을 수 있다?</h3><p>1에서 100까지 더하는 하나의 태스크를 1-50, 51-100 이렇게 2개의 구간합으로 나누고, 이를 1, 2번 CPU(또는 코어)에서 각각 동시에 실행하고, 동시에 1에서 100까지 곱하는 하나의 태스크를 1-50, 51-100 이렇게 2개의 구간곱으로 나누고, 이를 3, 4번 CPU(또는 코어)에서 각각 동시에 실행한다면 어떨까?</p><p>이럴 때는 더하기와 곱하기라는 독립적인 복수의 태스크를 동시에 실행하므로 동시성이 있고,<br>더하기라는 하나의 태스크를 구간합으로 나눠서 동시에 실행하고, 곱하기라는 하나의 태스크를 구간곱으로 나눠서 동시에 실행하므로 병렬성도 있다.</p><h2 id="concurrent-vs-simultaneous"><a href="#concurrent-vs-simultaneous" class="headerlink" title="concurrent vs simultaneous"></a>concurrent vs simultaneous</h2><p>참고로 전산 용어를 잠시 떠나서 concurrent와 simultaneous를 비교해보는 것도 concurrent의 의미를 이해하는 데 도움이 될 것 같다.</p><p>둘의 차이를 아래와 같이 해석하는 게 100% 맞는지는 원어민이 아닌 나는 알 수 없지만, 최소한 concurrency vs parallelism을 이해하는 데는 확실히 도움이 된다. 어설픈 번역 말고 그냥 원어 그대로 가져와본다. 출처는 <a href="https://www.quora.com/Is-there-any-major-difference-between-simultaneous-and-concurrent" target="_blank" rel="noopener">Quora</a>다.</p><p><img src="https://i.imgur.com/2KAJ16s.png" alt="Imgur"></p><h2 id="Go-언어를-만든-Rob-Pike의-강연"><a href="#Go-언어를-만든-Rob-Pike의-강연" class="headerlink" title="Go 언어를 만든 Rob Pike의 강연"></a>Go 언어를 만든 Rob Pike의 강연</h2><p>Rob Pike는 <a href="https://www.youtube.com/watch?v=cN_DpYBzKso" target="_blank" rel="noopener">강연</a>에서 Concurrency와 Parallelism는 다르다며 여러 주옥 같은 표현을 남겼다.</p><blockquote><p>동시성은 독립적인 실행 프로세스의 조합을 의미하고,<br>병렬성은 여러 가지 일을 동시에 실행하는 것을 의미한다.</p><p><code>Concurrency is the composition of independently executing processes.</code><br><code>Parallelism is the simultaneous execution of multiple things.</code></p></blockquote><p>참고로 이 말에 나온 프로세스는 리눅스 프로세스가 아닌 스레드, 코루틴을 포괄하는 일반적인 의미의 프로세스를 의미한다.</p><blockquote><p>동시성은 여러 가지 일을 한 번에 <strong>처리</strong>하는 것을 말하고,<br>병렬성은 여러 가지 일을 한 번에 <strong>수행</strong>하는 것을 말한다.</p><p><code>Concurrency is about **dealing with** lots of things at once.</code><br><code>Parallelism is about **doing** lots of things at once.</code></p></blockquote><p><code>dealing with</code>와 <code>doing</code>이 영어로는 확연하게 대조되지만, 간결함과 글자수 맞춤을 위해 <code>처리</code>와 <code>수행</code>으로 옮겨보면 그 차이가 좀 희석되는 것 같다.<br><code>dealing with</code>에는 설계가 포함되고, <code>doing</code>은 설계된 대로 수행하는 것을 의미한다고 이해하면 크게 틀리지 않을 것 같다.</p><blockquote><p>동시성은 <strong>구조</strong>에 관한 것이고,<br>병렬성은 <strong>실행</strong>에 관한 것이다.</p><p><code>Concurrency is about the **structure**.</code><br><code>Parallelism is about the **execution**.</code></p></blockquote><p>오호 이게 좋다. 영어든 국어든 글자수까지 똑같아서 아름답기까지 하다..<br>이렇게 보면 Parallelism을 병렬성보다는 병행성으로 옮기는 게 더 나은 것 같다.  </p><p>정리하면 Rob Pike는 Concurrency는 설계 쪽에 무게를 두고, Parallelism은 실행 쪽에 무게를 두는 것 같다.</p><h2 id="그림-비교"><a href="#그림-비교" class="headerlink" title="그림 비교"></a>그림 비교</h2><p>간단하게는 썸네일로 사용한 이 그림도 괜찮고,</p><p><img src="https://i.imgur.com/cDdWLKL.jpg" alt="Imgur"></p><p>(출처: <a href="https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism" target="_blank" rel="noopener">https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism</a>)</p><p>다음 그림도 괜찮은 것 같다.</p><p><img src="https://i.imgur.com/uIMnkj1.jpg" alt="Imgur"></p><p>(출처: <a href="https://twitter.com/ohidxy/status/946110898539659264" target="_blank" rel="noopener">https://twitter.com/ohidxy/status/946110898539659264</a>)</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>Concurrency와 Parallelism을 구별할 때 다음과 같은 해석이 도움이 된다.</p><ul><li><p>‘동시’의 차이</p><ul><li>Concurrency에서 말하는 동시성은 사실 상 동시라고 간주해도 되는 시간 간격을 의미</li><li>Parallelism에서 말하는 동시성은 완전히 동일한 시점을 의미</li></ul></li><li><p>작업 독립성의 차이</p><ul><li>Concurrent하게 실행되는 작업은 일반적으로 서로 독립적</li><li>Parallel하게 실행되는 작업은 일반적으로 원래 하나인 작업을 동시에 실행할 수 있도록 분할한 작업을 의미</li></ul></li></ul><p>Go 언어를 만든 Rob Pike에 의하면,</p><ul><li>Concurrency는 독립적인 여러 작업을 한 번에 수행하도록 설계하는 쪽에 무게를 둔 개념</li><li>Parallelism은 하나의 작업을 설계된 대로 분할해서 동시에 수행하는 쪽에 무게를 둔 개념</li></ul><h3 id="참고-자료"><a href="#참고-자료" class="headerlink" title="참고 자료"></a>참고 자료</h3><ul><li><a href="https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/" target="_blank" rel="noopener">https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/</a></li><li><a href="https://www.slideshare.net/PramestiHattaK/golang-101-concurrency-vs-parallelism" target="_blank" rel="noopener">https://www.slideshare.net/PramestiHattaK/golang-101-concurrency-vs-parallelism</a></li><li><a href="http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html</a></li><li><a href="https://www.amazon.com/Reactive-Programming-RxJava-Asynchronous-Applications/dp/1491931655/" target="_blank" rel="noopener">https://www.amazon.com/Reactive-Programming-RxJava-Asynchronous-Applications/dp/1491931655/</a></li></ul><h2 id="추가"><a href="#추가" class="headerlink" title="추가"></a>추가</h2><p>페북에 공유하고 보니 이규원 님으로부터 다음과 같은 아주 쌈박한 의견을 얻을 수 있었다.</p><blockquote><p>Concurrency는 다수의 문제가 동시에 일어난 상황에 대한 것이고,<br>Parallelism은 다수의 문제를 동시에 해결하는 방법에 대한 것입니다.</p></blockquote><p>개인적으로는</p><blockquote><p>Concurrency는 해결해야 할 문제고,<br>Parallelisma은 해결하는 방법이다.</p></blockquote><p>라고 생각해왔는데, 몇 군데 조사해보니 이런 식으로 서술된 게 없어서 아닌가보다.. 하고 Rob Pike의 설명대로 구조 vs 실행에 힘을 실어주고 끝맺었는데, 우군을 얻었으니 Rob Pike와는 조금 다를지라도 다음과 같이 결론낸다.</p><blockquote><p><strong>Concurrency는 동시에 발생한 다수의 일을 처리해야하는 상황을 의미</strong>하고,<br><strong>Parallelism은 다수의 일을 동시에 실행하는 방식을 의미</strong>한다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Back-to-the-Essence-Concurrency-vs-Parallelism&quot;&gt;&lt;a href=&quot;#Back-to-the-Essence-Concurrency-vs-Parallelism&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Concepts" scheme="http://homoefficio.github.io/categories/Concepts/"/>
    
    
      <category term="Concurrency" scheme="http://homoefficio.github.io/tags/Concurrency/"/>
    
      <category term="Parallelism" scheme="http://homoefficio.github.io/tags/Parallelism/"/>
    
      <category term="동시성" scheme="http://homoefficio.github.io/tags/%EB%8F%99%EC%8B%9C%EC%84%B1/"/>
    
      <category term="병렬성" scheme="http://homoefficio.github.io/tags/%EB%B3%91%EB%A0%AC%EC%84%B1/"/>
    
      <category term="병행성" scheme="http://homoefficio.github.io/tags/%EB%B3%91%ED%96%89%EC%84%B1/"/>
    
  </entry>
  
  <entry>
    <title>Back to the Essence - Java 컴파일에서 실행까지 - (2)</title>
    <link href="http://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-2/"/>
    <id>http://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-컴파일에서-실행까지-2/</id>
    <published>2019-01-30T15:20:05.000Z</published>
    <updated>2019-11-23T05:32:21.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Back-to-the-Essence-Java-컴파일에서-실행까지-2"><a href="#Back-to-the-Essence-Java-컴파일에서-실행까지-2" class="headerlink" title="Back to the Essence - Java 컴파일에서 실행까지 - (2)"></a>Back to the Essence - Java 컴파일에서 실행까지 - (2)</h1><p>Java 11 JVM 스펙을 기준으로 Java 소스 코드가 어떻게 컴파일되고 실행되는지 살짝 깊게 알아보자.</p><p>이번엔 2탄 실행 편이다. 1탄 컴파일 편은 <a href="https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-컴파일에서-실행까지-1/">여기</a>에..</p><h1 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h1><p>자바 애플리케이션은 <code>java</code> 명령어로 실행할 수 있다. <a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE" target="_blank" rel="noopener">오라클의 Tools Reference 문서</a>에 나오는 <code>java</code>에 대한 설명은 다음과 같다.</p><blockquote><p><code>java</code> 명령어는 자바 애플리케이션을 시작한다.<br><code>java</code> 명령어는 먼저 JRE(Java Runtime Environment)를 시작하고,<br>인자로 지정된 클래스(<code>public static void main(String[] args)</code>를 포함하고 있는 클래스)를 로딩하고,<br><code>main()</code> 메서드를 호출한다.</p></blockquote><h2 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK, JRE, JVM"></a>JDK, JRE, JVM</h2><p><code>java</code>는 JRE를 시작한다고 하니, JDK, JRE, JVM의 관계를 그림 한 장으로 가볍게 훑고 지나가자.</p><p><img src="https://i.imgur.com/wChPQEV.png" alt="Imgur"></p><ul><li>JDK: 자바 개발 환경 - 컴파일러, 역어셈블러, 디버거, 의존관계분석 등 개발에 필요한 도구 제공</li><li>JRE: 자바 실행 환경 - 자바 실행 명령, 클래스로더와 바이트코드의 실행에 필요한 기본 라이브러리 제공</li><li>JVM: 자바 가상 머신 - 바이트코드 인터프리터, JIT 컴파일러, 링커, 명령어 세트, 가비지 컬렉터, 런타임 데이터 영역(메모리) 등 OS에 독립적으로 실행될 수 있는 추상층 제공</li></ul><p>대략 다음과 같이 정리할 수 있다.</p><blockquote><p>JDK를 사용해서 바이트코드(class 파일)를 만들고, </p><p>JRE를 사용해서 바이트코드를 실행하면,</p><p>JVM이 기동되면서 바이트코드의 실질적인 실행(실제 OS에 메모리 할당/회수, 시스템 명령 호출 등 요청)을 담당한다.</p></blockquote><h2 id="JRE-시작"><a href="#JRE-시작" class="headerlink" title="JRE 시작"></a>JRE 시작</h2><p><code>java</code> 명령 실행에 의해 JRE가 시작된다는 것은 결국 <code>java</code> 명령어의 인자로 지정된 클래스를 실행하기 위한 자바 실행 환경이 조성됨을 의미한다. </p><p><code>java</code> 명령어의 인자로 지정한 설정 옵션에 맞게 JVM이 실행되고, JVM이 클래스로더를 이용해서 <code>initial class</code>를 <code>create</code>하고, <code>initial class</code>를 <code>link</code>하고, <code>initialize</code>하고, main 메서드를 호출한다.(<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.2" target="_blank" rel="noopener">JVM 스펙</a> 참고)</p><h3 id="용어-정리"><a href="#용어-정리" class="headerlink" title="용어 정리"></a>용어 정리</h3><p>몇 가지 용어를 일부러 스펙에 나온 원어 그대로 썼는데 스펙상의 의미는 다음과 같다.</p><ul><li>initial class: JVM 구현에 따라 다를 수 있지만 일반적으로 main 메서드를 포함하는 클래스로서 java 명령어의 인자로 지정되는 클래스 (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.2" target="_blank" rel="noopener">JVM 스펙</a> 참고)</li><li>create (a class or interface): 해당 클래스나 인터페이스의 바이트코드를 로딩해서 JVM이 할당한 메모리(Method Area, 메서드 영역)에 construction하는 것 (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.3" target="_blank" rel="noopener">JVM 스펙</a> 참고)</li><li>link (a class or interface): 해당 클래스나 인터페이스의 바로 위 수퍼클래스나 수퍼인터페이스, 또는 배열일 경우 배열의 원소인 클래스나 인터페이스를 확인(verify)/준비(prepare)하고, 심볼릭 참조를 해석(resolve)해서 JVM에서 실행될 수 있는 상태로 만드는 것 (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4" target="_blank" rel="noopener">JVM 스펙</a> 참고)</li><li>initialize (a class or interface): 해당 클래스나 인터페이스의 class or interface initialization method를 실행하는 것 (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener">JVM 스펙</a> 참고)</li></ul><p>위 설명에는 없지만 중요한 용어인 로딩의 스펙상의 의미는 다음과 같다.</p><ul><li>load (a class or interface): 해당 클래스나 인터페이스의 바이너리 표현을 찾아서 그 바이너리 표현으로부터 클래스나 인터페이스를 생성(create)하는 것 (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html" target="_blank" rel="noopener">JVM 스펙</a> 참고)</li></ul><p>앞으로 <strong>initial class는 시작 클래스</strong>, <strong>create은 생성</strong>, <strong>link는 링크</strong>, <strong>initialize는 초기화</strong>, <strong>load는 로딩</strong>이라고 쓴다. 한 가지 유의할 것은 여기서 말하는 <strong>생성(create)은 JVM의 힙(heap)에 객체를 생성하는 것만을 지칭하는 것이 아니라 JVM의 메모리 어딘가에 자료구조를 생성하는 것을 모두 지칭</strong>한다.</p><h2 id="런타임-데이터-영역"><a href="#런타임-데이터-영역" class="headerlink" title="런타임 데이터 영역"></a>런타임 데이터 영역</h2><p><code>java</code> 명령어로 자바 애플리케이션을 실행하면 JVM이 실행되면서 시작 클래스를 생성, 링크, 초기화하고 main 메서드를 호출한다고 했다. 시작 클래스를 생성한다는 것은 시작 클래스의 바이트코드를 읽어서 JVM의 메모리 어딘가에 쓰는 것을 의미한다. JVM의 메모리는 어떻게 생겼을까?</p><p>JVM은 프로그램의 실행에 사용되는 메모리를 런타임 데이터 영역(Runtime Data Area)이라고 부르는 몇 가지 영역으로 나눠서 관리한다. 스펙의 목차로 보면 밋밋하게 다음과 같이 나열되어 있다.</p><ol><li>PC 레지스터</li><li>JVM 스택</li><li>힙(Heap)</li><li>메서드 영역(Method Area)</li><li>런타임 상수 풀(Run-Time Constnat Pool)</li><li>네이티브 메서드 스택</li></ol><p>이렇게 보면 위 6가지가 동등한 최상위 수준에서 분류되는 것처럼 보인다. 하지만, 실제 스펙의 설명을 보면 다음과 같이 약간 입체적으로 구분하는 것이 더 적합하다.</p><p><img src="https://i.imgur.com/Mh4DuRB.png" alt="Imgur"></p><p>여기서 ‘단위’라는 구분 단계를 추가한 이유는 스펙에도 <code>per-class</code>, <code>per-thread</code> 라는 표현이 나오기 때문인데, 여기에서의 ‘단위’는 생명 주기와 생성 단위를 의미한다.</p><p>JVM 단위에 속하는 <strong>힙과 메서드 영역은 JVM이 시작될 때 생성되고, JVM이 종료될 때 소멸되며, JVM 하나에 힙 하나, 메서드 영역도 하나가 생성</strong> 된다.</p><p>마찬가지로 클래스 단위에 속하는 <strong>런타임 상수 풀은 클래스가 생성/소멸될 때 함께 생성/소멸되며, 클래스 하나에 런타임 상수 풀도 하나가 생성</strong> 된다.</p><p>스레드 단위에 속하는 <strong>PC 레지스터, JVM 스택, 네이티브 메서드 스택도 스레드가 생성/소멸될 때 함께 생성/소멸되며, 스레드 하나에 PC 레지스터, JVM 스택, 네이티브 메서드 스택도 각 하나씩 생성</strong> 된다.</p><p>자. 이제 6가지 영역을 좀 더 자세히 알아보자.</p><p>라고 진행하면 너무 뻔한 나열식이라 머리에 잘 안 남는다. 그러니 다음과 같이 간단한 예제 코드 실행 과정과 함께 살펴보자.</p><h2 id="예제-코드"><a href="#예제-코드" class="headerlink" title="예제 코드"></a>예제 코드</h2><h3 id="자바-소스-코드"><a href="#자바-소스-코드" class="headerlink" title="자바 소스 코드"></a>자바 소스 코드</h3><p>헬로 월드 수준의 단순한 소스 코드다. 힙에서 객체가 생성되는 것을 확인하기 위해 Hello 인스턴스를 만들고 무한루프로 프로그램의 종료를 일부러 막아둔 코드다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.jvm.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Hello hello = <span class="keyword">new</span> Hello();</span><br><span class="line">        System.out.println(hello.helloMessage());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, JVM"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="컴파일된-바이트코드"><a href="#컴파일된-바이트코드" class="headerlink" title="컴파일된 바이트코드"></a>컴파일된 바이트코드</h3><p>컴파일된 바이트코드는 다음과 같다.</p><blockquote><p>javap -v -p -s homo/efficio/jvm/sample/Hello.class</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">$ /c/Program\ Files/Java/jdk-<span class="number">11.0</span>.2/bin/javap -v -p -s homo/efficio/jvm/sample/Hello</span><br><span class="line">Classfile /C:/gitrepo/scratchpad/java-jvm-scratchpad/out/production/java-jvm-scratchpad/homo/efficio/jvm/sample/Hello.class</span><br><span class="line">  Last modified <span class="number">2019</span>. <span class="number">1</span>. <span class="number">30</span>.; size <span class="number">741</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">675e63</span>b96993dc5e661d6566467d92d3</span><br><span class="line">  Compiled from <span class="string">"Hello.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">homo</span>.<span class="title">efficio</span>.<span class="title">jvm</span>.<span class="title">sample</span>.<span class="title">Hello</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">55</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #2                          // homo/efficio/jvm/sample/Hello</span><br><span class="line">  super_class: #8                         // java/lang/Object</span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">0</span>, methods: <span class="number">3</span>, attributes: <span class="number">1</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #8.#26         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #27            // homo/efficio/jvm/sample/Hello</span><br><span class="line">   #3 = Methodref          #2.#26         // homo/efficio/jvm/sample/Hello."&lt;init&gt;":()V</span><br><span class="line">   #4 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #2.#30         // homo/efficio/jvm/sample/Hello.helloMessage:()Ljava/lang/String;</span><br><span class="line">   #6 = Methodref          #31.#32        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #7 = String             #33            // Hello, JVM</span><br><span class="line">   #8 = Class              #34            // java/lang/Object</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               ()V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line">  #16 = Utf8               main</span><br><span class="line">  #17 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               args</span><br><span class="line">  #19 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               hello</span><br><span class="line">  #21 = Utf8               StackMapTable</span><br><span class="line">  #22 = Utf8               helloMessage</span><br><span class="line">  #23 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               SourceFile</span><br><span class="line">  #25 = Utf8               Hello.java</span><br><span class="line">  #26 = NameAndType        #9:#10         // "&lt;init&gt;":()V</span><br><span class="line">  #27 = Utf8               homo/efficio/jvm/sample/Hello</span><br><span class="line">  #28 = Class              #35            // java/lang/System</span><br><span class="line">  #29 = NameAndType        #36:#37        // out:Ljava/io/PrintStream;</span><br><span class="line">  #30 = NameAndType        #22:#23        // helloMessage:()Ljava/lang/String;</span><br><span class="line">  #31 = Class              #38            // java/io/PrintStream</span><br><span class="line">  #32 = NameAndType        #39:#40        // println:(Ljava/lang/String;)V</span><br><span class="line">  #33 = Utf8               Hello, JVM</span><br><span class="line">  #34 = Utf8               java/lang/Object</span><br><span class="line">  #35 = Utf8               java/lang/System</span><br><span class="line">  #36 = Utf8               out</span><br><span class="line">  #37 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #38 = Utf8               java/io/PrintStream</span><br><span class="line">  #39 = Utf8               println</span><br><span class="line">  #40 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> homo.efficio.jvm.sample.Hello();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class homo/efficio/jvm/sample/Hello</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #3                  // Method "&lt;init&gt;":()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">11</span>: aload_1</span><br><span class="line">        12: invokevirtual #5                  // Method helloMessage:()Ljava/lang/String;</span><br><span class="line">        15: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">18</span>: goto          <span class="number">18</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">18</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">21</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">13</span>     <span class="number">1</span> hello   Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">1</span></span><br><span class="line">        frame_type = <span class="number">252</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">18</span></span><br><span class="line">          locals = [ class homo/efficio/jvm/sample/Hello ]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">helloMessage</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #7                  // String Hello, JVM</span><br><span class="line">         <span class="number">2</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">3</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Hello.java"</span></span><br></pre></td></tr></table></figure><p>앞에서 JDK, JRE, JVM 관계로 설명했지만 위와 같은 바이트코드를 만드는 과정까지는 JDK에서 담당한다.</p><p>앞에서 자바 프로그램이 실행되면 다음과 같이 전개된다고 설명했다. </p><blockquote><p><strong>JVM이 실행</strong>되고, JVM이 클래스로더를 이용해서 <strong>시작 클래스를 생성</strong>하고, <strong>링크</strong>하고, <strong>초기화</strong>하고, <strong>main 메서드를 호출</strong>한다.</p></blockquote><p>이제 <code>java homo.efficio.jvm.sample.Hello</code> 명령을 실행하면 어떻게 진행되는지 차근차근 살펴보자.</p><h2 id="JVM-실행"><a href="#JVM-실행" class="headerlink" title="JVM 실행"></a>JVM 실행</h2><p><code>java</code> 명령이 실행되면 JRE가 조성되면서 JVM이 실행된다. JVM이 실행되면 JVM 단위로 생성되는 힙과 메서드 영역이 함께 생성된다.</p><h3 id="힙"><a href="#힙" class="headerlink" title="힙"></a>힙</h3><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5.3" target="_blank" rel="noopener">힙(Heap)</a>은 인스턴스화 된 모든 클래스 인스턴스와 배열을 저장하는 공간</strong>이며, <strong>모든 JVM 스레드에 공유</strong>된다.</p><p>힙에 저장된 객체에 할당된 메모리는 명시적인 방법으로는 절대 회수되지 못하며, 오직 가비지 컬렉터(garbage collector)에 의해서만 회수될 수 있다.</p><p>Hello는 이 시점에서는 아직 인스턴스화 되지 않았으므로 힙은 비어있다.</p><h3 id="메서드-영역"><a href="#메서드-영역" class="headerlink" title="메서드 영역"></a>메서드 영역</h3><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener">메서드 영역(Method Area)</a>은 런타임 상수 풀, 필드와 메서드 데이터, 생성자 및 메서드의 코드 내용을 저장</strong>한다. 저장되는 내용은 위에서 살펴봤던 바이트코드의 내용과 거의 일치한다. 거의라고 얘기하는 이유는 바이트코드에는 런타임 상수 풀이 아니라 그냥 상수 풀(constanta pool)이 포함되어 있기 때문이다. 런타임 상수 풀은 이 상수 풀을 바탕으로 런타임에, 더 구체적으로는 메서드 영역에 저장될 때 만들어진다.</p><p>그래서 엄밀히 말하면 정확하지 않지만, <strong>바이트코드 내용이 메서드 영역에 저장된다</strong>라고 이해해도 크게 틀리지는 않다.</p><p>Hello는 이 시점에서는 아직 생성되지 않았으므로 메서드 영역도 비어있다.</p><p><img src="https://i.imgur.com/KXJsPgs.png" alt="Imgur"></p><p>JVM 스펙은 런타임 데이터 영역을 6가지로 나눠서 설명하고 있고, 그에따라 그림에도 힙과 메서드 영역을 분리해서 표현했지만, 스펙에는 메서드 영역이 논리적으로 힙의 일부지만(그래서 가비지 컬렉션 대상이 되지만), 단순하게는 가비지 컬렉션이나 압축을 하지 않게 구현할 수도 있으며, 스펙은 메서드의 영역의 위치에 대해 강제하지 않는다고 나와 있기도 하다. 결국 메서드 영역의 위치는 JVM 구현체에 따라 달라질 수 있다는 말이다.</p><p>참고로 Java 8 부터 Metaspace가 기존의 PermGen 영역을 대체한다는 자료들이 많이 있는데, JVM 스펙에는 Megaspace라는 용어는 전혀 나오지 않는다. Metaspace는 JVM 구현체인 HotSpot JVM에서 나오는 용어이며, Metaspace에 저장되는 데이터를 기준으로 보면 HotSpot JVM은 JVM 스펙의 메서드 영역을 Metaspace로 구현한 거라고 볼 수 있다.</p><h2 id="시작-클래스-생성"><a href="#시작-클래스-생성" class="headerlink" title="시작 클래스 생성"></a>시작 클래스 생성</h2><p>시작 클래스는 Hello를 지칭하며 시작 클래스를 생성하는 것은 파일시스템에 있는 Hello.class 파일을 JVM의 메서드 영역으로 읽어들이는 것을 의미한다고 했다. 따라서 <strong>이 시점에서 Hello의 바이트코드 내용이 메서드 영역에 저장</strong>된다.</p><p><img src="https://i.imgur.com/QBQyTab.png" alt="Imgur"></p><p>그런데 Hello 클래스는 누가 로딩하는 걸까? 당연하지만 클래스로더가 로딩한다. 그럼 클래스로더는 누가 로딩할까?</p><h3 id="클래스로더"><a href="#클래스로더" class="headerlink" title="클래스로더"></a>클래스로더</h3><p>자바 런타임은 네이티브 코드로 작성된 부트스트랩 클래스로더, 플랫폼 클래스로더, 시스템 클래스로더, 이렇게 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html" target="_blank" rel="noopener">3가지 빌트인(built-in) 클래스로더를 제공</a>한다.</p><p>결론적으로 <strong>Hello 클래스는 시스템 클래스로더가 로딩</strong>하는데, <strong>시스템 클래스로더는 플랫폼 클래스로더가 로딩하고, 플랫폼 클래스로더는 부트스트랩 클래스로더가 로딩하고, 부트스트랩 클래스로더는 <code>java</code> 명령에 의해 JRE가 조성될 때 실행</strong>된다.</p><p>클래스로딩은 <a href="https://homoefficio.github.io/2018/10/13/Java-클래스로더-훑어보기/">Java 클래스로더 훑어보기</a>와 <a href="ttps://homoefficio.github.io/2018/10/14/Java-URLClassLoader로-알아보는-클래스로딩/">Java URLClassLoader로 알아보는 클래스로딩</a>을 참고하자.</p><h3 id="런타임-상수-풀"><a href="#런타임-상수-풀" class="headerlink" title="런타임 상수 풀"></a>런타임 상수 풀</h3><p>클래스가 생성되면 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5.5" target="_blank" rel="noopener">런타임 상수 풀(Run-Time Constant Pool)</a>도 함께 생성된다고 했다. <strong>런타임 상수 풀에는 컴파일 타임에 이미 알 수 있는 숫자 리터럴 값부터 런타임에 해석되는 메서드와 필드의 참조까지를 포괄하는 여러 종류의 상수가 포함</strong>된다. 런타임 상수 풀은 다른 전통적인 언어에서 말하는 심볼 테이블과 비슷한 기능을 한다고 보면 된다.</p><p><img src="https://i.imgur.com/ZtsNYAv.png" alt="Imgur"></p><h2 id="링크"><a href="#링크" class="headerlink" title="링크"></a>링크</h2><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4" target="_blank" rel="noopener">링크</a>는 클래스나 인터페이스의 바로 위 수퍼클래스나 수퍼인터페이스, 또는 배열일 경우 배열의 원소인 클래스나 인터페이스를 확인(verify)/준비(prepare)하고, 심볼릭 참조를 해석(resolve)하는 과정</strong>을 말한다.</p><p>그럼 확인, 준비, 해석은 뭘 의미하는 걸까?</p><h3 id="확인"><a href="#확인" class="headerlink" title="확인"></a>확인</h3><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.1" target="_blank" rel="noopener">확인(verification)</a>은 클래스나 인터페이스의 바이너리 표현이 구조적으로 올바른지를 보장해주는 과정</strong>이다. 확인 과정은 다른 클래스나 인터페이스의 로딩을 유발할 수도 있지만, 로딩된 다른 클래스나 인터페이스의 확인이나 준비를 필수적으로 유발하지는 않는다.</p><p>Hello.class 파일은 JDK에 포함된 공식 컴파일러인 <code>javac</code>에 의해 정상적으로 컴파일되었으므로 구조적으로 올바르다고 가정하면, <strong>확인 과정에서 Hello의 부모 클래스인 Object가 로딩</strong>된다.</p><p><img src="https://i.imgur.com/8f6zqKP.png" alt="Imgur"></p><h3 id="준비"><a href="#준비" class="headerlink" title="준비"></a>준비</h3><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.2" target="_blank" rel="noopener">준비(preperation)</a>는 클래스나 인터페이스의 정적(static) 필드를 생성하고 기본값으로 초기화하는 과정</strong>이다. 준비 과정에서는 JVM 코드의 실행을 필요로 하지 않으며, <strong>기본값이 아닌 특정값으로 정적 필드를 초기화하는 과정은 준비 과정이 아니라 초기화 과정에서 수행</strong>된다.</p><p>스펙에 정의된 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.3" target="_blank" rel="noopener">기본형 타입의 기본값</a>과 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.4" target="_blank" rel="noopener">참조형 타입의 기본값</a>은 다음과 같다.</p><table><thead><tr><th>타입</th><th>기본값</th></tr></thead><tbody><tr><td>byte, short, int, long</td><td>0</td></tr><tr><td>char</td><td>null(<code>&#39;\u0000&#39;</code>)</td></tr><tr><td>float, double</td><td>0(positive zero)</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>참조형</td><td>null</td></tr></tbody></table><p>Hello에는 정적 필드가 없으므로 이 과정에서 특별히 수행되는 것은 없다.</p><h3 id="해석"><a href="#해석" class="headerlink" title="해석"></a>해석</h3><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3" target="_blank" rel="noopener">해석(resolution)</a>은 런타임 상수 풀에 있는 심볼릭 참조가 구체적인 값을 가리키도록 동적으로 결정하는 과정</strong>이다. 초기 상태의 런타임 상수 풀에 있는 심볼릭 참조는 해석되어져 있지 않다.</p><h3 id="링크의-조건"><a href="#링크의-조건" class="headerlink" title="링크의 조건"></a>링크의 조건</h3><p>JVM 스펙에서는 <strong>링크가 언제 수행되어야 하는지는 규정하지 않고 유연하게 구현될 수 있는 여지</strong>를 주고 있다. 단 다음과 같은 조건을 만족해야 한다.</p><ul><li>클래스나 인터페이스는 링크되기 전에 먼저 완전히 로딩되어야 한다.</li><li>클래스나 인스턴스는 초기화되기 전에 먼저 완전히 확인되고 준비되어야 한다.</li><li>링크 관련 에러는 해당 클래스나 인터페이스에 대한 링크를 필요로 하는 행위가 수행되는 시점에 throw 되어야 한다.</li><li>동적으로 계산되는(dynamically-computed) 상수 A에 대한 심볼릭 참조는, A를 참조하는 <code>ldc</code>, <code>ldc_w</code>, <code>ldc2_w</code> 명령어가 실행되거나 A를 정적 인자로 참조하는 부트스트랩 메서드가 호출되기 전까지는 해석되지 않는다.</li><li>동적으로 계산되는(dynamically-computed) call site B에 대한 심볼릭 참조는, B를 정적 인자로 참조하는 부트스트랩 메서드가 호출되기 전까지는 해석되지 않는다.</li></ul><p>일반적으로 만족되어야 하는 것은 1, 2, 3번째 조건이고 4, 5번째는 특수한 경우에 대한 조건이다.</p><p>해석 시점은 JVM 구현체에 따라 다를 수 있다. <strong>지연(lazy) 링크 전략을 사용하면 클래스나 인터페이스에 포함된 심볼릭 참조는 해당 참조가 실제 사용될 때 개별적으로 해석</strong>된다. 반면에 <strong>즉시(eager) 링크 전략을 사용하면 클래스나 인터페이스가 확인될 때 모든 심볼릭 참조가 한꺼번에 해석</strong>된다. 지연 링크를 사용하면 해석 과정은 클래스나 인터페이스가 초기화 된 후에 실행될 수도 있다.</p><p>링크 과정을 정리하면 다음과 같다.</p><blockquote><p>링크는 <strong>확인, 준비, 해석 단계로 구성된다.</strong></p><p><strong>클래스나 인터페이스는 완전히 로딩된 후에 확인과 준비가 수행돼야 하고, 완전히 확인되고 준비된 뒤에 초기화되어야 한다.</strong></p><p><strong>해석은 초기화 이후에 실행될 수도 있다.</strong></p></blockquote><p>스펙을 보면 해석은 다시 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.1" target="_blank" rel="noopener">클래스/인터페이스 해석</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.2" target="_blank" rel="noopener">필드 해석</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.3" target="_blank" rel="noopener">메서드 해석</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.4" target="_blank" rel="noopener">인터페이스 메서드 해석</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.5" target="_blank" rel="noopener">메서드 타입/핸들 해석</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.6" target="_blank" rel="noopener">동적 계산 상수/콜사이트 해석</a>, 이렇게 6가지로 나눠서 자세한 설명이 나와 있으니 관심있다면 찾아보기로 하고 다시 예제로 돌아와 보자. </p><p>Hello의 상수 풀은 다음과 같았다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #8.#26         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #27            // homo/efficio/jvm/sample/Hello</span><br><span class="line">   #3 = Methodref          #2.#26         // homo/efficio/jvm/sample/Hello."&lt;init&gt;":()V</span><br><span class="line">   #4 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #2.#30         // homo/efficio/jvm/sample/Hello.helloMessage:()Ljava/lang/String;</span><br><span class="line">   #6 = Methodref          #31.#32        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #7 = String             #33            // Hello, JVM</span><br><span class="line">   #8 = Class              #34            // java/lang/Object</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               ()V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line">  #16 = Utf8               main</span><br><span class="line">  #17 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               args</span><br><span class="line">  #19 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               hello</span><br><span class="line">  #21 = Utf8               StackMapTable</span><br><span class="line">  #22 = Utf8               helloMessage</span><br><span class="line">  #23 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               SourceFile</span><br><span class="line">  #25 = Utf8               Hello.java</span><br><span class="line">  #26 = NameAndType        #9:#10         // "&lt;init&gt;":()V</span><br><span class="line">  #27 = Utf8               homo/efficio/jvm/sample/Hello</span><br><span class="line">  #28 = Class              #35            // java/lang/System</span><br><span class="line">  #29 = NameAndType        #36:#37        // out:Ljava/io/PrintStream;</span><br><span class="line">  #30 = NameAndType        #22:#23        // helloMessage:()Ljava/lang/String;</span><br><span class="line">  #31 = Class              #38            // java/io/PrintStream</span><br><span class="line">  #32 = NameAndType        #39:#40        // println:(Ljava/lang/String;)V</span><br><span class="line">  #33 = Utf8               Hello, JVM</span><br><span class="line">  #34 = Utf8               java/lang/Object</span><br><span class="line">  #35 = Utf8               java/lang/System</span><br><span class="line">  #36 = Utf8               out</span><br><span class="line">  #37 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #38 = Utf8               java/io/PrintStream</span><br><span class="line">  #39 = Utf8               println</span><br><span class="line">  #40 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>설명의 편의를 위해 즉시 링크 방식으로 해석이 진행된다고 가정하고, 위 상수 풀에서 유도되는 런타임 상수 풀에 있는 심볼릭 참조의 해석 과정을 몇 개만 예로 살펴보자.</p><p><code>#1 = Methodref          #8.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code></p><p>Object 클래스가 확인 과정에서 메서드 영역에 로딩되어 있으므로, 메서드 영역에 저장된 Object 클래스의 바이트코드 내용에서 생성자(<code>&lt;init&gt;</code>)의 위치를 알아낼 수 있고, 그 위치를 <code>Methodref java/lang/Object.&quot;&lt;init&gt;&quot;</code>의 값으로 해석할 수 있다.</p><p><img src="https://i.imgur.com/MAiWMYz.png" alt="Imgur"></p><p><code>#2 = Class              #27            // homo/efficio/jvm/sample/Hello</code></p><p>Hello 인스턴스를 만들 때 필요한 Hello 클래스 정보는 이미 메서드 영역에 로딩되어 있으므로, 메서드 영역 내에서 Hello 클래스의 위치를 <code>Class homo/efficio/jvm/sample/Hello</code>의 값으로 해석할 수 있다.</p><p><img src="https://i.imgur.com/y0qP8vW.png" alt="Imgur"></p><p><code>#3</code>은 Hello 생성자를 가리키는 Methodref 항목인데, Methodref의 해석 과정은 앞의 <code>#1</code>에서 이미 다뤘으므로 설명은 생략하고 그림만 보자.</p><p><img src="https://i.imgur.com/XBMPitk.png" alt="Imgur"></p><p><code>#4 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</code></p><p>System 클래스는 아직 로딩되어 있지 않으므로 먼저 로딩하고, 확인 후 준비 과정을 거치면서 System 클래스의 정적 필드인 <code>out</code>의 타입인 PrintStream 클래스도 로딩되고 참조형 변수인 <code>out</code>은 기본값인 null 로 초기화 된다.</p><p><img src="https://i.imgur.com/RJ3ZLvX.png" alt="Imgur"></p><p>대략 이런 식으로 로딩-링크 과정이 연쇄적으로 수행되면서 메서드 영역이 채워지고, 메서드 영역 내에서 클래스 단위로 생성되는 런타임 상수 풀 안에 있는 심볼릭 참조가 가리키는 값들이 결정된다.</p><p>하지만 이것도 위에 썼듯이 즉시 링크 방식일 때의 얘기고, <strong>지연 링크를 사용한다면 각 클래스의 초기화가 수행된 이후에 해석 과정이 수행</strong>될 수도 있다.</p><p>그럼 이제 초기화를 알아볼 차례다.</p><h2 id="초기화"><a href="#초기화" class="headerlink" title="초기화"></a>초기화</h2><p>초기화(initialization)는 <code>클래스 또는 인터페이스 초기화 메서드(class or interface initialization method)</code>를 실행할 때 수행되는 과정이다. 쉽게 말하면 <strong>여기에서 말하는 초기화는 정적 초기화(static initialization)를 말한다</strong>고 볼 수 있다.</p><p>그럼 초기화 메서드는 무엇일까?</p><h3 id="초기화-메서드"><a href="#초기화-메서드" class="headerlink" title="초기화 메서드"></a>초기화 메서드</h3><p>초기화 메서드(initialization method)는 두 가지가 있다.</p><h4 id="인스턴스-초기화-메서드"><a href="#인스턴스-초기화-메서드" class="headerlink" title="인스턴스 초기화 메서드"></a>인스턴스 초기화 메서드</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.9.1" target="_blank" rel="noopener">인스턴스 초기화 메서드</a>는 자바 언어로 작성되는 생성자에 해당하며, 클래스는 0개 이상의 인스턴스 초기화 메서드를 가진다. <code>인스턴스 초기화 메서드</code>는 다음의 조건을 모두 충족해야 한다.</p><ul><li>(인터페이스가 아니고) 클래스 안에 정의된다.</li><li>(바이트코드 상에서) <code>&lt;init&gt;</code>라는 특수한 이름으로 표현된다.</li><li>반환 타입은 void</li></ul><p><code>인스턴스 초기화 메서드</code>는 생성자로서 힙에 인스턴스를 생성하는 역할을 담당하며, 이름에 초기화라는 용어가 들어가지만 여기에서 말하는 초기화와는 좀 다른 개념이고, 실제 스펙에서도 초기화는 (인스턴스 초기화 메서드를 배제하고) <code>class or interface initialization method(클래스 또는 인터페이스 초기화 메서드)</code>를 호출한다고 명시되어 있다. (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener">JVM 스펙</a>에 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.9.2" target="_blank" rel="noopener">2.9.2</a> 라고 따로 명기)</p><h4 id="클래스-초기화-메서드-클래스-또는-인터페이스-초기화-메서드"><a href="#클래스-초기화-메서드-클래스-또는-인터페이스-초기화-메서드" class="headerlink" title="클래스 초기화 메서드(클래스 또는 인터페이스 초기화 메서드)"></a>클래스 초기화 메서드(클래스 또는 인터페이스 초기화 메서드)</h4><p>앞에서 링크 과정의 준비 단계 설명에 초기화가 잠시 언급된 적이 있다.<br><strong>정적 필드를 기본값으로 초기화 하는 것은 링크의 준비 단계에서 수행</strong>되고, <strong>정적 필드를 특정값으로 초기화 하는 것은 초기화 단계에서 수행</strong>된다고 했는데, 지금 설명하고 있는 이 <code>클래스 또는 인터페이스 초기화 메서드</code>가 실행되는 것이 초기화 단계다.</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.9.2" target="_blank" rel="noopener">클래스 또는 인터페이스 초기화 메서드</a>는 클래스나 인터페이스에(클래스나 인터페이스의 바이트코드에) 1개만 존재할 수 있으며, 다음의 조건을 모두 충족해야 한다.</p><ul><li>(바이트코드 상에서) <code>&lt;clinit&gt;</code>라는 특수한 이름으로 표현된다.</li><li>반환 타입은 void</li><li>class 파일 버전 51 이상에서는 <code>ACC_STATIC</code> 플래그가 붙는다.</li></ul><p>인스턴스 초기화 메서드는 생성자에 해당한다는 명확하고 직관적인 설명이 스펙에 있는데, <code>클래스 또는 인터페이스 초기화 메서드</code>는 아쉽게도 뭐에 해당하는지 스펙에는 구체적인 설명이 없다.</p><p>그래서 몇 가지 테스트를 해 본 결과 <strong>클래스 초기화 메서드는 쉽게 말해 static 블록(들)의 내용을 하나로 합친 것</strong>이라고 볼 수 있다. 이건 말보다 코드가 훨씬 쉬우니 코드로 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.jvm.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        j = <span class="number">22</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴파일한 후 <code>javap -v -p -s homo.efficio.jvm.sample.StaticInitSample</code> 명령으로 바이트코드를 살펴보면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">homo</span>.<span class="title">efficio</span>.<span class="title">jvm</span>.<span class="title">sample</span>.<span class="title">StaticInitSample</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#19         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #4.#20         // homo/efficio/jvm/sample/StaticInitSample.i:I</span><br><span class="line">   #3 = Fieldref           #4.#21         // homo/efficio/jvm/sample/StaticInitSample.j:I</span><br><span class="line">   #4 = Class              #22            // homo/efficio/jvm/sample/StaticInitSample</span><br><span class="line">   #5 = Class              #23            // java/lang/Object</span><br><span class="line">   #6 = Utf8               i</span><br><span class="line">   #7 = Utf8               I</span><br><span class="line">   #8 = Utf8               j</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               ()V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lhomo/efficio/jvm/sample/StaticInitSample;</span><br><span class="line">  #16 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #17 = Utf8               SourceFile</span><br><span class="line">  #18 = Utf8               StaticInitSample.java</span><br><span class="line">  #19 = NameAndType        #9:#10         // "&lt;init&gt;":()V</span><br><span class="line">  #20 = NameAndType        #6:#7          // i:I</span><br><span class="line">  #21 = NameAndType        #8:#7          // j:I</span><br><span class="line">  #22 = Utf8               homo/efficio/jvm/sample/StaticInitSample</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> homo.efficio.jvm.sample.StaticInitSample();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lhomo/efficio/jvm/sample/StaticInitSample;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">11</span></span><br><span class="line">         2: putstatic     #2                  // Field i:I</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">22</span></span><br><span class="line">         7: putstatic     #3                  // Field j:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"StaticInitSample.java"</span></span><br></pre></td></tr></table></figure><p>상수 풀의 16번째 항목에 <code>#16 = Utf8               &lt;clinit&gt;</code>가 1개 있고, 아래 코드 내용의 <code>static {};</code> 아래 부분에 i를 1로, j를 2로 초기화 하는 부분이 소스코드에는 별개의 static 블록에 있었는데 바이트코드에서는 하나로 합쳐저 있음을 확인할 수 있다.</p><h3 id="초기화-정리"><a href="#초기화-정리" class="headerlink" title="초기화 정리"></a>초기화 정리</h3><p>링크 단계 다음에 수행되는 초기화 단계를 정리해보면 다음과 같다.</p><blockquote><p><strong>초기화는 바이트코드에서 <code>&lt;clinit&gt;</code>으로 표시되는 <code>클래스 또는 인터페이스 초기화 메서드</code>(자바 소스 코드의 static 블록을 하나로 합친 것)를 실행하는 것</strong>을 의미한다.</p><p><strong>링크 단계 이후에 수행되는 초기화란 결국 정적 초기화를 의미</strong>한다.</p></blockquote><p>다시 원래의 예제 코드인 Hello로 돌아와보자. Hello에는 정적 필드가 없으므로 초기화 과정에서 따로 수행되는 것은 없다. 초기화 과정까지 마쳤으면 이제 드디어 JVM에 의해 main 메서드가 호출될 차례다.</p><h1 id="main-메서드-호출"><a href="#main-메서드-호출" class="headerlink" title="main 메서드 호출"></a>main 메서드 호출</h1><p>앞서 설명한 로딩, 링크, 초기화 과정은 바이트코드 내용 기준, 즉 클래스 단위의 정적인 준비를 다뤘는데, main 메서드 호출부터는 실제 프로그램의 동적인 실행이 일어난다. 프로그램이 실행되려면 프로그램 흐름의 최소 단위인 스레드가 있어야 한다. <strong>JVM이 main 메서드 호출을 위한 main 스레드를 생성</strong>한다. </p><h2 id="main-스레드-생성"><a href="#main-스레드-생성" class="headerlink" title="main 스레드 생성"></a>main 스레드 생성</h2><p><strong>스레드가 생성되면 PC 레지스터, JVM 스택, 네이티브 메서드 스택이 함께 생성</strong>되고, 런타임 데이터 영역은 대략 다음과 같아진다.</p><p><img src="https://i.imgur.com/izWNxMs.png" alt="Imgur"></p><h2 id="PC-Register"><a href="#PC-Register" class="headerlink" title="PC Register"></a>PC Register</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5.1" target="_blank" rel="noopener">PC 레지스터</a>에는 현재 실행 중인 메서드가 </p><ul><li>네이티브 메서드가 아니면 <strong>현재 실행 중인 JVM 명령어의 위치가 저장</strong>되고, </li><li>네이티브 메서드이면 PC 레지스터에 저장되는 값은 정의되지 않는다(undefined).</li></ul><h2 id="JVM-Stack"><a href="#JVM-Stack" class="headerlink" title="JVM Stack"></a>JVM Stack</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5.2" target="_blank" rel="noopener">JVM 스택</a>은 LIFO(Last In First Out) 방식으로 동작하는 자료구조서 <strong>JVM 스택에는 프레임이 저장</strong>된다.</p><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><p>JVM 스택에 쌓이는 정보의 단위가 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">프레임(Frame)</a>이다. 프레임은 데이터나 중간 결과의 저장, 동적 링크, 값 반환, 예외 디스패치에 사용된다.</p><p><strong>메서드 하나가 호출될 때마다 새 프레임이 생성되어 스택에 쌓이고, 메서드 호출이 정상 완료되거나 예외가 던져지면 프레임은 스택에서 빠지면서 소멸된다.</strong></p><p><strong>프레임은 로컬 변수 배열, 오퍼랜드 스택, 프레임에 해당하는 메서드가 속한 클래스의 런타임 상수 풀에 대한 참조 이렇게 3개의 자료구조로 구성</strong>된다.</p><p><img src="https://i.imgur.com/t1MmhAk.png" alt="Imgur"></p><h4 id="Local-Variables"><a href="#Local-Variables" class="headerlink" title="Local Variables"></a>Local Variables</h4><p>프레임은 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.6.1" target="_blank" rel="noopener">로컬 변수 배열(Local Variables</a>을 하나 가지고 있다. 로컬 변수 배열의 크기는 컴파일 타임에 결정되며 바이트코드의 <code>Code</code> 속성에 <code>locals</code>으로 표시된다.</p><p><code>boolean</code>, <code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>reference</code>, <code>returnAddress</code>는 배열의 1개의 슬롯에 저장되고, <code>long</code>과 <code>double</code>은 2개의 슬롯에 걸쳐 저장된다.</p><p>메서드가 호출될 때 그 <strong>메서드의 파라미터 값은 로컬 변수 배열을 통해 넘겨진다.</strong></p><ul><li>메서드가 <strong>클래스 메서드이면 첫 번째 파라미터는 0번 슬롯에 두 번째 파라미터는 1번 슬롯에 차례대로 저장</strong>되고, </li><li>메서드가 <strong>인스턴스 메서드이면 <code>this</code>가 0번 슬롯에 먼저 저장되고, 첫 번째 파라미터는 1번 슬롯에, 두 번째 파라미터는 2번 슬롯에 차례대로 저장</strong>된다.</li></ul><p>파이썬은 인스턴스 메서드 호출 시 첫 인자로 <code>self</code>를 항상 넘겨주는데, 자바에서는 소스 코드에 직접 명시하지 않아도 컴파일러가 바이트코드를 생성할 때 <code>this</code>에 대한 심볼릭 참조를 로컬 변수 배열의 0번 슬롯에 넣어준다. 바이트코드의 <code>Code</code> 속성으로 표시되는 메서드의 바이트코드를 보면 다음과 같이 <code>LocalVariableTable</code>에 <code>this</code>에 대한 정보가 표시되는 것을 볼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> homo.efficio.jvm.sample.Hello();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lhomo/efficio/jvm/sample/Hello;  <span class="comment">// &lt;== 여기!!</span></span><br></pre></td></tr></table></figure><h4 id="Operand-Stack"><a href="#Operand-Stack" class="headerlink" title="Operand Stack"></a>Operand Stack</h4><p><strong>프레임은 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.6.2" target="_blank" rel="noopener">오퍼랜드 스택(Operand Stack)</a>을 하나 가지고 있다.</strong> 오퍼랜드 스택의 최대 깊이는 컴파일 타임에 결정되며 바이트코드의 <code>Code</code> 속성에 <code>stack</code>으로 표시된다.</p><p>오퍼랜드 스택은 프레임이 생성될 때는 비어있다. 오퍼랜드 스택에 상수, 로컬 변수, 필드를 쌓는 명령어와 오퍼랜드 스택에서 값을 꺼내서 연산을 하고 다시 스택에 넣는 명령어는 JVM 명령어로 제공되며 그 중에서 Hello 예제 코드에 사용된 JVM 명령어에 대한 설명은 앞으로 차차 알아보기로 하자. </p><p>메서드에 전달되는 파라미터를 준비하거나 메서드가 반환해주는 결과값을 받을 때도 오퍼랜드 스택이 사용되며 <strong>단순하게 표현하면 값을 가져오고 넘겨주는 거의 모든 과정에 오퍼랜드 스택이 사용된다고 볼 수 있다.</strong></p><h4 id="Reference-to-Run-Time-Constant-Pool"><a href="#Reference-to-Run-Time-Constant-Pool" class="headerlink" title="Reference to Run-Time Constant Pool"></a>Reference to Run-Time Constant Pool</h4><p>런타임 상수 풀에 대한 참조는 말 그대로 <strong>해당 프레임에 대응되는 메서드가 속한 클래스의 런타임 상수 풀에 대한 참조</strong>를 의미한다.<br>스펙에서 별도의 항목으로 기술되어 있지는 않고, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">프레임의 설명 부분에서 언급</a>되고 있다.</p><p>하나의 스레드에서 여러 인스턴스의 메서드를 실행할 수 있고, 그때마다 프레임이 생성되어 JVM 스택에 쌓이고, <strong>프레임에서 해당 클래스의 런타임 상수 풀에 있는 정보를 사용하려면 이 참조가 있어야 한다.</strong></p><p>위 그림에서는 하나의 예로 Hello 클래스의 런타임 상수 풀을 가리키도록 표현했을 뿐이고, 프레임에 따라 각각 다른 클래스의 런타임 상수 풀을 가리키게 된다.</p><h2 id="Native-Method-Stack"><a href="#Native-Method-Stack" class="headerlink" title="Native Method Stack"></a>Native Method Stack</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5.6" target="_blank" rel="noopener">네이티브 메서드 스택(Native Method Stack)</a>은 JVM 스택이 아닌 보통 C 스택이라고 부르는 전통적인 스택이며, 자바가 아닌 다른 언어로 작성된 네이티브 메서드를 지원하기 위해 사용되는 스택이다. 네이티브 메서드 스택은 JVM 스택과 마찬가지로 스레드 단위의 자료구조다.</p><p>JVM이 반드시 네이티브 메서드를 지원해야 하는 것은 아니므로 네이티브 메서드 스택 역시 필수는 아니다. </p><h2 id="main-메서드-호출-1"><a href="#main-메서드-호출-1" class="headerlink" title="main 메서드 호출"></a>main 메서드 호출</h2><p>이제 JVM의 런타임 데이터 영역을 구성하는 요소들에 대한 정적인 설명을 모두 알아봤으므로 실제 main 메서드 호출과 함께 변화 과정을 동적으로 알아보자.</p><p>main 메서드의 바이트코드는 다음과 같다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">       0: new           #2                  // class homo/efficio/jvm/sample/Hello</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokespecial #3                  // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       8: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">11</span>: aload_1</span><br><span class="line">      12: invokevirtual #5                  // Method helloMessage:()Ljava/lang/String;</span><br><span class="line">      15: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">18</span>: goto          <span class="number">18</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">7</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">8</span>: <span class="number">18</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">21</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">          <span class="number">8</span>      <span class="number">13</span>     <span class="number">1</span> hello   Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">1</span></span><br><span class="line">      frame_type = <span class="number">252</span> <span class="comment">/* append */</span></span><br><span class="line">        offset_delta = <span class="number">18</span></span><br><span class="line">        locals = [ class homo/efficio/jvm/sample/Hello ]</span><br></pre></td></tr></table></figure><p>오퍼랜드 스택의 최대 크기는 2, 로컬 변수 배열 크기는 2, 인자 갯수는 1이다.</p><p>main 메서드가 호출되면 다음과 같이 <code>main 메서드 프레임</code>이 생성된다. 오퍼랜드 스택과 로컬 변수 배열은 비어있는 상태이고, 런타임 상수 풀에 대한 참조는 Hello 클래스의 런타임 상수 풀을 가리킨다. </p><p>오퍼랜드 스택은 최대 크기가 2이고 아직 아무 것도 쌓여있지 않은 상태이므로 점선으로 표시했고, 로컬 변수 배열은 안에 값은 없지만 2개의 슬롯이 확정적으로 만들어져있으므로 실선으로 표시했다.</p><p><img src="https://i.imgur.com/O7LRpA6.png" alt="Imgur"></p><h3 id="0-new-2-class-homo-efficio-jvm-sample-Hello"><a href="#0-new-2-class-homo-efficio-jvm-sample-Hello" class="headerlink" title="0: new #2  // class homo/efficio/jvm/sample/Hello"></a><code>0: new #2  // class homo/efficio/jvm/sample/Hello</code></h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.new" target="_blank" rel="noopener"><code>new</code></a>는 인자로 지정된 클래스의 새 인스턴스에 필요한 메모리를 힙 안에 할당하고, 할당된 위치를 가리키는 참조를 오퍼랜드 스택에 쌓는다. 이 때 인스턴스 변수들이 기본값으로 초기화 된다. 참고로 인스턴스 변수가 아닌 정적 변수는 앞서 초기화 과정에서 이미 특정값으로 초기화 되어 있는 상태다.</p><p>Hello 클래스의 새 인스턴스에 필요한 메모리를 할당하고 그 위치에 대한 참조를 오퍼랜드 스택에 쌓는다. (파란색 동그라미)</p><p><img src="https://i.imgur.com/e6u8VRO.png" alt="Imgur"></p><h3 id="3-dup"><a href="#3-dup" class="headerlink" title="3: dup"></a><code>3: dup</code></h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.dup" target="_blank" rel="noopener"><code>dup</code></a>은 오퍼랜드 스택 맨 위에 있는 값을 복사해서 오퍼랜드 스택 맨 위에 쌓는다.(초록색 동그라미)</p><p><img src="https://i.imgur.com/Ve6moKN.png" alt="Imgur"></p><h3 id="4-invokespecial-3-Method-quot-lt-init-gt-quot-V"><a href="#4-invokespecial-3-Method-quot-lt-init-gt-quot-V" class="headerlink" title="4: invokespecial #3  // Method &quot;&lt;init&gt;&quot;:()V"></a><code>4: invokespecial #3  // Method &quot;&lt;init&gt;&quot;:()V</code></h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.invokespecial" target="_blank" rel="noopener"><code>invokespecial</code></a>은 다음과 같이 생성자, 현재 클래스, 수퍼클래스의 메서드를 호출한다고 나와 있다. </p><blockquote><p>invokespecial</p><p>Operation<br> Invoke instance method; direct invocation of instance initialization methods and methods of the current class and its supertypes</p></blockquote><p>그래서 private 메서드를 호출할 때 <code>invokespecial</code>이 사용된다고 써있는 자료도 흔히 볼 수 있는데, 막상 <code>javac</code>, <code>javap</code>로 확인해보면 현실은 좀 다르다. 대부분 생성자와 수퍼클래스의 생성자를 호출할 때 <code>invokespecial</code>이 사용되고, 상속받은 클래스에서 수퍼클래스의 메서드를 호출할 때와, 같은 클래스 내의 다른 private 인스턴스 메서드를 호출할 때는 <code>invokevirtual</code>이 사용된다. </p><p><code>invokespecial</code>로 특정 메서드가 호출되면 프레임과 로컬 변수 배열, 오퍼랜드 스택, 런타임 상수 풀에 대한 참조가 생겨난다. 호출하는 쪽의 오퍼랜드 스택에서 호출되는 메서드의 파라미터 갯수 + 1개 만큼 호출하는 쪽의 오퍼랜드 스택에서 값을 꺼내서 호출되는 쪽에 새로 생성된 로컬 변수 배열의 0번 슬롯까지 채워지도록 뒤에서부터 차례로 채운다.</p><p>글로는 복잡하니 그림으로 보자. 새로 호출하는 메서드의 파라미터가 2개라면 다음과 같이 진행된다. 먼저 호출하기 전 상태는 다음과 같다.</p><p><img src="https://i.imgur.com/jQIe28m.png" alt="Imgur"></p><p>파라미터 2개 있는 메서드를 호출하면 다음과 같이 새로 프레임이 생성되고, 호출하는 쪽의 오퍼랜드 스택에서 2 + 1인 3개의 값이 차례로 꺼내져서, 호출되는 쪽의 로컬 변수 배열의 2, 1, 0번 슬롯에 차례로 저장된다.</p><p><img src="https://i.imgur.com/YJBfT4H.png" alt="Imgur"></p><p>파라미터 갯수인 2개 외에 마지막에 추가로 하나 더 꺼내져서 호출되는 프레임의 로컬 변수 배열 0번 슬롯에 저장되는 값(초록색 동그라미)은 스펙에 <code>objectref</code>라고 표현되어 있으며 반드시 참조값이어야 한다.</p><p>지금 설명한 호출하는 쪽의 프레임의 오퍼랜드 스택에서 값을 꺼내서 호출되는 쪽의 프레임의 로컬 변수 배열에 저장하는 방식은 <code>invokespecial</code> 뿐 아니라 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.7.invokevirtual" target="_blank" rel="noopener"><code>invokevirtual</code></a>에도 공히 적용되는 방식이다.</p><p>스택 맨 위에 있는 Hello 인스턴스에 대한 참조(초록색 동그라미)를 꺼내서 Hello 클래스의 디폴트 생성자의 첫 번째 인자로 넘기면서 디폴트 생성자를 호출한다. Hello 클래스의 디폴트 생성자에 대한 프레임(<code>Hello 생성자 프레임</code>)이 새로 생성되고 JVM 스택의 맨 위(<code>main 메서드 프레임</code> 위)에 쌓인다. <code>Hello 생성자 프레임</code> 안에 있는 로컬 변수 배열의 0번 슬롯에 새 Hello 인스턴스에 대한 참조가 저장된다. </p><p><img src="https://i.imgur.com/jvvanVL.png" alt="Imgur"></p><p>Hello 생성자의 바이트코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> homo.efficio.jvm.sample.Hello();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lhomo/efficio/jvm/sample/Hello;</span><br></pre></td></tr></table></figure><p><code>Code</code> 속성 바로 아래줄에 <code>stack=1, locals=1, args_size=1</code>라고 되어 있는데, <code>Hello 생성자 프레임</code>의 오퍼랜드 스택 최대 깊이는 1, 로컬 변수 배열의 크기는 1, 인자의 갯수는 1개로 되어 있다. 오퍼랜드 스택 최대 깊이와 로컬 변수 배열의 크기는 위 그림에 적용되어 있다.</p><p>Hello 생성자 프레임이 생성되면 가장 위에 있는 명령어인 <code>aload_0</code>이 먼저 실행된다.</p><h4 id="0-aload-0"><a href="#0-aload-0" class="headerlink" title="0: aload_0"></a><code>0: aload_0</code></h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.aload_n" target="_blank" rel="noopener"><code>aload_n</code></a>은 로컬 변수 배열의 <code>n</code>번 슬롯에 저장된 참조값(load 앞에 붙은 <code>a</code>가 참조값을 의미)을 오퍼랜드 스택 맨 위에 쌓는다.</p><p><code>Hello 생성자 프레임</code>의 로컬 변수 배열의 0번 슬롯에 저장되어 있던 새 Hello 인스턴스에 대한 참조(초록색 동그라미)가 <code>Hello 생성자 프레임</code>의 오퍼랜드 스택에 쌓인다.</p><p><img src="https://i.imgur.com/zP0BaqB.png" alt="Imgur"></p><h4 id="1-invokespecial-1-Method-java-lang-Object-quot-lt-init-gt-quot-V"><a href="#1-invokespecial-1-Method-java-lang-Object-quot-lt-init-gt-quot-V" class="headerlink" title="1: invokespecial #1  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V"></a><code>1: invokespecial #1  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code></h4><p><code>invokespecial</code> 명령어에 대한 설명은 앞에서 알아봤으므로 생략한다. </p><p>Object의 생성자를 호출하면 힙에 Object의 새 인스턴스를 위한 메모리가 할당되고, <code>Object 생성자 프레임</code>이 생성된다.</p><p><code>Hello 생성자 프레임</code>의 오퍼랜드 스택 맨 위에 있던 <code>this</code>(초록색 동그라미)가 꺼내지고 새로 생성된 <code>Object 생성자 프레임</code>의 로컬 변수 배열의 0번 슬롯에 저장(초록색 동그라미)된다.</p><p><img src="https://i.imgur.com/Dw4W7or.png" alt="Imgur"></p><p>Object의 생성자의 바이트코드는 다음과 같다.</p><blockquote><p>javap -v -p -s java.lang.Object</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.Object();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">50</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ljava/lang/Object;</span><br><span class="line">  RuntimeVisibleAnnotations:</span><br><span class="line">    0: #27()</span><br><span class="line">      jdk.internal.HotSpotIntrinsicCandidate</span><br></pre></td></tr></table></figure><p>설명하는 입장에서 매우 다행스럽게도 그냥 <code>4: return</code> 하는 것이 전부다. <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.return" target="_blank" rel="noopener"><code>return</code></a>은 void를 반환하며, 오퍼랜드 스택에 있던 모든 값이 전부 폐기되고 <code>Object 생성자 프레임</code>도 폐기되고, 호출한 메서드의 프레임인 <code>Hello 생성자 프레임</code>으로 제어가 넘어간다.</p><p><img src="https://i.imgur.com/1XJNvOY.png" alt="Imgur"></p><p>Hello의 디폴트 생성자의 바이트코드에서 남은 것은 <code>return</code>뿐이다. 따라서 Hello의 디폴트 생성자 실행이 완료되면 <code>Hello 생성자 프레임도 폐기</code>되고 다음과 같이 <code>main 메서드 프레임</code>의 오퍼랜드 스택에는 아래와 같이 새로 생성 및 초기화된 Hello 인스턴스에 대한 참조만 남게 된다.</p><p><img src="https://i.imgur.com/lEsyaU9.png" alt="Imgur"></p><h3 id="7-astore-1"><a href="#7-astore-1" class="headerlink" title="7: astore_1"></a><code>7: astore_1</code></h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.astore_n" target="_blank" rel="noopener"><code>astore_n</code></a>은 오퍼랜드 스택의 맨 위에 있는 값을 꺼내서 로컬 변수 배열의 <code>n</code> 위치에 저장한다. </p><p>현재 <code>main 메서드 프레임</code>의 오퍼랜드 스택 맨 위에 있는 값인 새 Hello 인스턴스에 대한 참조(<code>this</code>)를 꺼내서 <code>main 메서드 프레임</code>의 로컬 변수 배열의 1번 슬롯에 넣는다.</p><p>결국 로컬 변수에 뭔가 저장하는 것인데 자바 소스 코드의 <code>final Hello hello = new Hello();</code>에 해당한다.</p><p><img src="https://i.imgur.com/ZOUyk7M.png" alt="Imgur"></p><h3 id="8-getstatic-4-Field-java-lang-System-out-Ljava-io-PrintStream"><a href="#8-getstatic-4-Field-java-lang-System-out-Ljava-io-PrintStream" class="headerlink" title="8: getstatic #4  // Field java/lang/System.out:Ljava/io/PrintStream;"></a><code>8: getstatic #4  // Field java/lang/System.out:Ljava/io/PrintStream;</code></h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.getstatic" target="_blank" rel="noopener"><code>getstatic</code></a>은 클래스의 정적(static) 필드 값을 가져와서 오퍼랜드 스택에 쌓는다.</p><p>여기에서는 System 클래스의 정적 변수인 out의 값을 System의 런타임 상수 풀에서 읽어서 <code>main 메서드 프레임</code>의 오퍼랜드 스택에 쌓는다. (초록색 동그라미)</p><p><img src="https://i.imgur.com/guTnj4t.png" alt="Imgur"></p><h3 id="11-aload-1"><a href="#11-aload-1" class="headerlink" title="11: aload_1"></a><code>11: aload_1</code></h3><p><code>aload_1</code>은 <code>main 메서드 프레임</code>의 로컬 변수 배열 1번 슬롯에 있던 값을 <code>main 메서드 프레임</code>의 오퍼랜드 스택에 쌓는다. (파란색 동그라미)</p><p><img src="https://i.imgur.com/fU90B7m.png" alt="Imgur"></p><h3 id="12-invokevirtual-5-Method-helloMessage-Ljava-lang-String"><a href="#12-invokevirtual-5-Method-helloMessage-Ljava-lang-String" class="headerlink" title="12: invokevirtual #5  // Method helloMessage:()Ljava/lang/String;"></a><code>12: invokevirtual #5  // Method helloMessage:()Ljava/lang/String;</code></h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.invokevirtual" target="_blank" rel="noopener"><code>invokevirtual</code></a>은 자바 메서드 호출의 기본 방식이며, 객체 참조(obj.)를 붙여서 호출되는 일반적인 메서드를 호출한다. 해당 메서드가 속한 인스턴스를 가리키는 참조가 첫 번째 파라미터로 넘겨진다. 호출에 의해 새 프레임이 생성되고 로컬 변수 배열의 0번 슬롯에 첫 번째 인자로 넘어온 값인 해당 메서드가 속한 인스턴스를 가리키는 참조가 저장되고 그 이후의 인자도 로컬 변수 배열에 순서대로 저장된다. 앞에서 <code>invokespecial</code>에 나왔던 그림 설명을 참고한다.</p><p><code>helloMessage()</code>의 바이트코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">helloMessage</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()Ljava/lang/String;</span><br><span class="line">  flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       0: ldc           #7                  // String Hello, JVM</span><br><span class="line">       <span class="number">2</span>: areturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">3</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lhomo/efficio/jvm/sample/Hello;</span><br></pre></td></tr></table></figure><p><code>helloMessage()</code>가 호출되면 <code>helloMessage 메서드 프레임</code>이 새로 생성되고, <code>main 메서드 프레임</code>의 오퍼랜드 스택 맨 위에 있던 값(파란 동그라미)이 꺼내져서 <code>helloMessage 메서드 프레임</code>의 로컬 변수 배열 0번 슬롯에 저장된다.</p><p><img src="https://i.imgur.com/ZbJ4ISa.png" alt="Imgur"></p><h4 id="0-ldc-7-String-Hello-JVM"><a href="#0-ldc-7-String-Hello-JVM" class="headerlink" title="0: ldc #7  // String Hello, JVM"></a><code>0: ldc #7  // String Hello, JVM</code></h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.ldc" target="_blank" rel="noopener"><code>ldc</code></a>는 런타임 상수 풀의 항목 하나를 오퍼랜드 스택의 맨 위에 쌓는다.</p><p>Hello 클래스의 런타임 상수 풀의 7번 항목인 문자열 리터럴 <code>&quot;Hello, JVM&quot;</code>에 대한 참조를 <code>helloMessage 메서드 프레임</code>의 오퍼랜드 스택 맨 위에 쌓는다.</p><p>문자열 리터럴이 저장되는 문자열 풀(String pool)은 JVM 스펙을 뒤져봤으나 찾을 수 없었다. <a href="http://java-performance.info/string-intern-in-java-6-7-8/" target="_blank" rel="noopener">http://java-performance.info/string-intern-in-java-6-7-8/</a> 에 따르면 문자열 풀은 Java 6까지는 힙이 아닌 PermGen 영역에 있었지만, Java 7부터 힙에 존재한다고 한다.</p><p>따라서 스펙에서 확인한 내용은 아니지만 Java 11에서도 문자열 풀은 힙에 존재한다고 보면 다음과 같이 표현할 수 있다.</p><p><img src="https://i.imgur.com/NCga0nz.png" alt="Imgur"></p><h4 id="2-areturn"><a href="#2-areturn" class="headerlink" title="2: areturn"></a><code>2: areturn</code></h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.areturn" target="_blank" rel="noopener"><code>areturn</code></a>은 오퍼랜드 스택 맨 위에 있는 참조값(return 앞에 있는 <code>a</code>가 참조값을 의미)을 꺼내서 호출한 메서드 프레임의 오퍼랜드 스택 맨 위에 저장하고, <code>areturn</code>이 속한 프레임을 폐기하고 제어를 호출한 메서드 프레임으로 넘겨준다.</p><p><code>helloMessage 메서드 프레임</code>의 오퍼랜드 스택 맨 위에 있던 값은 <code>&quot;Hello, JVM&quot;</code>에 대한 참조이며 이 값을 <code>main 메서드 프레임</code>의 오퍼랜드 스택 맨 위에 쌓는다. 결국 <strong>메서드가 값을 반환한다는 것은 호출된 프레임의 오퍼랜드 스택 맨 위의 값을 꺼내서 호출한 프레임의 오퍼랜드 스택 맨 위에 저장하는 것</strong>을 의미한다.</p><p><img src="https://i.imgur.com/vz0uuaf.png" alt="Imgur"></p><h3 id="15-invokevirtual-6-Method-java-io-PrintStream-println-Ljava-lang-String-V"><a href="#15-invokevirtual-6-Method-java-io-PrintStream-println-Ljava-lang-String-V" class="headerlink" title="15: invokevirtual #6  // Method java/io/PrintStream.println:(Ljava/lang/String;)V"></a><code>15: invokevirtual #6  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</code></h3><p>PrintStream 클래스의 println(String)의 바이트코드는.. 매우 길다.. 어차피 <code>invokevirtual</code>은 앞에서 살펴봤고 그 외에 오퍼랜드 스택이나 로컬 지역 변수의 변화 과정을 앞에서 계속 봐왔으므로, println(String)은 결과만 보자.</p><p><code>main 메서드 프레임</code>의 오퍼랜드 스택에 있던 System.out에 대한 참조와 <code>&quot;Hello, JVM&quot;</code>에 대한 참조는<code>invokevirtual</code>로 System.out.println(String)을 호출하면서 모두 꺼내지고<code>main 메서드 프레임</code>의 오퍼랜드 스택은 비워진다. <code>println 메서드 프레임</code>이 새로 생성되고 인자로 전달받은 참조를 활용해서 “Hello, JVM”을 화면에 출력하고, <code>println 메서드 프레임</code>은 폐기된 후의 모습은 다음과 같다.</p><p><img src="https://i.imgur.com/BWa4gBm.png" alt="Imgur"></p><h3 id="18-goto-18"><a href="#18-goto-18" class="headerlink" title="18: goto 18"></a><code>18: goto 18</code></h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.goto" target="_blank" rel="noopener"><code>goto</code></a>는 오퍼랜드 스택의 변화 없이 특정 행으로 실행 흐름을 이동시킨다.</p><p>18행에서 18행으로 계속 이동하면 결국 무한루프다. 자바 소스 코드의 <code>while(true) {}</code>가 여기에 해당된다.</p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>여기까지 바이트코드 흐름에 따라 JVM의 런타임 데이터 영역 내의 자료구조들이 어떻게 변화하는지 살펴봤다. 사실 몰라도 일반적인 개발을 하는데 거의 지장이 없다시피한 내용이라서 그림 한땀한땀 그리고 고치고를 반복할 때마다 내가 이 짓을 왜하고 있나.. 이쯤에서 그만두자.. 하는 생각이 든 게 한 두번이 아니었.. ㅠㅜ </p><p>그래도 인터넷 어디를 뒤져봐도 자바 프로그램의 실행 과정에 대해 이보다 친절한 설명은 없으리라..</p><blockquote><p>JVM에서 실행되는 프로그램(class파일)을 실행하면 JVM이 기동된다.</p><p>JVM이 기동되면 힙(Heap)과 메서드 영역(Method Area)가 생성된다.</p><p>프로그램 실행에 필요한 시작 클래스의 바이트코드가 클래스로더를 통해 로딩되어 메서드 영역에 저장된다.<br>이 때 바이트코드에 있던 상수 풀의 내용을 바탕으로 런타임 상수 풀이 클래스 단위로 만들어져 메서드 영역에 함께 저장된다.</p><p>링크(확인, 준비, 해석)를 통해 Object 등 프로그램 실행에 필요한 다른 클래스들이 로딩되고 필요하다면 정적으로 초기화 된다.</p><p>시작 클래스의 main 메서드 실행을 위한 main 스레드가 생성된다.</p><p>main 스레드가 생성되면 PC 레지스터, JVM 스택, 네이티브 메서드 스택이 한 개씩 main 스레드에 생성된다.<br>JVM 스택이 생성되면 main 메서드를 위한 main 메서드 프레임이 생성된다.<br>main 메서드 프레임이 생성되면 로컬 변수 배열, 오퍼랜드 스택, 런타임 상수 풀에 대한 참조가 한 개씩 main 메서드 프레임에 생성된다.</p><p>main 메서드의 내용에 따라 로컬 변수 배열, 오퍼랜드 스택, 런타임 상수 풀에 대한 참조를 이용해서 필요한 값이나 참조를 연산하고,<br>메서드 호출이 발생하면 해당 메서드를 위한 새 로컬 변수 배열, 오퍼랜드 스택, 런타임 상수 풀에 대한 참조가 포함된 새 프레임이 생성되어 JVM 스택 위에 쌓이고,<br>메서드 호출이 종료되면 해당 프레임이 JVM 스택에서 빠져나가고 제어는 다시 호출한 메서드의 프레임으로 돌아온다.<br>이 때 반환값이 있다면 호출한 메서드의 프레임의 오퍼랜드 스택의 맨 위에 쌓인다.</p><p>한 장의 그림으로 보면 다음과 같다.</p><p><img src="https://i.imgur.com/NCga0nz.png" alt="Imgur"></p></blockquote><h2 id="마지막-쉬운-퀴즈"><a href="#마지막-쉬운-퀴즈" class="headerlink" title="마지막 쉬운 퀴즈"></a>마지막 쉬운 퀴즈</h2><p>다음과 같은 코드를 실행하면 HelloNoInstance 인스턴스가 힙에 만들어질까 안 만들어질까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.jvm.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloNoInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, JVM"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 이름에 답이 있지만 HelloNoInstance 인스턴스는 힙에 만들어지지 않는다. 아래는 VisualVM으로 힙 덤프를 떠서 확인한 그림이다.</p><p><img src="https://i.imgur.com/S0cm4E8.png" alt="Imgur"></p><p>참고로 Java 11 기준으로 간단한 헬로월드 프로그램이 수행되는데 로딩되는 클래스의 수는 몇 개일까? 이건 직접 알아보기로 하자. ^^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Back-to-the-Essence-Java-컴파일에서-실행까지-2&quot;&gt;&lt;a href=&quot;#Back-to-the-Essence-Java-컴파일에서-실행까지-2&quot; class=&quot;headerlink&quot; title=&quot;Back to the Essenc
      
    
    </summary>
    
      <category term="Specification" scheme="http://homoefficio.github.io/categories/Specification/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Java Execution Process" scheme="http://homoefficio.github.io/tags/Java-Execution-Process/"/>
    
      <category term="JVM" scheme="http://homoefficio.github.io/tags/JVM/"/>
    
      <category term="Bytecode" scheme="http://homoefficio.github.io/tags/Bytecode/"/>
    
      <category term="Compile" scheme="http://homoefficio.github.io/tags/Compile/"/>
    
      <category term="JVM Spec" scheme="http://homoefficio.github.io/tags/JVM-Spec/"/>
    
      <category term="invokeinterface" scheme="http://homoefficio.github.io/tags/invokeinterface/"/>
    
      <category term="invokevirtual" scheme="http://homoefficio.github.io/tags/invokevirtual/"/>
    
      <category term="javap" scheme="http://homoefficio.github.io/tags/javap/"/>
    
      <category term="자바 실행 과정" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"/>
    
      <category term="java 실행 과정" scheme="http://homoefficio.github.io/tags/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"/>
    
      <category term="컴파일" scheme="http://homoefficio.github.io/tags/%EC%BB%B4%ED%8C%8C%EC%9D%BC/"/>
    
      <category term="바이트코드" scheme="http://homoefficio.github.io/tags/%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C/"/>
    
      <category term="JVM 명세" scheme="http://homoefficio.github.io/tags/JVM-%EB%AA%85%EC%84%B8/"/>
    
      <category term="JVM 스펙" scheme="http://homoefficio.github.io/tags/JVM-%EC%8A%A4%ED%8E%99/"/>
    
      <category term="Java Memory Structure" scheme="http://homoefficio.github.io/tags/Java-Memory-Structure/"/>
    
      <category term="Java Memory Model" scheme="http://homoefficio.github.io/tags/Java-Memory-Model/"/>
    
      <category term="JVM Memory" scheme="http://homoefficio.github.io/tags/JVM-Memory/"/>
    
      <category term="JRE" scheme="http://homoefficio.github.io/tags/JRE/"/>
    
      <category term="JVM Instruction" scheme="http://homoefficio.github.io/tags/JVM-Instruction/"/>
    
      <category term="Run-Time Data Area" scheme="http://homoefficio.github.io/tags/Run-Time-Data-Area/"/>
    
      <category term="Heap" scheme="http://homoefficio.github.io/tags/Heap/"/>
    
      <category term="Method Area" scheme="http://homoefficio.github.io/tags/Method-Area/"/>
    
      <category term="PC Register" scheme="http://homoefficio.github.io/tags/PC-Register/"/>
    
      <category term="JVM Stack" scheme="http://homoefficio.github.io/tags/JVM-Stack/"/>
    
      <category term="Native Method Stack" scheme="http://homoefficio.github.io/tags/Native-Method-Stack/"/>
    
      <category term="Frame" scheme="http://homoefficio.github.io/tags/Frame/"/>
    
      <category term="Local Variables" scheme="http://homoefficio.github.io/tags/Local-Variables/"/>
    
      <category term="Operand Stack" scheme="http://homoefficio.github.io/tags/Operand-Stack/"/>
    
      <category term="Reference to Run-Time Constant Pool" scheme="http://homoefficio.github.io/tags/Reference-to-Run-Time-Constant-Pool/"/>
    
      <category term="Run-Time Constant Pool" scheme="http://homoefficio.github.io/tags/Run-Time-Constant-Pool/"/>
    
      <category term="Link" scheme="http://homoefficio.github.io/tags/Link/"/>
    
      <category term="Verification" scheme="http://homoefficio.github.io/tags/Verification/"/>
    
      <category term="Preparation" scheme="http://homoefficio.github.io/tags/Preparation/"/>
    
      <category term="Initialization" scheme="http://homoefficio.github.io/tags/Initialization/"/>
    
      <category term="Resolution" scheme="http://homoefficio.github.io/tags/Resolution/"/>
    
      <category term="invokespecial" scheme="http://homoefficio.github.io/tags/invokespecial/"/>
    
      <category term="JVM 명령어" scheme="http://homoefficio.github.io/tags/JVM-%EB%AA%85%EB%A0%B9%EC%96%B4/"/>
    
      <category term="런타임 데이터 영역" scheme="http://homoefficio.github.io/tags/%EB%9F%B0%ED%83%80%EC%9E%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%98%81%EC%97%AD/"/>
    
      <category term="자바 메모리 구조" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/"/>
    
      <category term="자바 메모리 모델" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%A8%EB%8D%B8/"/>
    
      <category term="JVM 메모리 구조" scheme="http://homoefficio.github.io/tags/JVM-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/"/>
    
      <category term="JVM 메모리 모델" scheme="http://homoefficio.github.io/tags/JVM-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%A8%EB%8D%B8/"/>
    
      <category term="힙" scheme="http://homoefficio.github.io/tags/%ED%9E%99/"/>
    
      <category term="메서드 영역" scheme="http://homoefficio.github.io/tags/%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%81%EC%97%AD/"/>
    
      <category term="PC 레지스터" scheme="http://homoefficio.github.io/tags/PC-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/"/>
    
      <category term="JVM 스택" scheme="http://homoefficio.github.io/tags/JVM-%EC%8A%A4%ED%83%9D/"/>
    
      <category term="네이티브 메서드 스택" scheme="http://homoefficio.github.io/tags/%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%8A%A4%ED%83%9D/"/>
    
      <category term="프레임" scheme="http://homoefficio.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84/"/>
    
      <category term="로컬 변수 배열" scheme="http://homoefficio.github.io/tags/%EB%A1%9C%EC%BB%AC-%EB%B3%80%EC%88%98-%EB%B0%B0%EC%97%B4/"/>
    
      <category term="오퍼랜드 스택" scheme="http://homoefficio.github.io/tags/%EC%98%A4%ED%8D%BC%EB%9E%9C%EB%93%9C-%EC%8A%A4%ED%83%9D/"/>
    
      <category term="런타임 상수 풀" scheme="http://homoefficio.github.io/tags/%EB%9F%B0%ED%83%80%EC%9E%84-%EC%83%81%EC%88%98-%ED%92%80/"/>
    
      <category term="링크" scheme="http://homoefficio.github.io/tags/%EB%A7%81%ED%81%AC/"/>
    
      <category term="확인" scheme="http://homoefficio.github.io/tags/%ED%99%95%EC%9D%B8/"/>
    
      <category term="준비" scheme="http://homoefficio.github.io/tags/%EC%A4%80%EB%B9%84/"/>
    
      <category term="초기화" scheme="http://homoefficio.github.io/tags/%EC%B4%88%EA%B8%B0%ED%99%94/"/>
    
      <category term="해석" scheme="http://homoefficio.github.io/tags/%ED%95%B4%EC%84%9D/"/>
    
  </entry>
  
  <entry>
    <title>Back to the Essence - Java 컴파일에서 실행까지 - (1)</title>
    <link href="http://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-1/"/>
    <id>http://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-컴파일에서-실행까지-1/</id>
    <published>2019-01-30T15:00:57.000Z</published>
    <updated>2019-11-23T05:32:24.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Back-to-the-Essence-Java-컴파일에서-실행까지-1"><a href="#Back-to-the-Essence-Java-컴파일에서-실행까지-1" class="headerlink" title="Back to the Essence - Java 컴파일에서 실행까지 - (1)"></a>Back to the Essence - Java 컴파일에서 실행까지 - (1)</h1><p>Java 11 JVM 스펙을 기준으로 Java 소스 코드가 어떻게 컴파일되고 실행되는지 살짝 깊게 알아보자.</p><p>이번엔 1탄 컴파일 편이다. 2탄 실행 편은 <a href="https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-컴파일에서-실행까지-2/">여기</a>에..</p><h1 id="컴파일"><a href="#컴파일" class="headerlink" title="컴파일"></a>컴파일</h1><p>전통적으로 컴파일이라고 하면 어떤 언어로 된 소스 코드를 기계가 인식할 수 있는 네이티브 코드로 변환하는 과정을 의미하지만, 자바에서의 컴파일은 자바 언어로 된 코드를 JVM이 인식할 수 있는 JVM 명령어 코드(바이트코드)로 변환하는 것을 의미한다.<br>드물지만 자바에서의 컴파일도 일반적인 의미의 컴파일처럼 기계가 인식할 수 있는 코드로 변환하는 과정을 의미할 때도 있다. 대표적으로 JIT 컴파일러가 하는 컴파일은 바이트코드로 변환하는 것이 아니라 바이트코드를 네이티브 코드로 변환하는 것을 의미한다.</p><h2 id="실행-파일-생성-과정"><a href="#실행-파일-생성-과정" class="headerlink" title="실행 파일 생성 과정"></a>실행 파일 생성 과정</h2><p>자바 소스 코드를 컴파일하는 과정이 몇 단계로 구성되는지 구체적으로 스펙에 규정되어 있지는 않다. 참고로 C로 작성된 코드로부터 실행 파일을 만드는 과정은 보통 다음과 같이 4 단계로 구분한다.</p><ol><li>전처리(Pre-processing)<ul><li>주석 제거</li><li>매크로 인라인화</li><li>include 파일 인라인화</li></ul></li><li>컴파일(Compiling)<ul><li>컴파일러가 전처리 과정을 거친 C 소스 코드를 컴파일해서 어셈블리어 코드로 변환</li></ul></li><li>어셈블리(Assembly)<ul><li>어셈블러가 어셈블리어 코드를 기계어 코드로 변환</li></ul></li><li>링크(Linking)<ul><li>링커가 기계어 코드와 공유 라이브러리 등 다른 코드를 합쳐서 최종 실행 파일 생성</li></ul></li></ol><p>(참고: <a href="https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/</a>)</p><p>컴파일과 어셈블리 단계를 그냥 컴파일 단계 하나로 합쳐서 보면 다음과 같은 그림으로 쉽게 이해할 수 있다.</p><ol><li><p>전처리</p><p> <img src="https://i.imgur.com/6Gixn4m.png" alt="Imgur"></p></li><li><p>컴파일</p><p> <img src="https://i.imgur.com/XgKJv8x.png" alt="Imgur"></p></li><li><p>링크</p><p> <img src="https://i.imgur.com/bjruQVw.png" alt="Imgur"></p></li></ol><p>(그림 참고: <a href="https://www.sitesbay.com/cprogramming/c-compile-link-program" target="_blank" rel="noopener">https://www.sitesbay.com/cprogramming/c-compile-link-program</a>)</p><p>참고로 중요하진 않지만 자바는 전처리 과정에서 주석이 있던 행 자체가 제거되지는 않는다. 바이트코드 내용 중에 자바 소스 코드의 행 번호와 바이트코드 명령어의 위치를 매핑해주는 부분이 있는데 이 때 표시되는 자바 소스 코드 행 번호는 주석이 있던 행이 제거되지 않은 상태 기준의 행 번호가 표시된다.</p><p>자바는 컴파일 결과로 나온 바이트코드가 JVM에 의해 실행되면서 네이티브 기계어 코드로 변환되므로, 프로그램 실행 전에 네이티브 기계어 코드를 만들어내는 어셈블리 단계가 없다고 볼 수 있다. 마찬가지로 링크 단계도 프로그램 실행 전에 수행되지 않고 JVM에 의해 프로그램이 실행될 때 동적으로 수행된다.</p><p>따라서 자바의 컴파일 절차는 아주 단순하다. 그림조차도 그릴 필요 없고 다음과 같이 표현할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">자바 소스 코드 파일(.java) -&gt; javac 컴파일러 -&gt; JVM 바이트코드(.class)</span><br></pre></td></tr></table></figure><p>앞에서 나온 C 컴파일 과정 그림에서 살펴본 것처럼 컴파일과 어셈블리 과정을 하나로 뭉쳐서 컴파일이라고 하기도 한다. 아래에서 살펴볼 일반적인 컴파일 세부 단계는 컴파일과 어셈블리 과정을 하나로 뭉친 개념이다.</p><h2 id="컴파일-세부-단계"><a href="#컴파일-세부-단계" class="headerlink" title="컴파일 세부 단계"></a>컴파일 세부 단계</h2><h3 id="1-Lexical-Analysis-어휘-분석"><a href="#1-Lexical-Analysis-어휘-분석" class="headerlink" title="1. Lexical Analysis(어휘 분석)"></a>1. Lexical Analysis(어휘 분석)</h3><p>Lexical Analyzer(Lexer 또는 Tokenizer라고도 한다)가 소스 코드에서 문자 단위로 읽어서 어휘소(lexeme)를 식별하고 어휘소를 설명하는 토큰 스트림(Token Stream)을 생성한다.</p><p>어휘소는 식별가능한 문자 시퀀스인데 다음과 같은 것들을 통칭한다.</p><ul><li>키워드(keywords): <code>public</code>, <code>class</code>, <code>main</code>, <code>for</code> 등</li><li>리터럴(literals): <code>1L</code>, <code>2.3f</code>, <code>&quot;Hello&quot;</code> 등</li><li>식별자(identifiers): 변수 이름, 상수 이름, 함수 이름 등</li><li>연산자(operators): <code>+</code>, <code>-</code> 등</li><li>구분 문자(punctuation characters): <code>,</code>, <code>[]</code>, <code>{}</code>, <code>()</code> 등</li></ul><p>토큰(Token)은 타입(키워드, 리터럴, 식별자 등)과 값(<code>public</code>, <code>1L</code>, <code>main</code> 등)으로 구성되며 어휘소를 설명하는 객체로 볼 수 있다.</p><p>식별자 토큰은 어휘 분석 단계에서 심볼 테이블에 저장되고 이후 단계에서 계속 사용된다.</p><h3 id="2-Syntax-Analysis-구문-분석"><a href="#2-Syntax-Analysis-구문-분석" class="headerlink" title="2. Syntax Analysis(구문 분석)"></a>2. Syntax Analysis(구문 분석)</h3><p>Syntax Analyzer(구문 분석기, 파서(Parser)라고도 한다)가 어휘 분석 결과로 나온 토큰 스트림이 언어의 스펙으로 정해진 문법 형식에 맞는지 검사해서, 맞지 않으면 컴파일 에러를 내고, 맞으면 파스 트리(Parse Tree)를 생성한다(구문 분석 단계의 결과로 나오는 파스 트리를 추상 구문 트리(Abstract Syntax Tree)라고 부르는 자료도 있다).</p><p>어휘 분석과 구문 분석 과정을 그림으로 요약하면 다음과 같다.</p><p><img src="https://i.imgur.com/ynDWnl2.gif" alt="Imgur"></p><p>(그림 출처: <a href="https://en.wikipedia.org/wiki/Compiler" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Compiler</a>)</p><p>위 그림에서 Parser 아래에 있는 트리가 파스 트리다.</p><h3 id="3-Symantic-Analysis-의미-분석"><a href="#3-Symantic-Analysis-의미-분석" class="headerlink" title="3. Symantic Analysis(의미 분석)"></a>3. Symantic Analysis(의미 분석)</h3><p>의미 분석 단계에서는 타입 검사, 자동 타입 변환 등이 수행된다. 예를 들어 다음과 같은 코드는 구문 분석 단계에서는 에러가 나지 않지만, 의미 분석 단계에서는 타입 검사가 수행되면서 에러가 발생한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure><p>의미 분석 단계를 거치면서 파스 트리에 타입 관련 정보 등이 추가된다.</p><h3 id="4-Intermediate-Code-Generation-중간-코드-생성"><a href="#4-Intermediate-Code-Generation-중간-코드-생성" class="headerlink" title="4. Intermediate Code Generation(중간 코드 생성)"></a>4. Intermediate Code Generation(중간 코드 생성)</h3><p>의미 분석 단계를 통과한 파스 트리를 바탕으로 기계어로 변환하기 좋은 형태의 중간 언어로 된 중간 코드를 생성한다. 중간 코드를 만들어 사용하는 이유는 중간 언어가 없을 때의 문제점을 그림으로 보면 금방 이해가 된다.</p><p><img src="https://i.imgur.com/wROkyp1.jpg" alt="Imgur"></p><p>(그림 출처: <a href="https://www.slideshare.net/RamchandraRegmi/intermediate-code-generationramchandra-regmi" target="_blank" rel="noopener">https://www.slideshare.net/RamchandraRegmi/intermediate-code-generationramchandra-regmi</a>)</p><p>한 마디로 중간 단계를 하나 둬서 간접화를 통해 경우의 수를 낮추고 효율을 높이기 위해 중간 코드를 생성한다.</p><p>자바의 바이트코드가 바로 이 중간 코드에 해당한다고 볼 수 있다. 위 그림에서 4개의 언어를 나타내는 네모를 각각 자바, 클로저(Clojure), 스칼라, 코틀린이라고 하고, 녹색 네모를 바이트코드라고 생각하면 쉽게 이해할 수 있다.</p><p>어휘 분석에서 만들어져서, 구문 분석, 의미 분석 과정을 거치며 다듬어진 심볼 테이블은 중간 코드인 바이트코드 생성 단계에서 클래스나 인터페이스별 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">상수 풀(Constant Pool)</a>을 만드는 데 사용된다. </p><p>상수 풀 안에 담겨 있는 대부분의 자료구조는 이름, 설명자(descriptor), 값 등 테이블에 정적으로 저장된 정보를 조합해서 엔티티를 직접 표현하지만, <code>CONSTANT_Dynamic_info</code>, <code>CONSTANT_InvokeDynamic_info</code>로 표현되는 자료구조는 런타임에 정해지는 동적인 엔티티를 간접적으로 표현한다.(참고: <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.4.10" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.4.10</a>)</p><p>상수 풀에 저장된 정보는 해당 클래스나 인터페이스가 실제 생성될 때 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.1" target="_blank" rel="noopener">런타임 상수 풀(Run-Time Constant Pool)</a>을 구성하는데 사용된다.</p><h3 id="5-Code-Optimization-중간-코드-최적화"><a href="#5-Code-Optimization-중간-코드-최적화" class="headerlink" title="5. Code Optimization(중간 코드 최적화)"></a>5. Code Optimization(중간 코드 최적화)</h3><p>말 그대로 중간 코드가 더 효율적인 기계어로 변환되도록 최적화하는 과정이 수행된다. 다음과 같이 매우 다양한 최적화 기법이 사용된다.</p><h4 id="핍홀-Peephole-최적화"><a href="#핍홀-Peephole-최적화" class="headerlink" title="핍홀(Peephole) 최적화"></a>핍홀(Peephole) 최적화</h4><ul><li>중복 명령어 제거</li><li>도달 불가능한 코드 제거</li><li>제어 흐름 최적화</li><li>비용 낮은 연산자로 변환 등</li></ul><h4 id="지역-최적화"><a href="#지역-최적화" class="headerlink" title="지역 최적화"></a>지역 최적화</h4><ul><li>지역 공통 부분식 제거</li><li>복사 전파</li><li>상수 폴딩 등</li></ul><h4 id="루프-최적화"><a href="#루프-최적화" class="headerlink" title="루프 최적화"></a>루프 최적화</h4><ul><li>코드 이동</li><li>귀납 변수 최적화</li><li>루프 융합/교환/전개 등</li></ul><h4 id="전역-최적화"><a href="#전역-최적화" class="headerlink" title="전역 최적화"></a>전역 최적화</h4><ul><li>전역 공통 부분식 제거</li><li>상수 폴딩 등</li></ul><p>이 외에도 다양한 최적화 기법이 사용되는데, 쉽게 감이 오는 루프 최적화의 코드 이동만 확인해보자. 실제로 최적화되는 것은 바이트코드지만 보기 편하게 자바 코드로 표현한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++) &#123;</span><br><span class="line">    c[k] = <span class="number">2</span> * (p - q) * (n - k + <span class="number">1</span>) / (sqrt(n) + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i와 관계 없이 값이 고정되어 있는 식을 반복문 밖으로 옮겨서 불필요한 계산 반복을 제거</span></span><br><span class="line"></span><br><span class="line">factor = <span class="number">2</span> * (p - q);</span><br><span class="line">denominator = (sqrt(n) + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++) &#123;</span><br><span class="line">    c[k] = factor * (n - k + <span class="number">1</span>) / denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(참고: 컴파일러의 이해 - <a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B4565472056" target="_blank" rel="noopener">http://www.hanbit.co.kr/store/books/look.php?p_code=B4565472056</a>)</p><h2 id="컴파일-과정-정리"><a href="#컴파일-과정-정리" class="headerlink" title="컴파일 과정 정리"></a>컴파일 과정 정리</h2><p>자바의 컴파일 과정은 여기까지다. 자바의 컴파일 과정을 한 마디로 요약하면 <strong>자바 코드를 자바 언어 스펙에 따라 분석/검증하고, JVM 스펙의 class 파일 구조에 맞는 바이트코드를 만들어내는 과정</strong> 이라고 할 수 있다.</p><p>바이트코드는 로딩, 링크 과정을 거쳐야 하지만 분명히 JVM에서 실행될 수 있는 코드다. 따라서 꼭 자바 언어 스펙을 따르는 자바가 아니라도, JVM 스펙의 class 파일 구조에 맞는 바이트코드를 만들어 낼 수 있다면 어떤 언어든 JVM에서 실행될 수 있다. 클로저(Clojure)나 스칼라, 코틀린 등이 JVM에서 실행될 수 있는 이유가 바로 여기에 있다.</p><p>자바 코드의 변수, 상수, 제어문, 연산, 인자, 메서드 호출, 배열, switch문, 예외 처리, finally, synchronization, 애너테이션, 모듈(Java 9 이후) 등이 바이트코드로 어떻게 변환되는지는 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-3.html" target="_blank" rel="noopener">JVM 스펙의 3장</a>에 나오는 예시를 통해 확인할 수 있다.</p><p>그냥 지나치면 허전하니 간단한 자바 파일과 컴파일 된 바이트코드를 한 번 살펴보자.</p><h2 id="바이트코드-구경하기"><a href="#바이트코드-구경하기" class="headerlink" title="바이트코드 구경하기"></a>바이트코드 구경하기</h2><p>그냥 헬로월드는 너무 단순하니까 인터페이스를 사용하는 코드 예제를 살펴보자. main 메서드를 가진 <code>GreetingMain</code> 클래스가 <code>Greeting</code> 인터페이스를 구현하는 <code>KoreanGreeting</code> 클래스를 사용하는 예제다.</p><p>먼저 인터페이스인 <code>Greeting</code>부터 살펴보자.</p><h3 id="Greeting"><a href="#Greeting" class="headerlink" title="Greeting"></a>Greeting</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.jvm.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>메서드 하나를 가지고 있는 아주 단순한 인터페이스다. 컴파일 한 후에 다음과 같이 <code>javap</code> 명령으로 바이트코드를 확인할 수 있다. <code>javap</code>는 바이너리인 바이트코드 .class 파일을 텍스트로 보여주는 일종의 역어셈블러 프로그램이다.</p><blockquote><p>javap -v -l -p homo/efficio/jvm/sample/Greeting.class</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Classfile /C:/gitrepo/scratchpad/plain-java-scratchpad/out/production/classes/homo/efficio/jvm/sample/Greeting.class</span><br><span class="line">  Last modified 2019. 1. 13.; size 181 bytes</span><br><span class="line">  MD5 checksum 8f7ae541e0a64f511d820930f739d4ac</span><br><span class="line">  Compiled from &quot;Greeting.java&quot;</span><br><span class="line">public interface homo.efficio.jvm.sample.Greeting</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 53</span><br><span class="line">  flags: (0x0601) ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT</span><br><span class="line">  this_class: #1                          // homo/efficio/jvm/sample/Greeting</span><br><span class="line">  super_class: #2                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 1, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">  #1 = Class              #7              // homo/efficio/jvm/sample/Greeting</span><br><span class="line">  #2 = Class              #8              // java/lang/Object</span><br><span class="line">  #3 = Utf8               sayHello</span><br><span class="line">  #4 = Utf8               (Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  #5 = Utf8               SourceFile</span><br><span class="line">  #6 = Utf8               Greeting.java</span><br><span class="line">  #7 = Utf8               homo/efficio/jvm/sample/Greeting</span><br><span class="line">  #8 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public abstract java.lang.String sayHello(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">    flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Greeting.java&quot;</span><br></pre></td></tr></table></figure><p>인터페이스의 바이트코드는 Classfile, public interface …, Constant pool, { 바이트코드 }, SourceFile 이렇게 크게 5가지 항목으로 구분되어 표시된다.</p><p>컴파일과 실행 관점에서 주목해야할 항목은 상수 풀(Constant pool)과 실제 소스 코드로부터 변환된 바이트코드 내용이다. </p><p>상수풀에는 <code>Class</code>와 <code>Utf8</code>로 분류되는 값들이 표시되어 있다. 상수 풀에 포함된 정보는 <code>#N</code>의 형식으로 인덱스되어 있다. <code>Class</code>는 말그대로 클래스임을 나타내고 <code>Utf8</code>은 클래스나 메서드 등의 이름을 나타내는 식별자를 UTF-8로 인코딩 된 값으로 나타내고 있다. <code>Class</code>로 분류된 항목의 값은 <code>#7</code> 같이 다른 항목을 가리키는 일종의 참조로 되어 있고, 참조를 통해 가리키는 항목의 값은 주석으로 병기(<code>// homo/efficio/jvm/sample/Greeting</code>)되어 있다.</p><p>바이트코드에는 원래 자바 소스에는 없던 <code>abstract</code>라는 키워드가 추가되어 표시되어 있다. sayHello 메서드의 파라미터 정보(<code>(Ljava/lang/String;)</code>) 와 반환 타입 정보(<code>Ljava/lang/String;</code>)가 descriptor 항목에 표시되고, 접근 지정자(<code>ACC_PUBLIC</code>, <code>ACC_ABSTRACT</code>)가 flags 항목에 표시된다. </p><p>아주 간단해서 바이트코드의 상수풀과 바이트코드가 어떤 식으로 기술되는지 비교적 쉽게 감을 잡을 수 있다. 너무 간단해서 바이트코드 내용이 별로 없기 때문에, 바이트코드에 대한 설명은 구현 클래스인 <code>KoreanGreeting</code>에서 실제 코드와 함께 다시 살펴볼 것이다.</p><h3 id="KoreanGreeting"><a href="#KoreanGreeting" class="headerlink" title="KoreanGreeting"></a>KoreanGreeting</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.jvm.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KoreanGreeting</span> <span class="keyword">implements</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String hello = <span class="string">"안녕 "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getHello() + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Greeting</code> 인터페이스를 구현하고 있고, <code>hello</code>라는 필드를 하나 가지고 있는 단순한 클래스다. <code>getHello()</code>는 메서드가 2개일 때는 어떻게 표시되는지, 내부 private 메서드 호출은 어떻게 표시되는지 보기 위해 일부러 추가했다.</p><blockquote><p>javap -v -l -p homo/efficio/jvm/sample/KoreanGreeting.class</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">Classfile /C:/gitrepo/scratchpad/plain-java-scratchpad/out/production/classes/homo/efficio/jvm/sample/KoreanGreeting.class</span><br><span class="line">  Last modified 2019. 1. 12.; size 1132 bytes</span><br><span class="line">  MD5 checksum d7ac2a6fd38c67407480720ca730d987</span><br><span class="line">  Compiled from &quot;KoreanGreeting.java&quot;</span><br><span class="line">public class homo.efficio.jvm.sample.KoreanGreeting implements homo.efficio.jvm.sample.Greeting</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 53</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #6                          // homo/efficio/jvm/sample/KoreanGreeting</span><br><span class="line">  super_class: #7                         // java/lang/Object</span><br><span class="line">  interfaces: 1, fields: 1, methods: 3, attributes: 3</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #26            // ▒?▒</span><br><span class="line">   #3 = Fieldref           #6.#27         // homo/efficio/jvm/sample/KoreanGreeting.hello:Ljava/lang/String;</span><br><span class="line">   #4 = Methodref          #6.#28         // homo/efficio/jvm/sample/KoreanGreeting.getHello:()Ljava/lang/String;</span><br><span class="line">   #5 = InvokeDynamic      #0:#32         // #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">   #6 = Class              #33            // homo/efficio/jvm/sample/KoreanGreeting</span><br><span class="line">   #7 = Class              #34            // java/lang/Object</span><br><span class="line">   #8 = Class              #35            // homo/efficio/jvm/sample/Greeting</span><br><span class="line">   #9 = Utf8               hello</span><br><span class="line">  #10 = Utf8               Ljava/lang/String;</span><br><span class="line">  #11 = Utf8               &lt;init&gt;</span><br><span class="line">  #12 = Utf8               ()V</span><br><span class="line">  #13 = Utf8               Code</span><br><span class="line">  #14 = Utf8               LineNumberTable</span><br><span class="line">  #15 = Utf8               LocalVariableTable</span><br><span class="line">  #16 = Utf8               this</span><br><span class="line">  #17 = Utf8               Lhomo/efficio/jvm/sample/KoreanGreeting;</span><br><span class="line">  #18 = Utf8               sayHello</span><br><span class="line">  #19 = Utf8               (Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               name</span><br><span class="line">  #21 = Utf8               getHello</span><br><span class="line">  #22 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #23 = Utf8               SourceFile</span><br><span class="line">  #24 = Utf8               KoreanGreeting.java</span><br><span class="line">  #25 = NameAndType        #11:#12        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #26 = Utf8               ▒?▒</span><br><span class="line">  #27 = NameAndType        #9:#10         // hello:Ljava/lang/String;</span><br><span class="line">  #28 = NameAndType        #21:#22        // getHello:()Ljava/lang/String;</span><br><span class="line">  #29 = Utf8               BootstrapMethods</span><br><span class="line">  #30 = MethodHandle       6:#36          // REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #31 = String             #37            // \u0001\u0001</span><br><span class="line">  #32 = NameAndType        #38:#39        // makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  #33 = Utf8               homo/efficio/jvm/sample/KoreanGreeting</span><br><span class="line">  #34 = Utf8               java/lang/Object</span><br><span class="line">  #35 = Utf8               homo/efficio/jvm/sample/Greeting</span><br><span class="line">  #36 = Methodref          #40.#41        // java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #37 = Utf8               \u0001\u0001</span><br><span class="line">  #38 = Utf8               makeConcatWithConstants</span><br><span class="line">  #39 = Utf8               (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  #40 = Class              #42            // java/lang/invoke/StringConcatFactory</span><br><span class="line">  #41 = NameAndType        #38:#46        // makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #42 = Utf8               java/lang/invoke/StringConcatFactory</span><br><span class="line">  #43 = Class              #48            // java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #44 = Utf8               Lookup</span><br><span class="line">  #45 = Utf8               InnerClasses</span><br><span class="line">  #46 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #47 = Class              #49            // java/lang/invoke/MethodHandles</span><br><span class="line">  #48 = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #49 = Utf8               java/lang/invoke/MethodHandles</span><br><span class="line">&#123;</span><br><span class="line">  private java.lang.String hello;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: (0x0002) ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  public homo.efficio.jvm.sample.KoreanGreeting();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: ldc           #2                  // String ▒?▒</span><br><span class="line">         7: putfield      #3                  // Field hello:Ljava/lang/String;</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 5: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      11     0  this   Lhomo/efficio/jvm/sample/KoreanGreeting;</span><br><span class="line"></span><br><span class="line">  public java.lang.String sayHello(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #4                  // Method getHello:()Ljava/lang/String;</span><br><span class="line">         4: aload_1</span><br><span class="line">         5: invokedynamic #5,  0              // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">        10: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      11     0  this   Lhomo/efficio/jvm/sample/KoreanGreeting;</span><br><span class="line">            0      11     1  name   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  private java.lang.String getHello();</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: (0x0002) ACC_PRIVATE</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #3                  // Field hello:Ljava/lang/String;</span><br><span class="line">         4: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lhomo/efficio/jvm/sample/KoreanGreeting;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;KoreanGreeting.java&quot;</span><br><span class="line">InnerClasses:</span><br><span class="line">  public static final #44= #43 of #47;    // Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span><br><span class="line">BootstrapMethods:</span><br><span class="line">  0: #30 REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #31 \u0001\u0001</span><br></pre></td></tr></table></figure><p>자바 소스 코드 상으로는 <code>Greeting</code> 인터페이스와 몇 줄 차이 안 나는데 바이트코드의 양은 큰 차이가 난다. 바이트코드를 분석하는 것이 글의 목적이 아니라 컴파일이라는 큰 과정을 살펴보면서 결과물인 바이트코드도 눈으로 구경해보자는 취지이므로 개략적인 생김새와 기본적인 내용만 훑어보자.</p><h4 id="상수-풀"><a href="#상수-풀" class="headerlink" title="상수 풀"></a>상수 풀</h4><p>상수 풀에는 <code>Methodref</code>, <code>String</code>, <code>Fieldref</code>, <code>Methodref</code>, <code>InvokeDynamic</code>, <code>NameAndType</code>, <code>MethodHandle</code> 등 새로운 종류의 상수 항목이 나오는데, 이름과 값을 조금 살펴보면 어떻게 사용되는지 대략 감을 잡을 수 있다. 소스 코드 수준에서 정적으로 파악할 수 있는 변수, 상수, 메서드 등의 일람표라고 생각하면 된다.</p><p>상수 풀에 저장되는 상수 항목의 종류는 총 17개이며, 자세한 내용은 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">JVM 스펙</a>을 참고한다.</p><h4 id="바이트코드"><a href="#바이트코드" class="headerlink" title="바이트코드"></a>바이트코드</h4><p>{} 로 묶여서 표시되는 바이트코드는 대략 다음과 같은 구조로 되어 있다.</p><ul><li>필드나 메서드 선언부<ul><li>descriptor: 필드의 타입이나 메서드의 파라미터 및 반환 타입</li><li>flags: 접근 지정자</li><li>Code<ul><li>stack, locals, args_size: 스택 높이, 로컬 변수 갯수, 인자 갯수<ul><li>실제 구현 코드: 코드 위치, 바이트코드 명령어(instruction), 오퍼랜드(operand, 피연산자)</li></ul></li><li>LineNumberTable: 자바 코드의 행 번호와 바이트코드의 위치 매핑 테이블</li><li>LocalVariableTable: 로컬 변수 테이블</li></ul></li></ul></li></ul><p>어셈블리어 프로그래밍 경험이 있는 개발자에게는 바이트코드가 그리 낯설지 않을 것이다. 바이트코드의 대부분은 오퍼랜드 스택에 값을 넣고, 빼고, 읽고, 복사하고, 스왑하거나 메서드를 호출하는 내용을 담고 있다.</p><p>바이트코드 명령어에 대한 자세한 내용은 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5" target="_blank" rel="noopener">JVM 스펙</a>을 참고하고 여기에서는 메서드 호출과 관계있는 <code>invoke*</code> 명령어만 짧게 알아보자.</p><table><thead><tr><th>명령어 이름</th><th>하는 일</th></tr></thead><tbody><tr><td>invokeinterface</td><td>인터페이스에 정의된 메서드 호출</td></tr><tr><td>invokespecial</td><td>생성자, 현재 클래스의 메서드, 수퍼클래스의 메서드 호출</td></tr><tr><td>invokestatic</td><td>정적 메서드 호출</td></tr><tr><td>invokevirtual</td><td>자바 메서드 호출의 기본 방식이며, 객체 참조(<code>obj.</code>)를 붙여서 호출되는 일반적인 메서드 호출</td></tr><tr><td>invokedynamic</td><td>JVM에서 실행되는 동적 타입 언어를 위해 Java 7에 추가된 명령어. 람다식도 invokedynamic을 이용해서 구현되었다. 자세한 내용은 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/multiple-language-support.html" target="_blank" rel="noopener">오라클 문서</a>나 <a href="https://d2.naver.com/helloworld/4911107" target="_blank" rel="noopener">네이버 문서</a> 또는 <a href="https://dzone.com/articles/dismantling-invokedynamic" target="_blank" rel="noopener">DZone 문서</a>를 참고하자.</td></tr></tbody></table><p>한 가지 눈여겨 볼 것은 실제 자바 소스 코드에는 없던 디폴트 생성자가 추가되어 있다는 점이다. 컴파일러가 자동으로 추가해준다는 사실을 실제로 확인한 셈이다. 디폴트 생성자는 <a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.8.9" target="_blank" rel="noopener">자바 언어 스펙</a>을 참고하자.</p><h3 id="GreetingMain"><a href="#GreetingMain" class="headerlink" title="GreetingMain"></a>GreetingMain</h3><p><code>Greeting</code> 인터페이스와 이를 구현한 <code>KoreanGreeting</code> 클래스를 사용해서 인사말을 찍는 클래스다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.jvm.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        KoreanGreeting koreanGreeting = <span class="keyword">new</span> KoreanGreeting();</span><br><span class="line">        System.out.println(koreanGreeting.sayHello(<span class="string">"Homo Efficio"</span>));</span><br><span class="line"></span><br><span class="line">        Greeting greeting = <span class="keyword">new</span> KoreanGreeting();</span><br><span class="line">        System.out.println(greeting.sayHello(<span class="string">"Homo Efficio"</span>));</span><br><span class="line"></span><br><span class="line">        sayHelloFromDynamicallyLoadedClass(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHelloFromDynamicallyLoadedClass</span><span class="params">(String arg)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        ClassLoader classLoader = GreetingMain.class.getClassLoader();</span><br><span class="line">        Class&lt;?&gt; aClass = classLoader.loadClass(arg);</span><br><span class="line">        <span class="keyword">if</span> (Greeting.class.isAssignableFrom(aClass)) &#123;</span><br><span class="line">            Greeting aGreeting = (Greeting) aClass.getDeclaredConstructor().newInstance();</span><br><span class="line">            System.out.println(aGreeting.sayHello(<span class="string">"Homo Efficio"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>바이트코드 대략적인 구조 설명은 앞에서 했으므로 여기에서는 인터페이스를 통한 자바의 다형성이 발현되는 지점을 알 수 있는 부분만 살펴보자. 나머지 내용이 궁금하다면 <a href="https://github.com/HomoEfficio/plain-java-scratchpad/tree/master/src/main/java/homo/efficio/jvm/sample" target="_blank" rel="noopener">https://github.com/HomoEfficio/plain-java-scratchpad/tree/master/src/main/java/homo/efficio/jvm/sample</a> 를 참고한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">    ...</span><br><span class="line">    #8 = InterfaceMethodref #16.#65       // homo/efficio/jvm/sample/Greeting.sayHello:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">    ...</span><br><span class="line">&#123;</span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.ClassNotFoundException, java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException, java.lang.InstantiationException;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=4, args_size=1</span><br><span class="line">         0: new           #2                  // class homo/efficio/jvm/sample/KoreanGreeting</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method homo/efficio/jvm/sample/KoreanGreeting.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        11: aload_1</span><br><span class="line">        12: ldc           #5                  // String Homo Efficio</span><br><span class="line">        14: invokevirtual #6                  // Method homo/efficio/jvm/sample/KoreanGreeting.sayHello:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">        17: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        20: new           #2                  // class homo/efficio/jvm/sample/KoreanGreeting</span><br><span class="line">        23: dup</span><br><span class="line">        24: invokespecial #3                  // Method homo/efficio/jvm/sample/KoreanGreeting.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        27: astore_2</span><br><span class="line">        28: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        31: aload_2</span><br><span class="line">        32: ldc           #5                  // String Homo Efficio</span><br><span class="line">        34: invokeinterface #8,  2            // InterfaceMethod homo/efficio/jvm/sample/Greeting.sayHello:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">        39: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상수 풀의 8번쨰 항목에 <code>InterfaceMethodref</code>라는 항목으로 <code>Greeting</code> 인터페이스의 sayHello 메서드가 등록되어 있다.</p><p>자바 소스코드에서 아래와 같이 인터페이스를 사용하지 않는 부분은</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KoreanGreeting koreanGreeting = <span class="keyword">new</span> KoreanGreeting();</span><br><span class="line">System.out.println(koreanGreeting.sayHello(<span class="string">"Homo Efficio"</span>));</span><br></pre></td></tr></table></figure><p>다음과 같이 <code>invokevirtual</code>이 사용되고,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12: ldc           #5                  // String Homo Efficio</span><br><span class="line">14: invokevirtual #6                  // Method homo/efficio/jvm/sample/KoreanGreeting.sayHello:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">17: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>인터페이스를 사용하는 아래 코드는</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Greeting greeting = <span class="keyword">new</span> KoreanGreeting();</span><br><span class="line">System.out.println(greeting.sayHello(<span class="string">"Homo Efficio"</span>));</span><br></pre></td></tr></table></figure><p>다음과 같이 <code>invokeinterface</code>가 사용됨을 확인할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">32: ldc           #5                  // String Homo Efficio</span><br><span class="line">34: invokeinterface #8,  2            // InterfaceMethod homo/efficio/jvm/sample/Greeting.sayHello:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">39: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>이 글은 컴파일 과정을 훑어보는 게 목적이었으므로 바이트코드 구경은 여기서 줄인다. 바이트코드에 대한 내용은 더 궁금하다면 알고 싶은 부분을 직접 코딩/컴파일하고 <code>javap</code>와 JVM 스펙으로 확인해보는 것이 가장 좋고, <a href="https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-컴파일에서-실행까지-2/">2탄</a>을 참고해도 좋다.</p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>여기까지 자바 소스 코드가 바이트코드로 어떻게 컴파일되는지 알아봤다. 짧게 정리해보면 다음과 같다.</p><blockquote><p>자바도 전처리, 컴파일, 링크 과정을 통해 최종 실행 파일이 만들어진다.</p><p>컴파일의 세부 단계는 어휘 분석, 구문 분석, 의미 분석, 중간 코드 생성, 중간 코드 최적화로 구성된다.  </p><p><strong>자바 컴파일은 자바 코드를 자바 언어 스펙에 따라 분석/검증하고, JVM 스펙의 class 파일 구조에 맞는 바이트코드를 만들어내는 과정</strong>이다.</p><p>자바 소스 코드를 컴파일한 결과로 나오는 class 파일은 크게 보면 <strong>클래스 메타 정보, 상수 풀, 코드 구현부(JVM 명령어+오퍼랜드)로 구성</strong>된다.</p><p><strong>소스 코드에서 정적으로 파악할 수 있는 변수, 상수, 메서드 등의 정보가 클래스 파일 단위의 상수 풀(Constant Pool)에 저장</strong>되고,<br><strong>연산, 제어, 메서드 호출 등은 JVM 명령어와 상수 풀에 저장된 항목을 오퍼랜드로 사용하는 바이트코드로 변환되어 코드 구현부에 저장</strong>된다.</p><p><code>javap</code> 명령으로 바이너리 바이트코드를 눈으로 읽을 수 있는 텍스트로 역어셈블해서 확인할 수 있다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Back-to-the-Essence-Java-컴파일에서-실행까지-1&quot;&gt;&lt;a href=&quot;#Back-to-the-Essence-Java-컴파일에서-실행까지-1&quot; class=&quot;headerlink&quot; title=&quot;Back to the Essenc
      
    
    </summary>
    
      <category term="Specification" scheme="http://homoefficio.github.io/categories/Specification/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Java Execution Process" scheme="http://homoefficio.github.io/tags/Java-Execution-Process/"/>
    
      <category term="JVM" scheme="http://homoefficio.github.io/tags/JVM/"/>
    
      <category term="Bytecode" scheme="http://homoefficio.github.io/tags/Bytecode/"/>
    
      <category term="Compile" scheme="http://homoefficio.github.io/tags/Compile/"/>
    
      <category term="JVM Spec" scheme="http://homoefficio.github.io/tags/JVM-Spec/"/>
    
      <category term="Lexical Analysis" scheme="http://homoefficio.github.io/tags/Lexical-Analysis/"/>
    
      <category term="Syntax Analysis" scheme="http://homoefficio.github.io/tags/Syntax-Analysis/"/>
    
      <category term="Symantic Analysis" scheme="http://homoefficio.github.io/tags/Symantic-Analysis/"/>
    
      <category term="Intermediate Code Generation" scheme="http://homoefficio.github.io/tags/Intermediate-Code-Generation/"/>
    
      <category term="Code Optimization" scheme="http://homoefficio.github.io/tags/Code-Optimization/"/>
    
      <category term="Constant Pool" scheme="http://homoefficio.github.io/tags/Constant-Pool/"/>
    
      <category term="invokeinterface" scheme="http://homoefficio.github.io/tags/invokeinterface/"/>
    
      <category term="invokevirtual" scheme="http://homoefficio.github.io/tags/invokevirtual/"/>
    
      <category term="javap" scheme="http://homoefficio.github.io/tags/javap/"/>
    
      <category term="자바 실행 과정" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"/>
    
      <category term="java 실행 과정" scheme="http://homoefficio.github.io/tags/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"/>
    
      <category term="컴파일" scheme="http://homoefficio.github.io/tags/%EC%BB%B4%ED%8C%8C%EC%9D%BC/"/>
    
      <category term="바이트코드" scheme="http://homoefficio.github.io/tags/%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C/"/>
    
      <category term="JVM 명세" scheme="http://homoefficio.github.io/tags/JVM-%EB%AA%85%EC%84%B8/"/>
    
      <category term="JVM 스펙" scheme="http://homoefficio.github.io/tags/JVM-%EC%8A%A4%ED%8E%99/"/>
    
      <category term="어휘 분석" scheme="http://homoefficio.github.io/tags/%EC%96%B4%ED%9C%98-%EB%B6%84%EC%84%9D/"/>
    
      <category term="구문 분석" scheme="http://homoefficio.github.io/tags/%EA%B5%AC%EB%AC%B8-%EB%B6%84%EC%84%9D/"/>
    
      <category term="의미 분석" scheme="http://homoefficio.github.io/tags/%EC%9D%98%EB%AF%B8-%EB%B6%84%EC%84%9D/"/>
    
      <category term="중간 코드 생성" scheme="http://homoefficio.github.io/tags/%EC%A4%91%EA%B0%84-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1/"/>
    
      <category term="코드 최적화" scheme="http://homoefficio.github.io/tags/%EC%BD%94%EB%93%9C-%EC%B5%9C%EC%A0%81%ED%99%94/"/>
    
      <category term="상수 풀" scheme="http://homoefficio.github.io/tags/%EC%83%81%EC%88%98-%ED%92%80/"/>
    
  </entry>
  
  <entry>
    <title>탈중앙화된 암호화폐는 죽었다</title>
    <link href="http://homoefficio.github.io/2018/12/11/%ED%83%88%EC%A4%91%EC%95%99%ED%99%94%EB%90%9C-%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90%EB%8A%94-%EC%A3%BD%EC%97%88%EB%8B%A4/"/>
    <id>http://homoefficio.github.io/2018/12/11/탈중앙화된-암호화폐는-죽었다/</id>
    <published>2018-12-11T12:59:50.000Z</published>
    <updated>2019-04-28T17:03:55.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="탈중앙화된-암호화폐는-죽었다"><a href="#탈중앙화된-암호화폐는-죽었다" class="headerlink" title="탈중앙화된 암호화폐는 죽었다."></a>탈중앙화된 암호화폐는 죽었다.</h1><blockquote><p>원저자인 SemkoDev의 허락을 받고 우리말로 옮긴 글입니다.<br>SemkoDev는 IOTA 재단과는 관련이 없는 3rd party 개발사입니다.</p><p>원문: <a href="https://semkodev.com/decentralised-cryptocurrency-is-dead/?lang=en" target="_blank" rel="noopener">https://semkodev.com/decentralised-cryptocurrency-is-dead/?lang=en</a></p><p>IOTA 기부</p><h5 id="원저자-IYUIUCFNGOEEQHT9CQU9VYJVOJMQI9VYTQGQLTBAKTFIPWWRBFEV9TJWUZU9EYEFPM9VB9QYXTSMCDKMDABASVXPPX"><a href="#원저자-IYUIUCFNGOEEQHT9CQU9VYJVOJMQI9VYTQGQLTBAKTFIPWWRBFEV9TJWUZU9EYEFPM9VB9QYXTSMCDKMDABASVXPPX" class="headerlink" title="원저자: IYUIUCFNGOEEQHT9CQU9VYJVOJMQI9VYTQGQLTBAKTFIPWWRBFEV9TJWUZU9EYEFPM9VB9QYXTSMCDKMDABASVXPPX"></a>원저자: IYUIUCFNGOEEQHT9CQU9VYJVOJMQI9VYTQGQLTBAKTFIPWWRBFEV9TJWUZU9EYEFPM9VB9QYXTSMCDKMDABASVXPPX</h5><h5 id="옮긴이-ALGUYPTFQAWONZEZNMFRBHFX9KXIFNHUTUCHQQHJJCHWVQOAWSRNAWKSLPMLUBCYLBTALRMNCHIULGJEYSFAISLOSB"><a href="#옮긴이-ALGUYPTFQAWONZEZNMFRBHFX9KXIFNHUTUCHQQHJJCHWVQOAWSRNAWKSLPMLUBCYLBTALRMNCHIULGJEYSFAISLOSB" class="headerlink" title="옮긴이: ALGUYPTFQAWONZEZNMFRBHFX9KXIFNHUTUCHQQHJJCHWVQOAWSRNAWKSLPMLUBCYLBTALRMNCHIULGJEYSFAISLOSB"></a>옮긴이: ALGUYPTFQAWONZEZNMFRBHFX9KXIFNHUTUCHQQHJJCHWVQOAWSRNAWKSLPMLUBCYLBTALRMNCHIULGJEYSFAISLOSB</h5></blockquote><p><img src="https://i.imgur.com/jHVJGUf.png" alt="Imgur"></p><p>블록체인은 혁신의 대명사였지만 이제는 녹이 슬어버린 예전 시스템처럼 되어가고 있습니다. 비트코인이 민주화 된 금융 질서를 세우고 불필요한 중간자를 축출할 수 있다고 생각했다면, 이제는 다시 생각해보는 게 좋을 것 같습니다.</p><p>블록체인, 탱글(tangle), 대용량 블록(2x blocks), 스마트 컨트랙트, 세그윗(segwit), 라이트닝 네트워크(lightning network), Schnorr 알고리듬과 앞으로 똑똑한 괴짜들이 고안해 낼 새로운 기술 등 암호화폐에 사용하고 있는 기술에 대한 얘기를 하려는 것이 아닙니다. 문제는 여러 다른 방법으로 해결될 수도 있으니까요.</p><p>좀 더 심오한 고민을 필요로 하는 이야기를 꺼내보려 합니다. 사토시가 제시한 최초의 비전에는 결함이 있습니다.</p><h2 id="금전적-보상은-언제나-불평등으로-이어진다"><a href="#금전적-보상은-언제나-불평등으로-이어진다" class="headerlink" title="금전적 보상은 언제나 불평등으로 이어진다."></a>금전적 보상은 언제나 불평등으로 이어진다.</h2><p>전에 썼던 <a href="https://semkodev.com/iota-why-free-transactions-matter-most/?lang=en" target="_blank" rel="noopener">IOTA: why free transactions matter most</a>에서 주장한 것처럼 문제의 핵심은 보상(rewards)입니다. 누군가에게 네트워크를 운영하라고 보상을 지불하는 것은 여러분이 가지고 있던 권력(power)을 지불하는 것입니다. 권력을 지불하면 시스템에 불균형이 발생하고, 소수의 권력 집단이 생겨나며 시스템의 바탕이 되는 다수는 힘을 잃게 됩니다. 힘 없는 다수는 힘 있는 채굴자들 없이는 존재할 수 없게 되고, 힘 있는 채굴자는 시간이 갈 수록 더 큰 권력을 얻게 됩니다.</p><p><img src="https://i.imgur.com/HcsWxIq.png" alt="Imgur"></p><p>가장 유서 깊은 탈중앙화 장부(ledger)인 비트코인은 이 문제로부터 자유로운 적이 없었습니다. 비트코인에서는 소수의 채굴 풀이 전체 해시레이트(hashrate)의 절반 이상을 점유하고 있습니다. 이는 아주 좋지 않은 소식이고 시스템을 유지관리하는 사람들에게 금전적인 보상을 지급하는 어떤 코인도 이 문제로부터 자유로울 수 없습니다.</p><p>누구든 가장 높은 해시레이트를 보유한 자가 왕입니다. 지분 증명(Proof of Stake, PoS)이 모든 문제를 해결해줄 거라고 주장하는 사람들도 있겠지만, 지분 증명은 문제를 해결하는 것이 아니라 옮겨놓을 뿐입니다. <strong>지분 증명에서는 가장 높은 해시레이트가 아니라 가장 많은 코인을 보유한 자가 왕입니다. 해시레이트가 부(wealth)로 바뀔 뿐 작업 증명에 내재되어 있던 문제와 다를 것이 없습니다. 물론 지분 증명은 작업 증명처럼 많은 자원을 필요로하지 않으므로 환경 관점에서는 더 나은 해법이겠지만 중앙화의 문제를 해결하지는 못 합니다.</strong></p><h2 id="불평등은-언제나-중앙화로-이어진다"><a href="#불평등은-언제나-중앙화로-이어진다" class="headerlink" title="불평등은 언제나 중앙화로 이어진다."></a>불평등은 언제나 중앙화로 이어진다.</h2><p>겉으로 보기에 탈중앙화된 것 같은 코인은 부유한 소수가 원하는 대로 시스템을 조작할 수 있는 현재의 금융 질서와 살짝 다를 뿐 비슷해지고 있습니다. 다시 말하지만 코인이나 그 코인이 사용하는 기술은 하나도 중요하지 않습니다. 작업 증명이든 지분 증명이든 채굴자에게 보상을 지불하는 한, 채굴자는 시스템 위에 군림하게 됩니다. 채굴자들이 모든 것을 운영하는 단 하나의 이유는 돈입니다. 채굴자들은 사실상 코인 자체에는 관심이 없습니다. 내일 비트코인이 없어진다면 채굴자들은 그저 이더리움이든 라이트코인이든 다른 코인을 채굴하면 됩니다.</p><p>그래서 블록체인의 업그레이드가 필요할 때 채굴자들은 자신들의 이기적인 이익을 최우선으로 생각합니다. 사용자들은 그런 방향을 원치 않을거라고요? 글쎄요, 체인을 포크(fork)해서 누가 더 많은 권력을 가지고 있는지 보면 알 수 있을 겁니다. 기존 체인이 죽더라도 누가 상관할까요?</p><h2 id="중앙화는-암호화폐를-퇴물로-만든다"><a href="#중앙화는-암호화폐를-퇴물로-만든다" class="headerlink" title="중앙화는 암호화폐를 퇴물로 만든다."></a>중앙화는 암호화폐를 퇴물로 만든다.</h2><p>만약 어떤 코인의 운명을 극소수의 개인이 좌우할 수 있다면 현재의 통화 시스템과 다를 게 무엇일까요? 그저 중앙 은행이 중앙 채굴자로 바뀌는 것 뿐입니다. 달라질 게 없는데 뭐하러 귀찮게 바꾸나요?</p><blockquote><p>꿈은 죽었습니다.</p></blockquote><p>채굴자 손아귀로 넘어간 권력은 탈중앙화된 암호화폐가 내세웠던 이상을 파괴합니다. 꿈은 죽었습니다. 가까스로 주류에 편입한 어떤 암호화폐라도 채굴자를 없애지 않으면 결국 똑같은 문제에 직면하게 됩니다.</p><h2 id="희망은-있다"><a href="#희망은-있다" class="headerlink" title="희망은 있다."></a>희망은 있다.</h2><p>아무도 시스템 위에 군림해서는 안 되며, 시스템의 일부가 되는 것 외에 다른 동기(motivation)가 있으면 안 됩니다. 채굴자와 사용자 사이에 아무런 차이가 없어야만 위에서 말한 문제가 생기지 않습니다. 전체를 이루는 모든 구성원은 평등(equal)해야 합니다. 문제의 핵심을 파고 들어서, 네트워크 운영에 대한 보상을 없앤다면 모두가 평등해질 수 있습니다. 보상이 없어지면 불평등이 없어지고(No rewards = no inequality), 평등해지면 중앙화는 사라집니다(No inequality = no centralization).</p><p>하지만 금전적인 보상이 없다면 도대체 누가 노드를 운영하려 할까요? 대답은 매우 단순하고, 아이오타(IOTA)는 이 문제를 처음부터 바로잡고 시작하는 유망한 프로젝트 입니다. 네트워크를 이용하려면 사용자 스스로 네트워크를 유지해야 합니다. 거래를 하고 싶으면 다른 두 개의 거래를 검사해줘야 합니다. 아주 단순하죠.</p><p>이 방식에서는 모든 사용자가 평등합니다. 네트워크의 일부가 되고 싶으면 네트워크의 일부가 되기 위해 노력을 해야 합니다. 각 사용자는 자신의 필요에 따라 주고 받습니다. 농담 섞어 말하자면 공산주의의 꿈이 디지털 암호 장부(cryptoledger)를 통해 마침내 이루어지게 되는 겁니다.</p><p>진심으로 말하자면, 이 방식은 지금까지 진정한 탈중앙화 달성을 위해 나온 여러 방식 중에서 가장 나은 접근 방식입니다. 아이오타 네트워크의 규모가 현실적으로 작고 그래서 코디네이터(coordinator)가 있어야만 안정성을 보장받을 수 있는 현 시점에서는, 진정한 탈중앙화를 이뤄낸 프로젝트는 없습니다. 하지만 규모가 충분해지고 그래서 코디네이터를 필요로 하지 않게 되는 순간, 아이오타는 현재의 암호화폐 세상의 질서를 바꿔놓을 수도 있습니다.</p><p>진정한 탈중앙화에 대한 약속이야말로 업계에서 아이오타가 사랑받는 이유입니다. 아이오타가 다른 어떤 프로젝트보다 많은 파트너십을 가질 수 있었던 이유이기도 합니다. 산업계에서 이미 큰 힘을 가지고 있는 회사가 수상한 소수의 개인에 의해 좌우될 수 있는 암호화폐 프로젝트와 뭐하러 손을 잡겠습니까? 암호화폐가 현실 세상에 제대로 도입되려면 진정한 탈중앙화와 평등은 필수 조건입니다. 99%의 암호화폐는 이 조건을 충족시키지 못합니다.</p><p>우리는 흥미진진한 세상을 살고 있습니다. 암호화폐에 대해 이렇게 비관적으로 얘기해서 유감이지만 누군가는 마음에 담았던 이야기를 해야만 하고 모든 문제의 근본 원인에 대해 이야기 해야 합니다. 경고일 수도 있고 미래의 암호화폐 프로젝트를 선택하는 팁일 수도 있는 이야기로 글을 마무리하려 합니다. 채굴자 없는 진정한 평등을 추구하지 않는 프로젝트의 운명은 이미 결정되어 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;탈중앙화된-암호화폐는-죽었다&quot;&gt;&lt;a href=&quot;#탈중앙화된-암호화폐는-죽었다&quot; class=&quot;headerlink&quot; title=&quot;탈중앙화된 암호화폐는 죽었다.&quot;&gt;&lt;/a&gt;탈중앙화된 암호화폐는 죽었다.&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;원저자
      
    
    </summary>
    
      <category term="Distributed Ledger Technology" scheme="http://homoefficio.github.io/categories/Distributed-Ledger-Technology/"/>
    
    
      <category term="블록체인" scheme="http://homoefficio.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="Cryptocurrency" scheme="http://homoefficio.github.io/tags/Cryptocurrency/"/>
    
      <category term="IOTA" scheme="http://homoefficio.github.io/tags/IOTA/"/>
    
      <category term="아이오타" scheme="http://homoefficio.github.io/tags/%EC%95%84%EC%9D%B4%EC%98%A4%ED%83%80/"/>
    
      <category term="암호화폐" scheme="http://homoefficio.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90/"/>
    
      <category term="Distributed Ledger Technology" scheme="http://homoefficio.github.io/tags/Distributed-Ledger-Technology/"/>
    
      <category term="분산 원장 기술" scheme="http://homoefficio.github.io/tags/%EB%B6%84%EC%82%B0-%EC%9B%90%EC%9E%A5-%EA%B8%B0%EC%88%A0/"/>
    
      <category term="Blockchain" scheme="http://homoefficio.github.io/tags/Blockchain/"/>
    
      <category term="Translation" scheme="http://homoefficio.github.io/tags/Translation/"/>
    
      <category term="번역" scheme="http://homoefficio.github.io/tags/%EB%B2%88%EC%97%AD/"/>
    
  </entry>
  
  <entry>
    <title>Java URLClassLoader로 알아보는 클래스로딩</title>
    <link href="http://homoefficio.github.io/2018/10/14/Java-URLClassLoader%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%94%A9/"/>
    <id>http://homoefficio.github.io/2018/10/14/Java-URLClassLoader로-알아보는-클래스로딩/</id>
    <published>2018-10-13T15:13:39.000Z</published>
    <updated>2019-07-27T15:42:38.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-URLClassLoader로-알아보는-클래스로딩"><a href="#Java-URLClassLoader로-알아보는-클래스로딩" class="headerlink" title="Java URLClassLoader로 알아보는 클래스로딩"></a>Java URLClassLoader로 알아보는 클래스로딩</h1><p>Bootstrap ClassLoader, Extension ClassLoader, Application ClassLoader 이 3가지 기본 클래스로더 말고도 자주 사용되는<code>URLClassLoader</code>가 있다.<br>사실 Java 8의 Extension ClassLoader와 Application ClassLoader는 <code>URLClassLoader</code>를 상속받아서 만들어진 클래스다.</p><p>3가지 기본 클래스로더에 대한 자세한 내용은 <a href="https://homoefficio.github.io/2018/10/13/Java-클래스로더-훑어보기/">여기</a>를 참고한다.</p><p>간단한 <code>URLClassLoader</code> 예제로 클래스로딩 과정을 짚어보자.</p><h1 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h1><h2 id="URLClassLoader-예제"><a href="#URLClassLoader-예제" class="headerlink" title="URLClassLoader 예제"></a>URLClassLoader 예제</h2><h3 id="ClassLoaderRunner"><a href="#ClassLoaderRunner" class="headerlink" title="ClassLoaderRunner"></a>ClassLoaderRunner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.nio.zipfs.ZipInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3 Default ClassLoader\n"</span>);</span><br><span class="line">        <span class="comment">// Bootstrap ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader bootStrapClassLoader = String.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"Bootstrap Classloader - ClassLoader of String.class: "</span> + bootStrapClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Extension ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader extensionClassLoader = ZipInfo.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"Extension Classloader - ClassLoader of ZipInfo.class: "</span> + extensionClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Application ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader applicationClassLoader = Internal.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"Application Classloader - ClassLoader of Internal.class: "</span> + applicationClassLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ClassLoader Hierarchy\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"BootStrap ClassLoader           : "</span> + bootStrapClassLoader);</span><br><span class="line">        System.out.println(<span class="string">"extensionClassLoader.getParent(): "</span> + extensionClassLoader.getParent());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Extension ClassLoader             : "</span> + extensionClassLoader);</span><br><span class="line">        System.out.println(<span class="string">"applicationClassLoader.getParent(): "</span> + applicationClassLoader.getParent());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 외부 폴더에 있는 파일 존재 확인</span></span><br><span class="line">        <span class="keyword">final</span> File classRepo = <span class="keyword">new</span> File(<span class="string">"C:/Temp/class-repo/"</span>);</span><br><span class="line"><span class="comment">//        System.out.println(classRepo.exists());</span></span><br><span class="line">        <span class="keyword">final</span> File abcClassFile = <span class="keyword">new</span> File(<span class="string">"C:/Temp/class-repo"</span>, <span class="string">"homo/efficio/classloader/External.class"</span>);</span><br><span class="line"><span class="comment">//        System.out.println(abcClassFile.exists());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader for External and Internal\n"</span>);</span><br><span class="line">            <span class="keyword">final</span> URLClassLoader urlClassLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123; classRepo.toURI().toURL() &#125;);</span><br><span class="line">            <span class="keyword">final</span> Class&lt;?&gt; externalFromUrl = urlClassLoader.loadClass(<span class="string">"homo.efficio.classloader.External"</span>);</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader of External: "</span> + externalFromUrl.getClassLoader());</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader of Internal: "</span> + Internal.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"URL 형식이 잘못되었습니다."</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"클래스가 없습니다."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간단하다. 먼저 3가지 기본 클래스로더를 출력해보고, 기본 클래스로더 사이의 위계 구조(Hierarchy)를 출력해서 확인해본다.</p><p>마지막으로 프로젝트 경로 외부에 있는 클래스를 <code>URLClassLoader</code>를 통해 읽어오는 부분이 있다. <code>URLClassLoader</code>를 생성할 때 <strong>URL만 인자로 넘기면 기본값으로 <code>ClassLoaderRunner</code>를 로딩한 애플리케이션 클래스로더가 parent classloader로 사용된다.</strong></p><p>유의해야할 점은 <strong>URLClassLoader의 생성자 인자로 URL을 넘겨줄 때 로딩하고자 하는 <code>.class</code> 파일을 포함하고 있는 디렉토리(<code>/</code>로 끝나야 함)를 넘겨줘야 <code>.class</code> 파일을 인식할 수 있다</strong>는 점이다. 예를 들어 패키지를 포함한 클래스 이름이 ‘a.b.c.ABC.class’라면 실제로는 ‘…/어딘가/a/b/c/ABC.class’로 저장돼 있는데, ‘/a’를 포함하고 있는 ‘…/어딘가/‘를 URL로 변환해서 넘겨줘야 한다.</p><h3 id="Internal"><a href="#Internal" class="headerlink" title="Internal"></a>Internal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Internal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UUID uuid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter/setter 생략</span></span><br></pre></td></tr></table></figure><p>Internal 클래스는 그냥 별다른 특이점이 없는 일반적인 클래스다.</p><h3 id="External"><a href="#External" class="headerlink" title="External"></a>External</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">External</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Internal internal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter/setter 생략</span></span><br></pre></td></tr></table></figure><p>External 클래스는 컴파일 한 후에 클래스 파일을 프로젝트(클래스패스) 외부로 옮겨서 URLClassLoader 에 의해 로딩되는 부분을 테스트하는데 사용한다.</p><p>Internal 클래스를 필드로 가지고 있는데, External 클래스가 외부에서 로딩될 때 Internal 클래스의 로딩 여부를 확인하는 데 사용한다.</p><h2 id="실행-결과-1"><a href="#실행-결과-1" class="headerlink" title="실행 결과 - 1"></a>실행 결과 - 1</h2><p>클래스 파일을 전혀 손대지 않은 실행 결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------</span><br><span class="line">3 Default ClassLoader</span><br><span class="line"></span><br><span class="line">Bootstrap Classloader - ClassLoader of String.class: null</span><br><span class="line">Extension Classloader - ClassLoader of ZipInfo.class: sun.misc.Launcher$ExtClassLoader@5a07e868</span><br><span class="line">Application Classloader - ClassLoader of Internal.class: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">-----------------------------------</span><br><span class="line">ClassLoader Hierarchy</span><br><span class="line"></span><br><span class="line">BootStrap ClassLoader           : null</span><br><span class="line">extensionClassLoader.getParent(): null</span><br><span class="line">Extension ClassLoader             : sun.misc.Launcher$ExtClassLoader@5a07e868</span><br><span class="line">applicationClassLoader.getParent(): sun.misc.Launcher$ExtClassLoader@5a07e868</span><br><span class="line">-----------------------------------</span><br><span class="line">ClassLoader for External and Internal</span><br><span class="line"></span><br><span class="line">ClassLoader of External: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">ClassLoader of Internal: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="알-수-있는-점"><a href="#알-수-있는-점" class="headerlink" title="알 수 있는 점"></a>알 수 있는 점</h3><ul><li>Bootstrap ClassLoader는 <code>null</code> 로 표시된다. 실제로 Bootstrap ClassLoader는 Native C로 구현되어 있다.</li><li><code>jre/lib/ext</code> 폴더에 있는 jar 파일 안에 있는 <code>ZipInfo.class</code>를 통해 Extension ClassLoader를 확인할 수 있다.<ul><li>참고로 Java 9 에서는 모듈 시스템이 도입되면서 클래스로더에도 변화가 있었으며, <code>ZipInfo.class</code> 파일을 찾지 못해 컴파일 에러가 발생한다.</li></ul></li><li>External 클래스는 <code>URLClassLoader</code>를 통해 로딩을 시도하더라도, <strong>클래스 파일이 프로젝트 외부가 아닌 내부에 존재하고 있으면 클래스로딩 위임에 의해 <a href="https://homoefficio.github.io/2018/10/13/Java-클래스로더-훑어보기/">여기</a>에 나온 것처럼 Application ClassLoader에 의해 로딩된다.</strong></li></ul><h2 id="External-클래스를-프로젝트-내부에서-외부로-옮긴-후-실행"><a href="#External-클래스를-프로젝트-내부에서-외부로-옮긴-후-실행" class="headerlink" title="External 클래스를 프로젝트 내부에서 외부로 옮긴 후 실행"></a>External 클래스를 프로젝트 내부에서 외부로 옮긴 후 실행</h2><p>다음 그림과 같이 External 클래스를 프로젝트 내부(즉 클래스패스)에서는 없애고 외부에만 존재하게 바꾸고 실행하면,</p><p><img src="https://i.imgur.com/uGY0oib.png" alt="Imgur"></p><p>다음과 같이 External 클래스가 Application ClassLoader가 아니라 <code>URLClassLoader</code>에 의해 로딩됨을 알 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------</span><br><span class="line">ClassLoader for External and Internal</span><br><span class="line"></span><br><span class="line">ClassLoader of External: java.net.URLClassLoader@2c7b84de</span><br><span class="line">ClassLoader of Internal: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><h3 id="알-수-있는-점-1"><a href="#알-수-있는-점-1" class="headerlink" title="알 수 있는 점"></a>알 수 있는 점</h3><ul><li>컴파일 된 클래스 파일을 클래스패스 외부에 두고 <code>URLClassLoader</code>로 로딩할 수 있다.</li><li>외부에 있는 클래스 파일에 포함되어 있는 Internal는 클래스로더 위임에 따라 원래대로 Application ClassLoader에서 로딩한다.<ul><li><strong>즉 클래스패스 외부에 있는 클래스 파일이 클래스패스 내부에 있는 클래스를 참조하더라도 둘 모두 문제 없이 로딩해서 조합해서 사용할 수 있다.</strong></li></ul></li></ul><h1 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h1><h2 id="URLClassLoader-예제-1"><a href="#URLClassLoader-예제-1" class="headerlink" title="URLClassLoader 예제"></a>URLClassLoader 예제</h2><p>External, Internal 클래스는 Java 8 예제와 동일하고, main 클래스만 Java 9 에 맞게 조금 수정해야 한다.</p><h3 id="ClassLoaderRunner9"><a href="#ClassLoaderRunner9" class="headerlink" title="ClassLoaderRunner9"></a>ClassLoaderRunner9</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> homo.efficio@gmail.com</span></span><br><span class="line"><span class="comment"> * Created on 2018-10-11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderRunner9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3 Default ClassLoader\n"</span>);</span><br><span class="line">        <span class="comment">// Bootstrap ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader bootStrapClassLoader = String.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"Bootstrap Classloader - ClassLoader of String.class: "</span> + bootStrapClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Platform ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader platformClassLoader = ClassLoader.getPlatformClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"Platform Classloader - ClassLoader.getPlatformClassLoader(): "</span> + platformClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"System Classloader - ClassLoader.getSystemClassLoader()    : "</span> + systemClassLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ClassLoader Hierarchy\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"BootStrap ClassLoader           : "</span> + bootStrapClassLoader);</span><br><span class="line">        System.out.println(<span class="string">"platformClassLoader.getParent() : "</span> + platformClassLoader.getParent());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Platform ClassLoader             : "</span> + platformClassLoader);</span><br><span class="line">        System.out.println(<span class="string">"systemClassLoader.getParent()    : "</span> + systemClassLoader.getParent());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 외부 폴더에 있는 파일 존재 확인</span></span><br><span class="line">        <span class="keyword">final</span> File classRepo = <span class="keyword">new</span> File(<span class="string">"C:/Temp/class-repo/"</span>);</span><br><span class="line"><span class="comment">//        System.out.println(classRepo.exists());</span></span><br><span class="line">        <span class="keyword">final</span> File abcClassFile = <span class="keyword">new</span> File(<span class="string">"C:/Temp/class-repo"</span>, <span class="string">"homo/efficio/classloader/External.class"</span>);</span><br><span class="line"><span class="comment">//        System.out.println(abcClassFile.exists());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader for External and Internal\n"</span>);</span><br><span class="line">            <span class="keyword">final</span> URLClassLoader urlClassLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123; classRepo.toURI().toURL() &#125;);</span><br><span class="line">            <span class="keyword">final</span> Class&lt;?&gt; externalFromUrl = urlClassLoader.loadClass(<span class="string">"homo.efficio.classloader.External"</span>);</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader of External: "</span> + externalFromUrl.getClassLoader());</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader of Internal: "</span> + Internal.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"URL 형식이 잘못되었습니다."</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"클래스가 없습니다."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8과 달라진 점은 Platform ClassLoader와 System ClassLoader를 <code>ZipInfo.class</code>나 <code>Internal.class</code>와 같은 개별 클래스의 <code>getClassLoader()</code>가 아니라 <strong><code>ClassLoader.getPlatformClassLoader()</code>, <code>ClassLoader.getSystemClassLoader()</code>와 같이 <code>ClassLoader</code>의 static 메서드를 통해 직접 가져올 수 있다</strong>는 점이다.</p><h2 id="실행-결과"><a href="#실행-결과" class="headerlink" title="실행 결과"></a>실행 결과</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------</span><br><span class="line">3 Default ClassLoader</span><br><span class="line"></span><br><span class="line">Bootstrap Classloader - ClassLoader of String.class: null</span><br><span class="line">Platform Classloader - ClassLoader.getPlatformClassLoader(): jdk.internal.loader.ClassLoaders$PlatformClassLoader@e73f9ac</span><br><span class="line">System Classloader - ClassLoader.getSystemClassLoader()    : jdk.internal.loader.ClassLoaders$AppClassLoader@726f3b58</span><br><span class="line">-----------------------------------</span><br><span class="line">ClassLoader Hierarchy</span><br><span class="line"></span><br><span class="line">BootStrap ClassLoader           : null</span><br><span class="line">platformClassLoader.getParent() : null</span><br><span class="line">Platform ClassLoader             : jdk.internal.loader.ClassLoaders$PlatformClassLoader@e73f9ac</span><br><span class="line">systemClassLoader.getParent()    : jdk.internal.loader.ClassLoaders$PlatformClassLoader@e73f9ac</span><br><span class="line">-----------------------------------</span><br><span class="line">ClassLoader for External and Internal</span><br><span class="line"></span><br><span class="line">ClassLoader of External: java.net.URLClassLoader@96532d6</span><br><span class="line">ClassLoader of Internal: jdk.internal.loader.ClassLoaders$AppClassLoader@726f3b58</span><br><span class="line">-----------------------------------</span><br></pre></td></tr></table></figure><p>클래스로더의 패키지와 이름이 좀 달라지기는 했지만, 기본 클래스로더의 3계층 구조나 3가지 원칙 등 내용적으로는 Java 8과 같다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><p>URLClassLoader를 사용하면 클래스패스 외부에 있는 클래스를 로딩해서 클래스패스 내부에 있는 클래스와 조합해서 사용할 수 있다.</p><p>URLClassLoader로 개별 <code>.class</code> 파일을 로딩하려면 해당 클래스 파일을 포함하고 있는 디렉토리(‘/‘로 끝나야 함)를 URL로 전달해야 한다.</p><p>URLClassLoader로 로딩을 시도하더라도 클래스 파일이 클래스패스 내에 존재하면 클래스로더 위임 원칙에 의해 URLClassLoader가 아닌 애플리케이션 클래스로더(Java 9부터는 시스템 클래스로더)에 의해 로딩된다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-URLClassLoader로-알아보는-클래스로딩&quot;&gt;&lt;a href=&quot;#Java-URLClassLoader로-알아보는-클래스로딩&quot; class=&quot;headerlink&quot; title=&quot;Java URLClassLoader로 알아보는 클래스로
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="ClassLoader" scheme="http://homoefficio.github.io/tags/ClassLoader/"/>
    
      <category term="Default ClassLoader" scheme="http://homoefficio.github.io/tags/Default-ClassLoader/"/>
    
      <category term="Bootstrap ClassLoader" scheme="http://homoefficio.github.io/tags/Bootstrap-ClassLoader/"/>
    
      <category term="Extension ClassLoader" scheme="http://homoefficio.github.io/tags/Extension-ClassLoader/"/>
    
      <category term="Application ClassLoader" scheme="http://homoefficio.github.io/tags/Application-ClassLoader/"/>
    
      <category term="ClassLoader Delegation" scheme="http://homoefficio.github.io/tags/ClassLoader-Delegation/"/>
    
      <category term="Delegation Principle" scheme="http://homoefficio.github.io/tags/Delegation-Principle/"/>
    
      <category term="Visibility Principle" scheme="http://homoefficio.github.io/tags/Visibility-Principle/"/>
    
      <category term="Uniqueness Principle" scheme="http://homoefficio.github.io/tags/Uniqueness-Principle/"/>
    
      <category term="Java 9" scheme="http://homoefficio.github.io/tags/Java-9/"/>
    
      <category term="Platform ClassLoader" scheme="http://homoefficio.github.io/tags/Platform-ClassLoader/"/>
    
      <category term="System ClassLoader" scheme="http://homoefficio.github.io/tags/System-ClassLoader/"/>
    
      <category term="자바 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="부트스트랩 클래스로더" scheme="http://homoefficio.github.io/tags/%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="애플리케이션 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="플랫폼 클래스로더" scheme="http://homoefficio.github.io/tags/%ED%94%8C%EB%9E%AB%ED%8F%BC-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="시스템 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="URLClassLoader" scheme="http://homoefficio.github.io/tags/URLClassLoader/"/>
    
      <category term="자바 URLClassLoader" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94-URLClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>Java 클래스로더 훑어보기</title>
    <link href="http://homoefficio.github.io/2018/10/13/Java-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94-%ED%9B%91%EC%96%B4%EB%B3%B4%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2018/10/13/Java-클래스로더-훑어보기/</id>
    <published>2018-10-13T12:58:48.000Z</published>
    <updated>2019-04-28T17:03:55.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-ClassLoader-훑어보기"><a href="#Java-ClassLoader-훑어보기" class="headerlink" title="Java ClassLoader 훑어보기"></a>Java ClassLoader 훑어보기</h1><p>아주 예전에 SCJP 시험볼 때나 살펴본 이후로 자바의 클래스로더를 직접 다뤄야 할 일은 솔직히 없었다. 그래서 거의 잊고 살아왔는데 요즘 Quartz를 다루면서 Quartz에 없는 기능인 외부 Job 클래스 로딩 기능을 만들면서 정말로 오랜만에 들여다보게 됐다.</p><p>클래스로더는 Java9에 모듈 시스템이 도입되면서 적지 않은 변경이 있었다. 자세한 내용은 <a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-D867DCCC-CEB5-4AFA-9D11-9C62B7A3FAB1" target="_blank" rel="noopener">https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-D867DCCC-CEB5-4AFA-9D11-9C62B7A3FAB1</a> 를 참고하고, 먼저 Java8 까지 적용됐던 내용을 기준으로 되짚어보자.</p><h1 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h1><h2 id="3가지-기본-클래스로더"><a href="#3가지-기본-클래스로더" class="headerlink" title="3가지 기본 클래스로더"></a>3가지 기본 클래스로더</h2><p><img src="https://i.imgur.com/cs5Qyoe.png" alt="Imgur"></p><h3 id="Bootstrap-ClassLoader"><a href="#Bootstrap-ClassLoader" class="headerlink" title="Bootstrap ClassLoader"></a>Bootstrap ClassLoader</h3><ul><li>부트스트랩 클래스로더는 3가지 기본 클래스로더 중 최상위 클래스로더로서, 쉽게 말하면 <code>jre/lib/rt.jar</code>에 담긴 JDK 클래스 파일을 로딩한다. </li><li>Native C로 구현돼 있어서, <code>String.class.getClassLoader()</code>는 그냥 <code>null</code>을 반환한다. Primordial ClassLoader 라고 불리기도 한다.</li></ul><h3 id="Extension-ClassLoader"><a href="#Extension-ClassLoader" class="headerlink" title="Extension ClassLoader"></a>Extension ClassLoader</h3><ul><li>익스텐션 클래스로더는 <code>jre/lib/ext</code> 폴더나 <code>java.ext.dirs</code> 환경 변수로 지정된 폴더에 있는 클래스 파일을 로딩한다. </li><li>Java로 구현되어 있으며 <code>sun.misc.Launcher</code> 클래스 안에 static 클래스로 구현되어 있으며, <code>URLClassLoader</code>를 상속하고 있다.</li></ul><h3 id="Application-ClassLoader"><a href="#Application-ClassLoader" class="headerlink" title="Application ClassLoader"></a>Application ClassLoader</h3><ul><li>애플리케이션 클래스로더는 <code>-classpath(또는 -cp)</code>나 JAR 파일 안에 있는 Manifest 파일의 <code>Class-Path</code> 속성값으로 지정된 폴더에 있는 클래스를 로딩한다.</li><li>익스텐션 클래스로더와 마찬가지로 Java로 구현되어 있으며, <code>sun.misc.Launcher</code> 클래스 안에 static 클래스로 구현되어 있으며, <code>URLClassLoader</code>를 상속하고 있다.</li><li>개발자가 애플리케이션 구동을 위해 직접 작성한 대부분의 클래스는 이 애플리케이션 클래스로더에 의해 로딩된다.</li></ul><h2 id="3가지-원칙"><a href="#3가지-원칙" class="headerlink" title="3가지 원칙"></a>3가지 원칙</h2><p>자바 클래스로더는 3이라는 숫자와 친해 보인다. 기본 클래스로더가 3가지이고, 작동 원칙도 3가지다.</p><h3 id="Delegation-Principle"><a href="#Delegation-Principle" class="headerlink" title="Delegation Principle"></a>Delegation Principle</h3><p>위임 원칙은 클래스 로딩이 필요할 때 <strong>3가지 기본 클래스로더의 윗 방향으로 클래스 로딩을 위임하는 것</strong>을 말한다. <code>main()</code> 메서드가 포함된 <code>ClassLoaderRunner</code> 클래스에서 개발자가 직접 작성한 <code>Internal</code> 클래스를 로딩하는 과정을 그림으로 표현하면 다음과 같다.</p><p><img src="https://i.imgur.com/kijdBjb.png" alt="Imgur"></p><ol><li><p><code>ClassLoaderRunner</code>는 자기 자신을 로딩한 애플리케이션 클래스로더에게 <code>Internal</code> 클래스 로딩을 요청한다.</p></li><li><p>클래스 로딩 요청을 받은 애플리케이션 클래스로더는 <code>Internal</code>을 스스로 직접 로딩하지 않고 상위 클래스로더인 익스텐션 클래스로더에게 위임한다.</p></li><li><p>클래스 로딩 요청을 받은 익스텐션 클래스로더도 <code>Internal</code>을 스스로 직접 로딩하지 않고 상위 클래스로더인 부트스트랩 클래스로더에게 위임한다.</p></li><li><p>부트스트랩 클래스로더는 <code>rt.jar</code>에서 <code>Internal</code>을 찾아서</p><p> 4.1 있으면 로딩 후 반환하고</p></li><li><p>없으면 익스텐션 클래스로더가 <code>jre/lib/ext</code> 폴더나 <code>java.ext.dirs</code> 환경 변수로 지정된 폴더에서 <code>Internal</code>을 찾아서</p><p> 5.1 있으면 로딩 후 반환하고</p></li><li><p>없으면 애플리케이션 클래스로더가 클래스패스에서 <code>Internal</code>을 찾아서</p><p> 6.1 있으면 로딩 후 반환하고</p></li><li><p>없으면 <code>ClassNotFoundException</code>이 발생한다.</p></li></ol><p>이런 식으로 동작하는 이유는 두 번째 원칙인 Visibility Principle과 관련이 있다.</p><h3 id="Visibility-Principle"><a href="#Visibility-Principle" class="headerlink" title="Visibility Principle"></a>Visibility Principle</h3><p>가시범위 원칙은 <strong>하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 볼 수 있지만, 상위 클래스로더는 하위 클래스로더가 로딩한 클래스를 볼 수 없다</strong>는 원칙이다.</p><p>만약에 개발자가 만든 클래스를 로딩하는 애플리케이션 클래스로더가 부트스트랩 클래스로더에 의해 로딩된 <code>String.class</code>를 볼 수 없다면 애플리케이션은 <code>String.class</code>를 사용할 수 없을 것이다. 따라서 하위에서는 상위를 볼 수 있어야 애플리케이션이 제대로 동작할 수 있다.</p><p>상위에서도 하위를 볼 수 있다면 상/하위 구분이 사실상 없어진다. 클래스로더를 3가지로 나눈 이유가 있을텐데 상위가 하위를 볼 수 있으면 구분 의미가 희석돼버린다.</p><p>따라서 하위에서는 상위를 볼 수 있지만 상위에서는 하위를 볼 수 없어야 한다.</p><h3 id="Uniqueness-Principle"><a href="#Uniqueness-Principle" class="headerlink" title="Uniqueness Principle"></a>Uniqueness Principle</h3><p>유일성 원칙은 <strong>하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 다시 로딩하지 않게 해서 로딩된 클래스의 유일성을 보장</strong>하는 것이다. 유일성을 식별하는 기준은 클래스의 <code>binary name</code>인데, <code>toString()</code>으로 찍다보면 가끔 보이는 <code>java.lang.String</code>, <code>javax.swing.JSpinner$DefaultEditor</code>, <code>java.security.KeyStore$Builder$FileBuilder$1</code>, <code>java.net.URLClassLoader$3$1</code> 이런 것들이 바로 <code>binary name</code>이다. <code>binary name</code>의 자세한 내용은 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1</a> 를 참고한다.</p><h1 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h1><p>Java 9 에서도 기본 클래스로더의 3계층 구조와 3가지 원칙은 그대로 유효하다. 다만 모듈 시스템 도입에 맞춰 이름과 범위, 구현 내용 등이 바뀌었다.</p><p><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-EEED398E-AE37-4D12-AB10-49F82F720027" target="_blank" rel="noopener">https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-EEED398E-AE37-4D12-AB10-49F82F720027</a> 요 내용 중 ClassLoader에 관련된 내용만 추려보면 다음과 같다.</p><h2 id="한-표-요약"><a href="#한-표-요약" class="headerlink" title="한 표 요약"></a>한 표 요약</h2><table><thead><tr><th>Java 8</th><th>Java 9</th><th>달라진 점</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>이름 그대로</td><td>- rt.jar 등이 없어짐에 따라 로딩할 수 있는 클래스의 범위가 전반적으로 축소 <br> - 따라서 parent classloader 인자로 <code>null</code>을 넘겨주며 Bootstrap ClassLoader를 parent classloader로 사용했던 코드 수정 필요할 수 있음</td></tr><tr><td>Extension ClassLoader</td><td>Platform ClassLoader</td><td>- <code>jre/lib/ext</code>, <code>java.ext.dirs</code>를 지원하지 않음 <br> - Java SE의 모든 클래스와 Java SE에는 없지만 JCP에 의해 표준화 된 모듈 내의 클래스를 볼 수 있으며, Java 8에 비해 볼 수 있는 범위가 확장됨 <br> - <code>URLClassLoader</code>가 아닌 <code>BuiltinClassLoader</code>를 상속받아 <code>ClassLoaders</code> 클래스의 내부 static 클래스로 구현됨</td></tr><tr><td>Application ClassLoader</td><td>System ClassLoader</td><td>- 클래스패스, 모듈패스에 있는 클래스 로딩 <br> - <code>URLClassLoader</code>가 아닌 <code>BuiltinClassLoader</code>를 상속받아 <code>ClassLoaders</code> 클래스의 내부 static 클래스로 구현됨</td></tr></tbody></table><h2 id="rt-jar-tools-jar-가-제거됨"><a href="#rt-jar-tools-jar-가-제거됨" class="headerlink" title="rt.jar, tools.jar 가 제거됨"></a>rt.jar, tools.jar 가 제거됨</h2><p><code>rt.jar</code>, <code>tools.jar</code> 등 기본으로 제공되던 jar 파일이 없어지고 그 안에 있던 내용들은 모듈 시스템에 맞게 더 효율적으로 재편되어 <code>lib</code> 폴더 안에 저장된다. 이에 따라 <code>rt.jar</code>내의 모든 클래스를 로딩할 수 있던 Bootstrap ClassLoader가 로딩할 수 있는 클래스의 범위도 전체적으로 줄어들었다.</p><p>따라서 <strong>Bootstrap ClassLoader를 parent classloader로 사용하던 코드에서는 문제가 발생할 수 있다.</strong> </p><p>이럴 때는 <strong>Bootstrap Classloader를 의미하는 <code>null</code> 대신 <code>Classloader.getPlatformClassLoader()</code>를 인자로 넘겨서 가시 범위가 확장된 Platform ClassLoader를 parent classloader로 사용하면 된다.</strong></p><h2 id="jre-lib-ext-java-ext-dirs-lib-endorsed-java-endorsed-dirs-가-제거됨"><a href="#jre-lib-ext-java-ext-dirs-lib-endorsed-java-endorsed-dirs-가-제거됨" class="headerlink" title="jre/lib/ext, java.ext.dirs, lib/endorsed, java.endorsed.dirs 가 제거됨"></a>jre/lib/ext, java.ext.dirs, lib/endorsed, java.endorsed.dirs 가 제거됨</h2><p><code>jre/lib/ext</code>, <code>lib/endorsed</code> 가 파일시스템에 존재하거나 <code>java.ext.dirs</code>, <code>java.endorsed.dirs</code>가 환경변수로 설정되어 있으면 <code>javac</code>나 <code>java</code>는 실행이 종료된다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><p>Java에는 3가지 기본 클래스로더가 있다.</p><ol><li><p>부트스트랩 클래스로더</p></li><li><p>익스텐션 클래스로더(Java 9부터는 플랫폼 클래스로더)</p></li><li><p>애플리케이션 클래스로더(Java 9부터 시스템 클래스로더)</p></li></ol><p>클래스로더 동작에는 3가지 원칙이 있다.</p><ol><li><p>위임 원칙: 클래스로딩 작업을 상위 클래스로더에 위임한다.</p></li><li><p>가시 범위 원칙: 하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 볼 수 있지만, 상위 클래스로더는 하위 클래스로더가 로딩한 클래스를 볼 수 없다.</p></li><li><p>유일성 원칙: 하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 다시 로딩하지 않게 해서 로딩된 클래스의 유일성을 보장한다.</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-ClassLoader-훑어보기&quot;&gt;&lt;a href=&quot;#Java-ClassLoader-훑어보기&quot; class=&quot;headerlink&quot; title=&quot;Java ClassLoader 훑어보기&quot;&gt;&lt;/a&gt;Java ClassLoader 훑어보기&lt;/
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="ClassLoader" scheme="http://homoefficio.github.io/tags/ClassLoader/"/>
    
      <category term="Default ClassLoader" scheme="http://homoefficio.github.io/tags/Default-ClassLoader/"/>
    
      <category term="Bootstrap ClassLoader" scheme="http://homoefficio.github.io/tags/Bootstrap-ClassLoader/"/>
    
      <category term="Extension ClassLoader" scheme="http://homoefficio.github.io/tags/Extension-ClassLoader/"/>
    
      <category term="Application ClassLoader" scheme="http://homoefficio.github.io/tags/Application-ClassLoader/"/>
    
      <category term="ClassLoader Delegation" scheme="http://homoefficio.github.io/tags/ClassLoader-Delegation/"/>
    
      <category term="Delegation Principle" scheme="http://homoefficio.github.io/tags/Delegation-Principle/"/>
    
      <category term="Visibility Principle" scheme="http://homoefficio.github.io/tags/Visibility-Principle/"/>
    
      <category term="Uniqueness Principle" scheme="http://homoefficio.github.io/tags/Uniqueness-Principle/"/>
    
      <category term="Java 9" scheme="http://homoefficio.github.io/tags/Java-9/"/>
    
      <category term="Platform ClassLoader" scheme="http://homoefficio.github.io/tags/Platform-ClassLoader/"/>
    
      <category term="System ClassLoader" scheme="http://homoefficio.github.io/tags/System-ClassLoader/"/>
    
      <category term="자바 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="부트스트랩 클래스로더" scheme="http://homoefficio.github.io/tags/%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="애플리케이션 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="플랫폼 클래스로더" scheme="http://homoefficio.github.io/tags/%ED%94%8C%EB%9E%AB%ED%8F%BC-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="시스템 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
  </entry>
  
  <entry>
    <title>스펙따라 만들어보는 OAuth 1.0a Client</title>
    <link href="http://homoefficio.github.io/2018/08/27/%EC%8A%A4%ED%8E%99%EB%94%B0%EB%9D%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EB%8A%94-OAuth-1-0a-Client/"/>
    <id>http://homoefficio.github.io/2018/08/27/스펙따라-만들어보는-OAuth-1-0a-Client/</id>
    <published>2018-08-26T15:20:58.000Z</published>
    <updated>2019-04-28T17:03:55.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="스펙따라-만들어보는-OAuth-1-0a-Client"><a href="#스펙따라-만들어보는-OAuth-1-0a-Client" class="headerlink" title="스펙따라 만들어보는 OAuth 1.0a Client"></a>스펙따라 만들어보는 OAuth 1.0a Client</h1><h2 id="OAuth-탄생-배경"><a href="#OAuth-탄생-배경" class="headerlink" title="OAuth 탄생 배경"></a>OAuth 탄생 배경</h2><ul><li><p>많은 서비스가 API를 통해 서로 연결</p><blockquote><p><strong>내가 A라는 앱에 쓴 글이 내 트위터 타임라인에도 표시되면 좋겠다.</strong></p></blockquote></li><li><p>하지만 A 앱은 내 트위터 타임라인에 글을 쓸 권한이 없다.</p></li><li><p>물론 A 앱이 내 트위터 계정 정보를 알고 있다면 A 앱이 내 트위터 타임라인에 글을 쓸 수 있겠지만,</p></li><li><p>필요한 것은 글을 쓸 수 있는 권한 뿐인데 계정 정보를 모두 A 앱에게 알려줄 필요는 없다.</p></li><li><p>따라서 내가 A 앱에게 글을 쓸 권한을 줬다는 사실을 트위터에게 알려주고,</p></li><li><p>그 사실을 트위터가 확인할 수 있다면,</p></li><li><p>내 계정 정보를 A 앱에게 알려주지 않고도 A 앱이 트위터에 글을 쓸 수 있게 된다.</p></li><li><p><strong>내가 A 앱에 쓴 글을 내 트위터 타임라인에도 표시</strong>하려면 결국 다음의 질문에 대한 답이 필요하다.</p><blockquote><p><strong>내가 A 앱에게 권한을 줬다는 사실을 트위터에게 어떻게 알려줄 수 있을까?</strong></p></blockquote></li></ul><h1 id="OAuth-1-0a"><a href="#OAuth-1-0a" class="headerlink" title="OAuth 1.0a"></a>OAuth 1.0a</h1><p>어떤 행위(내가 A 앱에게 트위터에 글을 쓸 권한을 준 행위)가 이루어졌음을 프로그래밍을 통해 증명하는 여러 방식 중에 대표적으로 서명(Signature)이라는 것이 있다.</p><p>아래 그림은 서명 방식 중에서 HMAC(Hashed Message Authentication Code)를 보여주고 있다.</p><p><img src="https://www.thinqloud.com/wp-content/uploads/2017/07/blog_banner_2-1.jpg" alt=""><br>(출처: <a href="https://www.thinqloud.com/hmac-authentication-in-salesforce/" target="_blank" rel="noopener">https://www.thinqloud.com/hmac-authentication-in-salesforce/</a>)</p><ul><li>송신자와 수신자가 비밀키를 공유하고,</li><li>송신자는 평문(빨간 문서 아이콘)과 비밀키를 함께 해시한 값(MAC)과 평문을 함께 수신자에게 보내면,</li><li>수신자는 송신자가 보낸 평문과 송신자와 공유하고 있는 비밀키를 함께 해시한 값(Hash Output)을 계산하고,</li><li>계산한 값이 송신자가 보낸 MAC 값과 같은지 비교해서 평문(어떤 행위)이 송신자로부터 전송되었음을 확인한다.</li></ul><p>OAuth 1.0a는 권한을 줬다는 사실을 위와 같은 서명 방식을 이용해서 증명한다. </p><p>과정이 조금 복잡한 면이 있어서 요즘은 조금 더 간단하고 편리한 OAuth 2.0이 더 많이 사용되지만, 편리한 만큼 보안성을 양보해야 한다. </p><p>OAuth 1.0a를 이해하면 OAuth 2.0을 쉽게 이해할 수 있으므로 학습 관점에서는 OAuth 1.0a를 먼저 공부하는 것이 의미가 있다.</p><p>이제 OAuth 1.0a를 좀더 구체적으로 알아보자.</p><h2 id="등장-인물-이라-쓰고-용어라고-읽"><a href="#등장-인물-이라-쓰고-용어라고-읽" class="headerlink" title="등장 인물(이라 쓰고 용어라고 읽..)"></a>등장 인물(이라 쓰고 용어라고 읽..)</h2><ul><li>Resource Owner: 트위터 계정을 가지고 있는 트위터 사용자. 앱 A에 대한 사용권한도 가지고 있다.</li><li>Client: 트위터 API를 이용해서 트위터에 글을 남기려는 앱 A.</li><li><p>Server: API로 서비스를 제공하는 트위터.</p></li><li><p>Client Credentials: 등록을 요청한 Client 앱에게 Server가 발급한 등록 정보</p></li><li>Temporary Credentials: Client의 권한 부여 요청을 확인하고 Server가 발급한 임시 확인 정보</li><li>Token Credentials: 사용자로부터 권한을 부여받았음을 확인하고 Server가 발급한 접근 토큰 정보</li></ul><p>참고로 다음과 같이 가리키는 대상은 같지만 <a href="https://oauth.net/core/1.0/" target="_blank" rel="noopener">OAuth 1.0</a>과 <a href="https://tools.ietf.org/html/rfc5849" target="_blank" rel="noopener">OAuth 1.0a</a>에서의 용어가 다르며, 커뮤니티 버전인 OAuth 1.0의 용어를 그대로 쓰고 있는 자료도 많다.</p><table><thead><tr><th>OAuth 1.0</th><th>OAuth 1.0a</th></tr></thead><tbody><tr><td>User</td><td>Resource Owner</td></tr><tr><td>Consumer</td><td>Client</td></tr><tr><td>Service Provider</td><td>Server</td></tr><tr><td>Consumer Key and Secret</td><td>Client Credentials</td></tr><tr><td>Request Token and Secret</td><td>Temporary Credentials</td></tr><tr><td>Access Token and Secret</td><td>Token Credentials</td></tr></tbody></table><p><strong>1.0의 용어가 더 구별하기 쉽고 직관적이어서 학습하기에 좋으므로 본 글에서는 1.0 용어를 사용한다.</strong> 1.0 용어로 이해한 후에는 1.0a의 용어도 쉽게 받아들일 수 있을 것이다.</p><p>한 가지 짚고 넘어갈 용어로 Secret이 있는데, 서명 방식에서 <strong>Secret은 Service Provider가 Consumer에게 발급하고 둘이 각자 보유하고 있다가 필요할 떄 사용할 뿐 온라인으로 주고 받지 않는 정보</strong>다.</p><h2 id="사전-조건"><a href="#사전-조건" class="headerlink" title="사전 조건"></a>사전 조건</h2><ul><li>Consumer는 Service Provider의 API를 이용할 수 있도록 등록되어 있어야 한다.</li><li>User는 Consumer와 Service Provider 모두를 사용할 수 있는 권한을 가지고 있다.</li></ul><h2 id="Service-Provider로부터-확인-받아야-하는-사항"><a href="#Service-Provider로부터-확인-받아야-하는-사항" class="headerlink" title="Service Provider로부터 확인 받아야 하는 사항"></a>Service Provider로부터 확인 받아야 하는 사항</h2><ul><li>Consumer는 User로부터 권한 부여 요청을 받았다는 사실을 Service Provider로부터 확인 받아야 함 - (1)</li><li>User는 Service Provider의 사용자임을 Service Provider로부터 확인 받아야 함 - (2)</li><li>User는 Consumer에게 권한을 부여했음을 Service Provider로부터 확인 받아야 함 - (3)</li></ul><p>이 3가지 확인을 받기위한 절차를 개략적으로 생각해보자</p><h2 id="절차-개요"><a href="#절차-개요" class="headerlink" title="절차 개요"></a>절차 개요</h2><ol><li><p>User가 Consumer에 글을 쓰고 ‘Service Provider에도 남기기’ 버튼을 누른다.</p></li><li><p>Consumer는 자신의 등록 정보를 바탕으로 Signature를 만들고 Service Provider에게 Signature를 보내서 사용자로부터 권한 부여 요청을 받았음을 Service Provider에게 알리고, Service Provider는 권한 부여 요청을 확인했다는 임시 증표(Request Token)를 저장하고 Request Token을 Consumer에게 발급한다. (1)</p></li><li><p>Consumer는 권한 부여 요청 확인 증표(Request Token)와 함께 User의 요청을 Service Provider의 인가(권한 부여) 화면으로 리다이렉트한다.</p></li><li><p>User가 Service Provider에 로그인 한 상태가 아니라면 로그인 한다. (2)</p></li><li><p>인가 화면에는 ‘Consumer에게 권한 부여’ 버튼이 표시된다.</p></li><li><p>User가 ‘Consumer에게 권한 부여’ 버튼을 클릭하면, Service Provider는 User가 (Request Token을 확인하고) Consumer에게 권한을 부여했음을 확인하고, 확인 코드(Verifier 또는 Authorization_code)를 저장 및 User에게 반환하고 Consumer가 제공하는 callback 화면으로 리다이렉트한다. (3)</p></li><li><p>리다이렉트를 통해 권한 부여 확인 코드를 전달 받은 Consumer는 Consumer Key, Request Token, Verifier 등을 대상으로 Consumer Secret, Request Token Secret를 이용해서 Signature를 만들고 Service Provider에게 Signature를 보낸다.</p></li><li><p>Service Provider는 Consumer가 보낸 Signature를 확인하고 User만 접근할 수 있었던 보호 자원에 대한 접근 증표(Access Token)를 Consumer에게 발급한다.</p></li><li><p>이후 Consumer는 Access Token를 Service Provider에게 보여주면서 User를 대신해서 보호 자원에 접근한다.</p></li></ol><p>6번까지 진행되면 확인해야 할 3가지 사항은 모두 확인했으므로 바로 보호 자원에 대한 Access Token을 발급할 수 있지만, 6번에서 발급하면 증표가 User에게 직접 발급되고 User의 Local Storage나 Session에 남을 수 있으므로 유출 가능성이 발생한다. 따라서 6번에서는 발급하지 않고 8번에서 Consumer에게 발급한다.</p><p>위 과정에서 ‘권한 부여 요청 확인 증표’를 <code>Request Token</code>, ‘권한 부여 확인 코드’를 <code>Verifier 또는 AuthorizationCode</code>, ‘보호 자원 접근 증표’를 <code>Access Token</code>이라고 부른다.</p><h2 id="Sequence-Diagram"><a href="#Sequence-Diagram" class="headerlink" title="Sequence Diagram"></a>Sequence Diagram</h2><p>위 절차 개요를 좀더 상세하게 시퀀스 다이어그램으로 표현해보면 다음과 같다.</p><p><img src="https://i.imgur.com/quqloI2.png" alt="Imgur"></p><p>(<a href="http://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art014" target="_blank" rel="noopener">http://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art014</a> 내용 참고하여 재구성)</p><p>초록색 화살표는 브라우저와 웹 서버의 통신을 나타내며, 파란색 화살표는 HTTP API 호출을 나타낸다.</p><p>이제 시퀀스 다이어그램을 토대로 실제 구현해보자.</p><h1 id="OAuth-1-0a-구현-Consumer"><a href="#OAuth-1-0a-구현-Consumer" class="headerlink" title="OAuth 1.0a 구현 - Consumer"></a>OAuth 1.0a 구현 - Consumer</h1><p>첫 번째 시나리오는 직접 구현한 Consumer를 통해 Service Provider인 트위터의 API를 사용해서 트위터에 글을 올리는 것이다. </p><h2 id="사전-조건-1"><a href="#사전-조건-1" class="headerlink" title="사전 조건"></a>사전 조건</h2><p>먼저 트위터에 내가 만들 Consumer 앱을 등록해야 한다. 참고로 OAuth 1.0a에서 Consumer라고 부르는 애플리케이션을 트위터에서는 트위터 앱(Twitter App)이라고 부른다.</p><p>Consumer 앱을 트위터에 등록하려면 먼저 트위터 개발자 계정이 있어야 한다. <a href="https://developer.twitter.com/en/docs/basics/developer-portal/overview" target="_blank" rel="noopener">트위터 개발자 포털</a>에서 개발자 계정을 신청할 수 있다.</p><p>개발자 계정 신청과 트위터 앱 등록 과정 설명은 아래의 화면 캡처로 대신한다.</p><h3 id="트위터-개발자-계정-신청"><a href="#트위터-개발자-계정-신청" class="headerlink" title="트위터 개발자 계정 신청"></a>트위터 개발자 계정 신청</h3><p><img src="https://i.imgur.com/OiGrOKX.png" alt="Imgur"></p><p><img src="https://i.imgur.com/Lp1vUPB.png" alt="Imgur"></p><p><img src="https://i.imgur.com/R1NUNqg.png" alt="Imgur"></p><p><img src="https://i.imgur.com/hV1K0xX.png" alt="Imgur"></p><p><img src="https://i.imgur.com/csco9Qs.png" alt="Imgur"></p><p><img src="https://i.imgur.com/J6ltjT6.png" alt="Imgur"></p><p><img src="https://i.imgur.com/ZgGGlFB.png" alt="Imgur"></p><p><img src="https://i.imgur.com/Ap50ZcF.png" alt="Imgur"></p><p><img src="https://i.imgur.com/AXkdALv.png" alt="Imgur"></p><p><img src="https://i.imgur.com/9QjOwMn.png" alt="Imgur"></p><p><img src="https://i.imgur.com/EJKOIXN.png" alt="Imgur"></p><h3 id="트위터-앱-등록"><a href="#트위터-앱-등록" class="headerlink" title="트위터 앱 등록"></a>트위터 앱 등록</h3><p><img src="https://i.imgur.com/3DWV3GB.png" alt="Imgur"></p><p><img src="https://i.imgur.com/85q36Jq.png" alt="Imgur"></p><p><img src="https://i.imgur.com/ikYSSYN.png" alt="Imgur"></p><p><img src="https://i.imgur.com/4OyDBKp.png" alt="Imgur"></p><p><img src="https://i.imgur.com/P8CcCqg.png" alt="Imgur"></p><p><img src="https://i.imgur.com/SYsQSMF.png" alt="Imgur"></p><h2 id="Consumer-앱-개발"><a href="#Consumer-앱-개발" class="headerlink" title="Consumer 앱 개발"></a>Consumer 앱 개발</h2><p>Consumer 앱은 OAuth 1.0a 흐름을 파악하는데 필요한 최소한의 기능만을 담아 간단하게 개발한다. 기능은 다음과 같다.</p><ul><li>글을 쓸 수 있는 폼 화면</li><li>권한 부여 요청 전송 (시퀀스 다이어그램 2번)</li><li>서명 생성 기능</li><li>접근 토큰 요청 전송 (시퀀스 다이어그램 14번)</li><li>트위터에 글 쓰기 (시퀀스 다이어그램 20번)</li></ul><p>편의상 스프링 부트로 개발하며, 프로젝트 생성 등의 자세한 과정은 생략한다.</p><p>OAuth 1.0a Spec인 <a href="https://tools.ietf.org/html/rfc5849" target="_blank" rel="noopener">RFC-5849</a>를 따라 Consumer가 갖춰야 할 기능을 구현해보자. 전체 소스 코드는 <a href="https://github.com/HomoEfficio/scratchpad-oauth10a-consumer" target="_blank" rel="noopener">여기</a>에 있다.</p><h3 id="프로젝트-생성"><a href="#프로젝트-생성" class="headerlink" title="프로젝트 생성"></a>프로젝트 생성</h3><p>스프링 이니셜라이저에서 다음과 같이 최소한의 starter만 선택해서 프로젝트를 생성한다.</p><p><img src="https://i.imgur.com/DcmkDvi.png" alt="Imgur"></p><h3 id="글-쓰는-폼-화면"><a href="#글-쓰는-폼-화면" class="headerlink" title="글 쓰는 폼 화면"></a>글 쓰는 폼 화면</h3><p>글 쓰는 폼 화면도 최대한 단순하게 구성했다.</p><p><img src="https://i.imgur.com/xEk7x8p.png" alt="Imgur"></p><p>User가 ‘트위터에 남기기’ 버튼을 클릭하면, Consumer 앱이 트위터에 Request Token 발급을 요청한다. 이 부분부터 자세히 살펴보자.</p><h2 id="Request-Token-발급-요청"><a href="#Request-Token-발급-요청" class="headerlink" title="Request Token 발급 요청"></a>Request Token 발급 요청</h2><p>Request Token 발급 요청 내용은 스펙의 <a href="https://tools.ietf.org/html/rfc5849#section-2.1" target="_blank" rel="noopener">2.1 Temporary Credentials</a>에 나와있다. Service Provider에게 전송해야할 정보는 다음과 같다고 예시에 나와 있지만,</p><ul><li><code>oauth_consumer_key</code>: Service Provider로부터 발급받은 Consumer key</li><li><code>oauth_signature_method</code>: 서명 방식. <code>HMAC-SHA1</code>, <code>RSA-SHA1</code>,<code>PLAINTEXT</code>의 3가지 방식이 있다.</li><li><code>oauth_callback</code>: Request Token 발급 후 Service Provider가 제공하는 권한 부여 화면에서 User가 Consumer에게 권한을 부여하면 리다이렉트 되는 Consumer의 callback API URI</li><li><code>oauth_signature</code>: 서명 값</li></ul><p>실제로는 <a href="https://tools.ietf.org/html/rfc5849#section-3.1" target="_blank" rel="noopener">3.1 Making Requests</a>에 나온 것처럼 다음과 같은 정보도 함께 전송해야 한다.</p><ul><li><code>oauth_token</code>: Request Token 발급 요청 시에는 <code>oauth_token</code>이 없으므로 생략 가능</li><li><code>oauth_timestamp</code>: 1970.01.01 00:00:00 기준 요청 당시의 초 값</li><li><code>oauth_nonce</code>: 임의의 문자열 값으로 replay attack을 막는데 사용되며, timestamp, consumer key/secret과 request/access token이 같은 요청에 대해서 nonce 값은 유일해야 한다.</li><li><code>oauth_version</code>: 선택 사항이며 <code>1.0</code>이어야 한다.</li></ul><p>이 규약은 Request Token 발급 요청 뿐아니라 Access Token 발급 요청 시에도 마찬가지로 적용된다.</p><p>대부분 이미 정해져 있거나 임의의 값 등으로 쉽게 구할 수 있지만, <code>oauth_signature</code>는 스펙에 정해진 규칙에 따라 계산 로직을 구현해줘야 한다.</p><p>이 글에서는 3가지 서명 방식 중 <code>HMAC-SHA1</code>만 다룬다. <code>PLAINTEXT</code>는 서명 방식으로 분류하고 있지만 실제로는 서명 방식이 아니며, <code>RSA-SHA1</code>는 shared-secret 대신 공개키/비밀키를 사용한다는 점만 <code>HMAC-SHA1</code>와 다르다.</p><h2 id="Token-Signature"><a href="#Token-Signature" class="headerlink" title="Token Signature"></a>Token Signature</h2><p>토큰 발급 요청을 위한 서명 생성 방법은 <a href="https://tools.ietf.org/html/rfc5849#section-3.4" target="_blank" rel="noopener">3.4 Signature</a>에 나와있다.</p><p>요약하면 다음과 같다.</p><ol><li><p>Signature Base String 생성</p></li><li><p>Signature Base String을 Base64로 인코딩 한 값을 Secret으로 서명</p></li></ol><h3 id="Signature-Base-String-생성"><a href="#Signature-Base-String-생성" class="headerlink" title="Signature Base String 생성"></a>Signature Base String 생성</h3><p>Signature Base String 생성 방식은 코드로 보는 것이 이해하기 쉬울 것 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateBaseString</span><span class="params">(AbstractOAuth10aRequestHeader header)</span> </span>&#123;</span><br><span class="line">    String httpMethod = header.getHttpMethod();</span><br><span class="line">    String baseUri = getBaseStringUri(header);</span><br><span class="line">    String requestParameters = getRequestParameters(header);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(httpMethod)</span><br><span class="line">            .append(<span class="string">'&amp;'</span>).append(getPercentEncoded(baseUri))</span><br><span class="line">            .append(<span class="string">'&amp;'</span>).append(getPercentEncoded(requestParameters));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>요약하면 Signature Base String은 HTTP 메서드, Base String URI(Token 발급 요청 URI), Token 발급 요청 파라미터를 <a href="https://tools.ietf.org/html/rfc5849#section-3.6" target="_blank" rel="noopener">Percent encoding</a> 한 후 &amp;를 구분자로 이어 붙여서 만든다.</p><p>여기서 주의할 것은 <strong>Java의 <code>URLEncoder.encode</code>는 OAuth 1.0a 스펙에서 말하는 Percent encoding과 차이가 있다는 점이다.</strong> Percent encoding 값이 잘못되면 서명값이 잘못 나오고, 잘못 나온 서명값은 서버 쪽에서 계산한 서명값과 일치하지 않으므로 요청이 계속 실패하게 된다. 서명값이 틀리면 요청에 사용된 여러 데이터중 어떤 데이터가 잘못 되어 서명값이 틀리는지 찾아내는 데 엄청난 고통이 뒤따른다.</p><p>검색해보면 아래와 같은 내용이 나오는데 이걸 사용하면 Request Token 발급과 Access Token 발급에는 성공하지만, 마지막으로 트위터에 특수 문자가 포함된 글을 남길 때 계속 실패한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUrlEncoded</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> URLEncoder.encode(value, StandardCharsets.UTF_8.name())</span><br><span class="line">                .replaceAll(<span class="string">"\\+"</span>, <span class="string">"%20"</span>)</span><br><span class="line">                .replaceAll(<span class="string">"%21"</span>, <span class="string">"!"</span>)</span><br><span class="line">                .replaceAll(<span class="string">"%27"</span>, <span class="string">"'"</span>)</span><br><span class="line">                .replaceAll(<span class="string">"%28"</span>, <span class="string">"("</span>)</span><br><span class="line">                .replaceAll(<span class="string">"%29"</span>, <span class="string">")"</span>)</span><br><span class="line">                .replaceAll(<span class="string">"%7E"</span>, <span class="string">"~"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>정말 며칠동안 계속 Trial-Error로 잘못된 부분을 찾느라 고생했는데, 결국 해결사는 스프링이었다. <strong>스프링의 <code>UriUtils</code> 클래스에서 제공하는 <code>UriUtils.encode()</code>와 <code>UriUtils.decode()</code>가 정확히 Percent Encoding을 구현</strong>하고 있어서 최종적으로 올바른 서명값을 계산해낼 수 있었다.</p><h3 id="Token-발급-요청-파라미터"><a href="#Token-발급-요청-파라미터" class="headerlink" title="Token 발급 요청 파라미터"></a>Token 발급 요청 파라미터</h3><p>Base String URI 구성을 마치면 Token 발급 요청 파라미터를 구성해야 한다.</p><p>Token 발급 요청 파라미터는 <a href="https://tools.ietf.org/html/rfc5849#section-3.4.1.3" target="_blank" rel="noopener">3.4.1.3.  Request Parameters</a>에 나와있다. 요약하면 다음과 같다.</p><ol><li>Token 발급 요청 URI에 있는 Query String을 이름/값으로 파싱하고 URL decoding 한다.</li><li>Authorization 헤더에 있는 헤더 정보를 이름/값으로 파싱하고 URL decoding 한다.</li><li>발급 요청이 single-part 이고 <code>Content-Type</code> 헤더 값이 <code>application/x-www-form-urlencoded</code>라면 HTTP 요청 body 값을 이름/값으로 파싱하고 URL decoding 한다.</li><li>위의 값들을 normalization 한다. normalization 방식은 다음과 같다.<ol><li>파라미터 이름과 값을 URL encoding 한다.</li><li>파라미터를 이름 기준 오름차순으로 정렬한다. 이름이 동일할 경우 값 기준 오름차순으로 정렬한다.</li><li>파라미터 이름과 값을 <code>=</code>로 이어 붙인다.</li><li>이어 붙인 파라미터를 <code>&amp;</code>로 이어 붙인다.</li></ol></li></ol><p>스펙에서는 고맙게도 이에 대한 테스트 케이스를 제공해주는데 아래와 같은 토큰 발급 요청이 있다면,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /request?b5=%3D%253D&amp;a3=a&amp;c%40=&amp;a2=r%20b HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Authorization: OAuth realm=&quot;Example&quot;,</span><br><span class="line">              oauth_consumer_key=&quot;9djdj82h48djs9d2&quot;,</span><br><span class="line">              oauth_token=&quot;kkk9d7dh3k39sjv7&quot;,</span><br><span class="line">              oauth_signature_method=&quot;HMAC-SHA1&quot;,</span><br><span class="line">              oauth_timestamp=&quot;137131201&quot;,</span><br><span class="line">              oauth_nonce=&quot;7d8f3e4a&quot;,</span><br><span class="line">              oauth_signature=&quot;djosJKDKJSD8743243%2Fjdk33klY%3D&quot;</span><br><span class="line"></span><br><span class="line">c2&amp;a3=2+q</span><br></pre></td></tr></table></figure><p>토큰 발급 요청 파라미터는 다음의 결과값을 갖게 된다.<br>(가독성을 위해 줄바꿈을 적용했으나 그런다고 가독성이 좋아지지는..)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a2=r%20b&amp;a3=2%20q&amp;a3=a&amp;b5=%3D%253D&amp;c%40=&amp;c2=&amp;oauth_consumer_key=9dj</span><br><span class="line">dj82h48djs9d2&amp;oauth_nonce=7d8f3e4a&amp;oauth_signature_method=HMAC-SHA1</span><br><span class="line">&amp;oauth_timestamp=137131201&amp;oauth_token=kkk9d7dh3k39sjv7</span><br></pre></td></tr></table></figure><p>토큰 발급 요청 파라미터를 구하는 로직을 스펙을 읽고 정확하게 파악하는 것이 어렵지만, 일단 파악하면 구현 자체는 어렵지 않다. 필요하다면 <a href="https://github.com/HomoEfficio/scratchpad-oauth10a-consumer/blob/master/src/main/java/io/homo/efficio/scratchpad/oauth10a/consumer/util/OAuth10aSignatureSupport.java" target="_blank" rel="noopener">이걸</a> 참고하면 된다.</p><h3 id="서명-생성"><a href="#서명-생성" class="headerlink" title="서명 생성"></a>서명 생성</h3><p>서명 생성은 <a href="https://tools.ietf.org/html/rfc5849#section-3.4.2" target="_blank" rel="noopener">3.4.2.  HMAC-SHA1</a>에 나와있다. 서명에는 키와 데이터가 필요한데 <code>HMAC-SHA1</code> 방식의 키는 Consumer Secret과 Token Secret을 <code>&amp;</code>로 이어 붙인 값이다.</p><p>Request Token 발급 요청할 때는 Token Secret이 없는 상태이므로 그냥 <code>ConsumerSecret값&amp;</code>이 키가 된다.</p><p>서명에 사용될 데이터는 위에서 구한 토큰 발급 요청 파라미터다.</p><p>서명 값은 <code>javax.crypto.Mac</code> 클래스를 이용해서 계산할 수 있으며, 검색해보면 찾을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillSignature</span><span class="params">(AbstractOAuth10aRequestHeader header)</span> </span>&#123;</span><br><span class="line">    String key = header.getKey();</span><br><span class="line">    String baseString = generateBaseString(header);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> SecretKeySpec signingKey = <span class="keyword">new</span> SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), OAuth10aConstants.HMAC_SHA1_ALGORITHM_NAME);</span><br><span class="line">        <span class="keyword">final</span> Mac mac = Mac.getInstance(OAuth10aConstants.HMAC_SHA1_ALGORITHM_NAME);</span><br><span class="line">        mac.init(signingKey);</span><br><span class="line">        <span class="keyword">final</span> String signature = Base64.getEncoder().encodeToString(mac.doFinal(baseString.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        header.setOauthSignature(signature);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidKeyException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="괴로운-부분"><a href="#괴로운-부분" class="headerlink" title="괴로운 부분"></a>괴로운 부분</h3><p>결론만 보면 쉬운 것 같지만 <strong>직접 구현한 로직으로 만든 서명이 실제로 맞는지 검증을 하는 쉬운 방법이 없다는 게 OAuth 1.0a Consumer를 구현하는 과정 중에 가장 괴로운 부분이다.</strong> </p><p>서명이 맞는지 확인 하는 유일한 방법은 Service Provider인 트위터에 서명을 전송하고 트위터의 응답을 받아보는 것 밖에 없다. 그런데 서명이 맞지 않을 때는 다음과 같이 401 Authorization Required 만 확인할 수 있을 뿐이고,</p><blockquote><p>org.springframework.web.client.HttpClientErrorException: 401 Authorization Required</p></blockquote><p>디버거를 활용해서 확인해보면 아래와 같이 트위터가 알려주는 정보를 확인할 수는 있는데, 빈 문자열이 반환된다.</p><p><img src="https://i.imgur.com/awb2ePA.png" alt="Imgur"></p><p>빈 문자열이 반환되니 <a href="https://developer.twitter.com/en/docs/basics/response-codes.html" target="_blank" rel="noopener">트위터 응답 코드 문서</a>도 도움이 되지 않는다. 실로 막막하고 괴롭다.</p><p>서버의 서명 검증이라는 것이 결국 HTTP 헤더로 전달받은 정보를 이용해서 계산되므로, 어느 부분이 틀렸는지 더 구체적인 정보를 알려줄 수 있을텐데 보안 때문인지 트위터는 오류 세부 내용을 알려주지 않는다.</p><p>오랜 고생 끝에 결국 성공하고 나서 정리한 최선의 방법론은 다음과 같다.</p><ol><li>Percent Encoding은 스프링에서 제공하는 <code>UriUtils</code> 클래스를 활용해서 처리한다.</li><li>스펙에 나온 Base String URI 테스트 케이스를 통과하도록 Base String URI를 구성하는 로직을 정확하게 구현한다.</li><li>Request Token 발급과 Access Token 발급까지는 Service Provider 별로 다를 게 없고 스펙대로만 구현하면 되므로, 의도대로 동작하지 않으면 스펙을 보고 구현 내용을 점검한다.</li><li>Protected Resources에 대한 접근 요청 규격은 Service Provider 별로 다르므로 Access Token 발급까지는 성공했는데 자원 접근 요청에서 실패한다면 Service Provider의 문서를 꼼꼼히 살펴서 요청 규격을 맞춰준다.</li><li>400 Bad Request 에러가 발생하면 헤더 구성 내용 중 이름 오류나 누락된 항목이 있는지 다시 한 번 살펴보고, 401 Authorization Required 에러가 발생하면 서명값 계산 로직을 다시 살펴본다.</li></ol><p>여기까지 Request Token 발급 요청과 Access Token 발급 요청을 위한 서명 생성까지 다뤘다. 실제 화면으로 작업 흐름을 되짚어 보고 Access Token 발급까지 확인해보자.</p><h3 id="User의-권한-부여-신청"><a href="#User의-권한-부여-신청" class="headerlink" title="User의 권한 부여 신청"></a>User의 권한 부여 신청</h3><p><img src="https://i.imgur.com/ROuYV2h.png" alt="Imgur"></p><h3 id="Consumer가-서명-생성-후-Service-Provider에-전송해서-Request-Token을-발급-받고-Service-Provider가-제공하는-User의-권한-부여-화면으로-리다이렉트"><a href="#Consumer가-서명-생성-후-Service-Provider에-전송해서-Request-Token을-발급-받고-Service-Provider가-제공하는-User의-권한-부여-화면으로-리다이렉트" class="headerlink" title="Consumer가 서명 생성 후 Service Provider에 전송해서 Request Token을 발급 받고, Service Provider가 제공하는 User의 권한 부여 화면으로 리다이렉트"></a>Consumer가 서명 생성 후 Service Provider에 전송해서 Request Token을 발급 받고, Service Provider가 제공하는 User의 권한 부여 화면으로 리다이렉트</h3><p><img src="https://i.imgur.com/KVmocfW.png" alt="Imgur"></p><h3 id="User가-앱-인증을-클릭하면-Consumer의-callback-API로-리다이렉트"><a href="#User가-앱-인증을-클릭하면-Consumer의-callback-API로-리다이렉트" class="headerlink" title="User가 앱 인증을 클릭하면 Consumer의 callback API로 리다이렉트"></a>User가 앱 인증을 클릭하면 Consumer의 callback API로 리다이렉트</h3><p><img src="https://i.imgur.com/BpTOODs.png" alt="Imgur"></p><h3 id="callback-API에서-서명-생성-후-Service-Provider에-전송해서-Access-Token-발급"><a href="#callback-API에서-서명-생성-후-Service-Provider에-전송해서-Access-Token-발급" class="headerlink" title="callback API에서 서명 생성 후 Service Provider에 전송해서 Access Token 발급"></a>callback API에서 서명 생성 후 Service Provider에 전송해서 Access Token 발급</h3><p><img src="https://i.imgur.com/4eia8Qv.png" alt="Imgur"></p><h2 id="보호된-자원에-접근"><a href="#보호된-자원에-접근" class="headerlink" title="보호된 자원에 접근"></a>보호된 자원에 접근</h2><p>Access Token 까지 발급 받았으니 이제 Access Token을 사용해서 보호된 자원(Protected Resources)에 사용자를 대신해서 접근하는 과정만 남았다.</p><p>앞에서도 언급했지만 일단 여기까지 왔으면 서명 생성 로직은 제대로 구현되었다고 볼 수 있다. 보호된 자원에 접근하는 과정과 앞선 Request Token, Access Token 발급 과정 사이의 가장 큰 차이점 두 가지는 다음과 같다.</p><ol><li>보호된 자원에 접근할 때는 드디어 사용자의 데이터(예를 들면 트위터에 남기고자 하는 글)가 처음으로 요청에 포함된다.</li><li>보호된 자원 접근 요청 규격은 Service Provider의 규격을 참고해야 한다.</li></ol><p>차례대로 알아보자.</p><h3 id="자원-접근-요청-발송은-어디에서-해야되나"><a href="#자원-접근-요청-발송은-어디에서-해야되나" class="headerlink" title="자원 접근 요청 발송은 어디에서 해야되나?"></a>자원 접근 요청 발송은 어디에서 해야되나?</h3><p>최초의 글 남기기 요청에서 권한 부여 확인 후 끊김 없이 연속적으로 글 남기가 까지 완료하려면, 일단 <strong>접근 요청을 날리는 위치는 Access Token 발급 요청을 전송하고, Access Token을 반환받는 callback URL API여야 한다.</strong></p><p>Access Token을 받은 후, <code>Session</code>에서 사용자 데이터를 읽어와서 Access Token 정보와 함께 자원 접근 요청을 날리면 된다.</p><h3 id="사용자-데이터-처리"><a href="#사용자-데이터-처리" class="headerlink" title="사용자 데이터 처리"></a>사용자 데이터 처리</h3><p>앞의 작업 흐름 화면에 보면 사용자 데이터는 가장 앞 단계에서 입력된다. 따라서 이 데이터를 Request Token, Access Token 발급 과정을 거쳐서 자원 접근 요청을 보낼때까지 유지시켜줘야 결과적으로 사용자 데이터를 보호된 자원 접근에 사용할 수 있다. 가장 간단한 방법은 <code>Session</code>에 담아두는 것이다.</p><p>시퀀스 다이어그램 6번 과정에서 사용자 데이터(트위터에 남길 글)를 <code>Session</code>에 담아두면 여러 번의 리다이렉트를 거치면서 최종 요청 단계인 20번 과정까지 <code>Session</code>에 사용자 데이터가 유지 된다.</p><p><img src="https://i.imgur.com/quqloI2.png" alt="Imgur"></p><h3 id="자원-접근-요청-규격"><a href="#자원-접근-요청-규격" class="headerlink" title="자원 접근 요청 규격"></a>자원 접근 요청 규격</h3><p>자원 접근 요청 규격은 Service Provider가 정한 규격에 따라야 한다. 트위터에 글을 남기는 요청 규격은 <a href="https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/post-statuses-update" target="_blank" rel="noopener">여기</a>에 다음과 같이 예제가 나와 있다.</p><blockquote><p>$ curl –request POST<br>–url ‘<a href="https://api.twitter.com/1.1/statuses/update.json" target="_blank" rel="noopener">https://api.twitter.com/1.1/statuses/update.json</a>?<br>status=Test%20tweet%20using%20the%20POST%20statuses%2Fupdate%20endpoint’<br>–header ‘authorization: OAuth oauth_consumer_key=”YOUR_CONSUMER_KEY”,<br>oauth_nonce=”AUTO_GENERATED_NONCE”, oauth_signature=”AUTO_GENERATED_SIGNATURE”,<br>oauth_signature_method=”HMAC-SHA1”, oauth_timestamp=”AUTO_GENERATED_TIMESTAMP”,<br>oauth_token=”USERS_ACCESS_TOKEN”, oauth_version=”1.0”‘<br>–header ‘content-type: application/json’</p></blockquote><p>POST 방식이지만 사용자 데이터를 request body가 아니라 Query String으로 붙여서 보내고 있다. 따라서 글 남기기 요청 시에도 POST 방식을 쓰되 남길 글을 request body가 아니라 Query String에 붙여서 보내야 하고, 서명 생성 시에도 요청 URL에 Query String이 포함되어야 한다.</p><h3 id="자원-접근-요청-구현-내용"><a href="#자원-접근-요청-구현-내용" class="headerlink" title="자원 접근 요청 구현 내용"></a>자원 접근 요청 구현 내용</h3><p>앞에서 다룬 3가지 주요 내용을 구현한 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/callback"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestTokenCredentials</span><span class="params">(HttpServletRequest request, VerifierResponse verifierResponse)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Access Token 발급 요청 전송</span></span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    <span class="keyword">final</span> String requestTokenSecret = (String) session.getAttribute(<span class="string">"RTS"</span>);</span><br><span class="line">    <span class="keyword">final</span> AbstractOAuth10aRequestHeader tcHeader =</span><br><span class="line">            <span class="keyword">new</span> OAuth10aTokenCredentialsRequestHeader(</span><br><span class="line">                    <span class="keyword">this</span>.tokenCredentialsUrl,</span><br><span class="line">                    <span class="keyword">this</span>.consumerKey,</span><br><span class="line">                    <span class="keyword">this</span>.consumerSecret,</span><br><span class="line">                    verifierResponse.getOauth_token(),</span><br><span class="line">                    requestTokenSecret,</span><br><span class="line">                    verifierResponse.getOauth_verifier());</span><br><span class="line">    <span class="keyword">final</span> ResponseEntity&lt;TokenCredentials&gt; responseEntity =</span><br><span class="line">            <span class="keyword">this</span>.twitterService.getCredentials(tcHeader, TokenCredentials.class);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"access_token: &#123;&#125;"</span>, Objects.requireNonNull(responseEntity.getBody()).toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 자원 접근 요청 전송</span></span><br><span class="line">    <span class="keyword">final</span> NextAction nextAction = (NextAction) session.getAttribute(OAuth10aConstants.NEXT_ACTION);</span><br><span class="line">    log.info(<span class="string">"nextAction: &#123;&#125;"</span>, nextAction);    </span><br><span class="line">    <span class="keyword">final</span> OAuth10aProtectedResourcesRequestHeader resourcesRequestHeader =</span><br><span class="line">            <span class="keyword">new</span> OAuth10aProtectedResourcesRequestHeader(</span><br><span class="line">                    nextAction,</span><br><span class="line">                    <span class="keyword">this</span>.consumerKey,</span><br><span class="line">                    <span class="keyword">this</span>.consumerSecret,</span><br><span class="line">                    responseEntity.getBody().getOauth_token(),</span><br><span class="line">                    responseEntity.getBody().getOauth_token_secret());</span><br><span class="line">    log.info(<span class="string">"OAuth10aProtectedResourcesRequestHeader: &#123;&#125;"</span>, resourcesRequestHeader);</span><br><span class="line">    <span class="keyword">final</span> ResponseEntity&lt;Object&gt; actionResponseEntity =</span><br><span class="line">            <span class="keyword">this</span>.twitterService.doNextAction(resourcesRequestHeader, nextAction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 접근 요청 후처리</span></span><br><span class="line">    <span class="keyword">if</span> (actionResponseEntity.getStatusCode().equals(HttpStatus.OK)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Mention is written!!!"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> actionResponseEntity.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="실제-글이-트위터에-남겨지는-진행-과정"><a href="#실제-글이-트위터에-남겨지는-진행-과정" class="headerlink" title="실제 글이 트위터에 남겨지는 진행 과정"></a>실제 글이 트위터에 남겨지는 진행 과정</h2><p>전체 과정은 다음과 같이 진행된다.</p><h3 id="글-쓰고-트위터에-남기기-클릭"><a href="#글-쓰고-트위터에-남기기-클릭" class="headerlink" title="글 쓰고 트위터에 남기기 클릭"></a>글 쓰고 트위터에 남기기 클릭</h3><p><img src="https://i.imgur.com/AdU3bB6.png" alt="Imgur"></p><h3 id="Consumer가-서명-생성-후-Service-Provider에-전송해서-Request-Token을-발급-받고-Service-Provider가-제공하는-User의-권한-부여-화면으로-리다이렉트-1"><a href="#Consumer가-서명-생성-후-Service-Provider에-전송해서-Request-Token을-발급-받고-Service-Provider가-제공하는-User의-권한-부여-화면으로-리다이렉트-1" class="headerlink" title="Consumer가 서명 생성 후 Service Provider에 전송해서 Request Token을 발급 받고, Service Provider가 제공하는 User의 권한 부여 화면으로 리다이렉트"></a>Consumer가 서명 생성 후 Service Provider에 전송해서 Request Token을 발급 받고, Service Provider가 제공하는 User의 권한 부여 화면으로 리다이렉트</h3><p><img src="https://i.imgur.com/A2rXtbb.png" alt="Imgur"></p><h3 id="User가-앱-인증을-클릭하면-Consumer의-Callback-API로-리다이렉트"><a href="#User가-앱-인증을-클릭하면-Consumer의-Callback-API로-리다이렉트" class="headerlink" title="User가 앱 인증을 클릭하면 Consumer의 Callback API로 리다이렉트"></a>User가 앱 인증을 클릭하면 Consumer의 Callback API로 리다이렉트</h3><p><img src="https://i.imgur.com/ZsnjElz.png" alt="Imgur"></p><p>Callback API로 리다이렉트 되면 내부적으로 다음 2가지 과정이 진행된다.</p><ol><li>callback API에서 서명 생성 후 Service Provider에 전송해서 Access Token 발급 요청 전송</li><li>Access Token을 발급 받은 후 Service Provider의 자원에 접근 요청 전송(글쓰기 요청 전송)</li></ol><h3 id="접근-요청이-성공하면-화면에-성공-메시지-표시됨"><a href="#접근-요청이-성공하면-화면에-성공-메시지-표시됨" class="headerlink" title="접근 요청이 성공하면 화면에 성공 메시지 표시됨"></a>접근 요청이 성공하면 화면에 성공 메시지 표시됨</h3><p><img src="https://i.imgur.com/7wCyEr2.png" alt="Imgur"></p><h3 id="트위터에-접속하면-글이-써진-것을-확인할-수-있음"><a href="#트위터에-접속하면-글이-써진-것을-확인할-수-있음" class="headerlink" title="트위터에 접속하면 글이 써진 것을 확인할 수 있음"></a>트위터에 접속하면 글이 써진 것을 확인할 수 있음</h3><p><img src="https://i.imgur.com/Ks3ZjrK.png" alt="Imgur"></p><h1 id="매우-귀중한-보너스"><a href="#매우-귀중한-보너스" class="headerlink" title="매우 귀중한 보너스!!"></a>매우 귀중한 보너스!!</h1><p>고생은 나 하나로 족하다. Request Token 발급 요청, Access Token 발급 요청, 자원 접근 요청에 사용되는 서명값 계산 로직을 검증할 수 있는 테스트 케이스를 선사한다.</p><p>중간에 사용되는 <code>*Header</code>나 <code>OAuth10aSignatureSupport</code> 클래스는 구현 방식에 따라 달라질 수 있으니 신경쓰지 말고 아래 나오는 URL, ConsumerKey, ConsumerSecret, RequestTokenKey, RequestTokenSecret, AccessToken, AccessTokenSecret, Nonce, TimeStamp와 Signature 값으로 각자의 구현 로직을 테스트할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OAuth10aSignatureSupportTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OAuth10aSignatureSupport oa10aSigSupport = <span class="keyword">new</span> OAuth10aSignatureSupport();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestToken__sigTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        OAuth10aTemporaryCredentialRequestHeader header = <span class="keyword">new</span> OAuth10aTemporaryCredentialRequestHeader(</span><br><span class="line">                <span class="string">"https://api.twitter.com/oauth/request_token"</span>,</span><br><span class="line">                <span class="string">"YourAppConsumerKey"</span>,</span><br><span class="line">                <span class="string">"YourAppConsumerSecret"</span>,</span><br><span class="line">                <span class="string">"YourAppCallbackURL"</span></span><br><span class="line">        );</span><br><span class="line">        header.setOauthNonce(<span class="string">"NDg0ZDNjOTktYTJlMC00YmI5LThhMDktZDBkZGQ0MDA0ZTIw"</span>);</span><br><span class="line">        header.setOauthTimestamp(<span class="string">"1535288634"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        oa10aSigSupport.fillSignature(header);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertThat(header.getOauthSignature()).isEqualTo(<span class="string">"DNpRbry9XwYfEf+KXz4tV5Ufbpk="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accessToken__sigTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        OAuth10aTokenCredentialsRequestHeader header = <span class="keyword">new</span> OAuth10aTokenCredentialsRequestHeader(</span><br><span class="line">                <span class="string">"https://api.twitter.com/oauth/access_token"</span>,</span><br><span class="line">                <span class="string">"YourAppConsumerKey"</span>,</span><br><span class="line">                <span class="string">"YourAppConsumerSecret"</span>,</span><br><span class="line">                <span class="string">"YourRequestToken"</span>,</span><br><span class="line">                <span class="string">"YourRequestTokenSecret"</span>,</span><br><span class="line">                <span class="string">"YourOAuthVerifier"</span></span><br><span class="line">        );</span><br><span class="line">        header.setOauthNonce(<span class="string">"ZmRmNDQ5Y2YtN2IwNC00YzFkLTgxODItN2YwZmEzYjRhZTJj"</span>);</span><br><span class="line">        header.setOauthTimestamp(<span class="string">"1535289096"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        oa10aSigSupport.fillSignature(header);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertThat(header.getOauthSignature()).isEqualTo(<span class="string">"64lbyOhFJRcmudwWSwrmL1cQhEQ="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">protectedResources__sigTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        NextAction nextAction = <span class="keyword">new</span> NextAction(</span><br><span class="line">                HttpMethod.POST,</span><br><span class="line">                <span class="string">"https://api.twitter.com/1.1/statuses/update.json?status=OAuth10a%20Test"</span>,</span><br><span class="line">                <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        OAuth10aProtectedResourcesRequestHeader header =</span><br><span class="line">                <span class="keyword">new</span> OAuth10aProtectedResourcesRequestHeader(</span><br><span class="line">                        nextAction,</span><br><span class="line">                        <span class="string">"YourAppConsumerKey"</span>,</span><br><span class="line">                        <span class="string">"YourAppConsumerSecret"</span>,</span><br><span class="line">                        <span class="string">"YourAccessToken"</span>,</span><br><span class="line">                        <span class="string">"YourAccessTokenSecret"</span></span><br><span class="line">                );</span><br><span class="line">        header.setOauthTimestamp(<span class="string">"1535272771"</span>);</span><br><span class="line">        header.setOauthNonce(<span class="string">"Y2I0Yjk4ZDItZjg2OS00Y2VjLThkMjgtY2RmMWY0YzZiOTlj"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        oa10aSigSupport.fillSignature(header);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertThat(header.getOauthSignature()).isEqualTo(<span class="string">"de5B57uqqbMG/Z/6vm5i5kJaxxA="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;스펙따라-만들어보는-OAuth-1-0a-Client&quot;&gt;&lt;a href=&quot;#스펙따라-만들어보는-OAuth-1-0a-Client&quot; class=&quot;headerlink&quot; title=&quot;스펙따라 만들어보는 OAuth 1.0a Client&quot;&gt;&lt;/a&gt;스펙
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="OAuth" scheme="http://homoefficio.github.io/tags/OAuth/"/>
    
      <category term="OAuth 1.0a" scheme="http://homoefficio.github.io/tags/OAuth-1-0a/"/>
    
      <category term="Consumer" scheme="http://homoefficio.github.io/tags/Consumer/"/>
    
      <category term="Twitter" scheme="http://homoefficio.github.io/tags/Twitter/"/>
    
      <category term="Request Token" scheme="http://homoefficio.github.io/tags/Request-Token/"/>
    
      <category term="Temporary Credentials" scheme="http://homoefficio.github.io/tags/Temporary-Credentials/"/>
    
      <category term="OAuth verifier" scheme="http://homoefficio.github.io/tags/OAuth-verifier/"/>
    
      <category term="OAuth Callback" scheme="http://homoefficio.github.io/tags/OAuth-Callback/"/>
    
      <category term="Access Token" scheme="http://homoefficio.github.io/tags/Access-Token/"/>
    
      <category term="Token Credentials" scheme="http://homoefficio.github.io/tags/Token-Credentials/"/>
    
      <category term="Percent Encoding" scheme="http://homoefficio.github.io/tags/Percent-Encoding/"/>
    
      <category term="Signature" scheme="http://homoefficio.github.io/tags/Signature/"/>
    
      <category term="HMAC-SHA1" scheme="http://homoefficio.github.io/tags/HMAC-SHA1/"/>
    
      <category term="Spring Boot" scheme="http://homoefficio.github.io/tags/Spring-Boot/"/>
    
      <category term="트위터" scheme="http://homoefficio.github.io/tags/%ED%8A%B8%EC%9C%84%ED%84%B0/"/>
    
      <category term="요청 토큰" scheme="http://homoefficio.github.io/tags/%EC%9A%94%EC%B2%AD-%ED%86%A0%ED%81%B0/"/>
    
      <category term="접근 토큰" scheme="http://homoefficio.github.io/tags/%EC%A0%91%EA%B7%BC-%ED%86%A0%ED%81%B0/"/>
    
      <category term="스프링 부트" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8/"/>
    
  </entry>
  
</feed>
