<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>뒤태지존의 끄적거림</title>
  
  <subtitle>개발</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://homoefficio.github.io/"/>
  <updated>2018-10-13T15:49:56.226Z</updated>
  <id>http://homoefficio.github.io/</id>
  
  <author>
    <name>HomoEfficio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java URLClassLoader로 알아보는 클래스로딩</title>
    <link href="http://homoefficio.github.io/2018/10/14/Java-URLClassLoader%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%94%A9/"/>
    <id>http://homoefficio.github.io/2018/10/14/Java-URLClassLoader로-알아보는-클래스로딩/</id>
    <published>2018-10-13T15:13:39.000Z</published>
    <updated>2018-10-13T15:49:56.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-URLClassLoader로-알아보는-클래스로딩"><a href="#Java-URLClassLoader로-알아보는-클래스로딩" class="headerlink" title="Java URLClassLoader로 알아보는 클래스로딩"></a>Java URLClassLoader로 알아보는 클래스로딩</h1><p>Bootstrap ClassLoader, Extension ClassLoader, Application ClassLoader 이 3가지 기본 클래스로더 말고도 자주 사용되는<code>URLClassLoader</code>가 있다.<br>사실 Java 8의 Extension ClassLoader와 Application ClassLoader는 <code>URLClassLoader</code>를 상속받아서 만들어진 클래스다.</p><p>3가지 기본 클래스로더에 대한 자세한 내용은 <a href="https://github.com/HomoEfficio/dev-tips/blob/master/Java%20ClassLoader%20훑어보기.md" target="_blank" rel="noopener">여기</a>를 참고한다.</p><p>간단한 <code>URLClassLoader</code> 예제로 클래스로딩 과정을 짚어보자.</p><h1 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h1><h2 id="URLClassLoader-예제"><a href="#URLClassLoader-예제" class="headerlink" title="URLClassLoader 예제"></a>URLClassLoader 예제</h2><h3 id="ClassLoaderRunner"><a href="#ClassLoaderRunner" class="headerlink" title="ClassLoaderRunner"></a>ClassLoaderRunner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.nio.zipfs.ZipInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3 Default ClassLoader\n"</span>);</span><br><span class="line">        <span class="comment">// Bootstrap ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader bootStrapClassLoader = String.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"Bootstrap Classloader - ClassLoader of String.class: "</span> + bootStrapClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Extension ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader extensionClassLoader = ZipInfo.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"Extension Classloader - ClassLoader of ZipInfo.class: "</span> + extensionClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Application ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader applicationClassLoader = Internal.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"Application Classloader - ClassLoader of Internal.class: "</span> + applicationClassLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ClassLoader Hierarchy\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"BootStrap ClassLoader           : "</span> + bootStrapClassLoader);</span><br><span class="line">        System.out.println(<span class="string">"extensionClassLoader.getParent(): "</span> + extensionClassLoader.getParent());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Extension ClassLoader             : "</span> + extensionClassLoader);</span><br><span class="line">        System.out.println(<span class="string">"applicationClassLoader.getParent(): "</span> + applicationClassLoader.getParent());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 외부 폴더에 있는 파일 존재 확인</span></span><br><span class="line">        <span class="keyword">final</span> File classRepo = <span class="keyword">new</span> File(<span class="string">"C:/Temp/class-repo/"</span>);</span><br><span class="line"><span class="comment">//        System.out.println(classRepo.exists());</span></span><br><span class="line">        <span class="keyword">final</span> File abcClassFile = <span class="keyword">new</span> File(<span class="string">"C:/Temp/class-repo"</span>, <span class="string">"homo/efficio/classloader/External.class"</span>);</span><br><span class="line"><span class="comment">//        System.out.println(abcClassFile.exists());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader for External and Internal\n"</span>);</span><br><span class="line">            <span class="keyword">final</span> URLClassLoader urlClassLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123; classRepo.toURI().toURL() &#125;);</span><br><span class="line">            <span class="keyword">final</span> Class&lt;?&gt; externalFromUrl = urlClassLoader.loadClass(<span class="string">"homo.efficio.classloader.External"</span>);</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader of External: "</span> + externalFromUrl.getClassLoader());</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader of Internal: "</span> + Internal.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"URL 형식이 잘못되었습니다."</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"클래스가 없습니다."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간단하다. 먼저 3가지 기본 클래스로더를 출력해보고, 기본 클래스로더 사이의 위계 구조(Hierarchy)를 출력해서 확인해본다.</p><p>마지막으로 프로젝트 경로 외부에 있는 클래스를 <code>URLClassLoader</code>를 통해 읽어오는 부분이 있다. <code>URLClassLoader</code>를 생성할 때 <strong>URL만 인자로 넘기면 기본값으로 <code>ClassLoaderRunner</code>를 로딩한 애플리케이션 클래스로더가 parent classloader로 사용된다.</strong></p><p>유의해야할 점은 <strong>URLClassLoader의 생성자 인자로 URL을 넘겨줄 떄 <code>/</code>로 끝나는 문자열을 줘야 <code>.class</code> 파일을 인식할 수 있다</strong>는 점이다.</p><h3 id="Internal"><a href="#Internal" class="headerlink" title="Internal"></a>Internal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Internal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UUID uuid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter/setter 생략</span></span><br></pre></td></tr></table></figure><p>Internal 클래스는 그냥 별다른 특이점이 없는 일반적인 클래스다.</p><h3 id="External"><a href="#External" class="headerlink" title="External"></a>External</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">External</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Internal internal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter/setter 생략</span></span><br></pre></td></tr></table></figure><p>External 클래스는 컴파일 한 후에 클래스 파일을 프로젝트(클래스패스) 외부로 옮겨서 URLClassLoader 에 의해 로딩되는 부분을 테스트하는데 사용한다.</p><p>Internal 클래스를 필드로 가지고 있는데, External 클래스가 외부에서 로딩될 때 Internal 클래스의 로딩 여부를 확인하는 데 사용한다.</p><h2 id="실행-결과-1"><a href="#실행-결과-1" class="headerlink" title="실행 결과 - 1"></a>실행 결과 - 1</h2><p>클래스 파일을 전혀 손대지 않은 실행 결과는 다음과 같다.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------</span><br><span class="line"><span class="number">3</span> Default ClassLoader</span><br><span class="line"></span><br><span class="line">Bootstrap Classloader - ClassLoader of String<span class="selector-class">.class</span>: null</span><br><span class="line">Extension Classloader - ClassLoader of ZipInfo<span class="selector-class">.class</span>: sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$ExtClassLoader</span>@<span class="number">5</span>a07e868</span><br><span class="line">Application Classloader - ClassLoader of Internal<span class="selector-class">.class</span>: sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$AppClassLoader</span>@<span class="number">18</span>b4aac2</span><br><span class="line">-----------------------------------</span><br><span class="line">ClassLoader Hierarchy</span><br><span class="line"></span><br><span class="line">BootStrap ClassLoader           : null</span><br><span class="line">extensionClassLoader.getParent(): null</span><br><span class="line">Extension ClassLoader             : sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$ExtClassLoader</span>@<span class="number">5</span>a07e868</span><br><span class="line">applicationClassLoader.getParent(): sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$ExtClassLoader</span>@<span class="number">5</span>a07e868</span><br><span class="line">-----------------------------------</span><br><span class="line">ClassLoader <span class="keyword">for</span> External and Internal</span><br><span class="line"></span><br><span class="line">ClassLoader of External: sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$AppClassLoader</span>@<span class="number">18</span>b4aac2</span><br><span class="line">ClassLoader of Internal: sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$AppClassLoader</span>@<span class="number">18</span>b4aac2</span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit <span class="selector-tag">code</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="알-수-있는-점"><a href="#알-수-있는-점" class="headerlink" title="알 수 있는 점"></a>알 수 있는 점</h3><ul><li>Bootstrap ClassLoader는 <code>null</code> 로 표시된다. 실제로 Bootstrap ClassLoader는 Native C로 구현되어 있다.</li><li><code>jre/lib/ext</code> 폴더에 있는 jar 파일 안에 있는 <code>ZipInfo.class</code>를 통해 Extension ClassLoader를 확인할 수 있다.<ul><li>참고로 Java 9 에서는 모듈 시스템이 도입되면서 클래스로더에도 변화가 있었으며, <code>ZipInfo.class</code> 파일을 찾지 못해 컴파일 에러가 발생한다.</li></ul></li><li>External 클래스는 <code>URLClassLoader</code>를 통해 로딩을 시도하더라도, <strong>클래스 파일이 프로젝트 외부가 아닌 내부에 존재하고 있으면 클래스로딩 위임에 의해 <a href="https://github.com/HomoEfficio/dev-tips/blob/master/Java%20ClassLoader%20훑어보기.md" target="_blank" rel="noopener">여기</a>에 나온 것처럼 Application ClassLoader에 의해 로딩된다.</strong></li></ul><h2 id="External-클래스를-프로젝트-내부에서-외부로-옮긴-후-실행"><a href="#External-클래스를-프로젝트-내부에서-외부로-옮긴-후-실행" class="headerlink" title="External 클래스를 프로젝트 내부에서 외부로 옮긴 후 실행"></a>External 클래스를 프로젝트 내부에서 외부로 옮긴 후 실행</h2><p>다음 그림과 같이 External 클래스를 프로젝트 내부(즉 클래스패스)에서는 없애고 외부에만 존재하게 바꾸고 실행하면,</p><p><img src="https://i.imgur.com/uGY0oib.png" alt="Imgur"></p><p>다음과 같이 External 클래스가 Application ClassLoader가 아니라 <code>URLClassLoader</code>에 의해 로딩됨을 알 수 있다.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------</span><br><span class="line">ClassLoader <span class="keyword">for</span> External and Internal</span><br><span class="line"></span><br><span class="line">ClassLoader of External: java<span class="selector-class">.net</span><span class="selector-class">.URLClassLoader</span>@<span class="number">2</span>c7b84de</span><br><span class="line">ClassLoader of Internal: sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$AppClassLoader</span>@<span class="number">18</span>b4aac2</span><br></pre></td></tr></table></figure><h3 id="알-수-있는-점-1"><a href="#알-수-있는-점-1" class="headerlink" title="알 수 있는 점"></a>알 수 있는 점</h3><ul><li>컴파일 된 클래스 파일을 클래스패스 외부에 두고 <code>URLClassLoader</code>로 로딩할 수 있다.</li><li>외부에 있는 클래스 파일에 포함되어 있는 Internal는 클래스로더 위임에 따라 원래대로 Application ClassLoader에서 로딩한다.<ul><li><strong>즉 클래스패스 외부에 있는 클래스 파일이 클래스패스 내부에 있는 클래스를 참조하더라도 둘 모두 문제 없이 로딩해서 조합해서 사용할 수 있다.</strong></li></ul></li></ul><h1 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h1><h2 id="URLClassLoader-예제-1"><a href="#URLClassLoader-예제-1" class="headerlink" title="URLClassLoader 예제"></a>URLClassLoader 예제</h2><p>External, Internal 클래스는 Java 8 예제와 동일하고, main 클래스만 Java 9 에 맞게 조금 수정해야 한다.</p><h3 id="ClassLoaderRunner9"><a href="#ClassLoaderRunner9" class="headerlink" title="ClassLoaderRunner9"></a>ClassLoaderRunner9</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> homo.efficio@gmail.com</span></span><br><span class="line"><span class="comment"> * Created on 2018-10-11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderRunner9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3 Default ClassLoader\n"</span>);</span><br><span class="line">        <span class="comment">// Bootstrap ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader bootStrapClassLoader = String.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"Bootstrap Classloader - ClassLoader of String.class: "</span> + bootStrapClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Platform ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader platformClassLoader = ClassLoader.getPlatformClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"Platform Classloader - ClassLoader.getPlatformClassLoader(): "</span> + platformClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System ClassLoader 확인</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"System Classloader - ClassLoader.getSystemClassLoader()    : "</span> + systemClassLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ClassLoader Hierarchy\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"BootStrap ClassLoader           : "</span> + bootStrapClassLoader);</span><br><span class="line">        System.out.println(<span class="string">"platformClassLoader.getParent() : "</span> + platformClassLoader.getParent());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Platform ClassLoader             : "</span> + platformClassLoader);</span><br><span class="line">        System.out.println(<span class="string">"systemClassLoader.getParent()    : "</span> + systemClassLoader.getParent());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 외부 폴더에 있는 파일 존재 확인</span></span><br><span class="line">        <span class="keyword">final</span> File classRepo = <span class="keyword">new</span> File(<span class="string">"C:/Temp/class-repo/"</span>);</span><br><span class="line"><span class="comment">//        System.out.println(classRepo.exists());</span></span><br><span class="line">        <span class="keyword">final</span> File abcClassFile = <span class="keyword">new</span> File(<span class="string">"C:/Temp/class-repo"</span>, <span class="string">"homo/efficio/classloader/External.class"</span>);</span><br><span class="line"><span class="comment">//        System.out.println(abcClassFile.exists());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader for External and Internal\n"</span>);</span><br><span class="line">            <span class="keyword">final</span> URLClassLoader urlClassLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123; classRepo.toURI().toURL() &#125;);</span><br><span class="line">            <span class="keyword">final</span> Class&lt;?&gt; externalFromUrl = urlClassLoader.loadClass(<span class="string">"homo.efficio.classloader.External"</span>);</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader of External: "</span> + externalFromUrl.getClassLoader());</span><br><span class="line">            System.out.println(<span class="string">"ClassLoader of Internal: "</span> + Internal.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"URL 형식이 잘못되었습니다."</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"클래스가 없습니다."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8과 달라진 점은 Platform ClassLoader와 System ClassLoader를 <code>ZipInfo.class</code>나 <code>Internal.class</code>와 같은 개별 클래스의 <code>getClassLoader()</code>가 아니라 <strong><code>ClassLoader.getPlatformClassLoader()</code>, <code>ClassLoader.getSystemClassLoader()</code>와 같이 <code>ClassLoader</code>의 static 메서드를 통해 직접 가졍로 수 있다</strong>는 점이다.</p><h2 id="실행-결과"><a href="#실행-결과" class="headerlink" title="실행 결과"></a>실행 결과</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------</span><br><span class="line"><span class="number">3</span> Default ClassLoader</span><br><span class="line"></span><br><span class="line">Bootstrap Classloader - ClassLoader of String<span class="selector-class">.class</span>: null</span><br><span class="line">Platform Classloader - ClassLoader.getPlatformClassLoader(): jdk<span class="selector-class">.internal</span><span class="selector-class">.loader</span><span class="selector-class">.ClassLoaders</span><span class="variable">$PlatformClassLoader</span>@e73f9ac</span><br><span class="line">System Classloader - ClassLoader.getSystemClassLoader()    : jdk<span class="selector-class">.internal</span><span class="selector-class">.loader</span><span class="selector-class">.ClassLoaders</span><span class="variable">$AppClassLoader</span>@<span class="number">726</span>f3b58</span><br><span class="line">-----------------------------------</span><br><span class="line">ClassLoader Hierarchy</span><br><span class="line"></span><br><span class="line">BootStrap ClassLoader           : null</span><br><span class="line">platformClassLoader.getParent() : null</span><br><span class="line">Platform ClassLoader             : jdk<span class="selector-class">.internal</span><span class="selector-class">.loader</span><span class="selector-class">.ClassLoaders</span><span class="variable">$PlatformClassLoader</span>@e73f9ac</span><br><span class="line">systemClassLoader.getParent()    : jdk<span class="selector-class">.internal</span><span class="selector-class">.loader</span><span class="selector-class">.ClassLoaders</span><span class="variable">$PlatformClassLoader</span>@e73f9ac</span><br><span class="line">-----------------------------------</span><br><span class="line">ClassLoader <span class="keyword">for</span> External and Internal</span><br><span class="line"></span><br><span class="line">ClassLoader of External: java<span class="selector-class">.net</span><span class="selector-class">.URLClassLoader</span>@<span class="number">96532</span>d6</span><br><span class="line">ClassLoader of Internal: jdk<span class="selector-class">.internal</span><span class="selector-class">.loader</span><span class="selector-class">.ClassLoaders</span><span class="variable">$AppClassLoader</span>@<span class="number">726</span>f3b58</span><br><span class="line">-----------------------------------</span><br></pre></td></tr></table></figure><p>클래스로더의 패키지와 이름이 좀 달라지기는 했지만, 기본 클래스로더의 3계층 구조나 3가지 원칙 등 내용적으로는 Java 8과 같다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><p>URLClassLoader를 사용하면 클래스패스 외부에 있는 클래스를 로딩해서 클래스패스 내부에 있는 클래스와 조합해서 사용할 수 있다.</p><p>URLClassLoader로 개별 <code>.class</code> 파일을 로딩하려면 해당 클래스 파일을 포함한 URL이 <code>/</code>로 끝나야 한다.</p><p>URLClassLoader로 로딩을 시도하더라도 클래스 파일이 클래스패스 내에 존재하면 클래스로더 위임 원칙에 의해 URLClassLoader가 아닌 애플리케이션 클래스로더(Java 9부터는 시스템 클래스로더)에 의해 로딩된다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-URLClassLoader로-알아보는-클래스로딩&quot;&gt;&lt;a href=&quot;#Java-URLClassLoader로-알아보는-클래스로딩&quot; class=&quot;headerlink&quot; title=&quot;Java URLClassLoader로 알아보는 클래스로
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="ClassLoader" scheme="http://homoefficio.github.io/tags/ClassLoader/"/>
    
      <category term="Default ClassLoader" scheme="http://homoefficio.github.io/tags/Default-ClassLoader/"/>
    
      <category term="Bootstrap ClassLoader" scheme="http://homoefficio.github.io/tags/Bootstrap-ClassLoader/"/>
    
      <category term="Extension ClassLoader" scheme="http://homoefficio.github.io/tags/Extension-ClassLoader/"/>
    
      <category term="Application ClassLoader" scheme="http://homoefficio.github.io/tags/Application-ClassLoader/"/>
    
      <category term="URLClassLoader" scheme="http://homoefficio.github.io/tags/URLClassLoader/"/>
    
      <category term="ClassLoader Delegation" scheme="http://homoefficio.github.io/tags/ClassLoader-Delegation/"/>
    
      <category term="Delegation Principle" scheme="http://homoefficio.github.io/tags/Delegation-Principle/"/>
    
      <category term="Visibility Principle" scheme="http://homoefficio.github.io/tags/Visibility-Principle/"/>
    
      <category term="Uniqueness Principle" scheme="http://homoefficio.github.io/tags/Uniqueness-Principle/"/>
    
      <category term="Java 9" scheme="http://homoefficio.github.io/tags/Java-9/"/>
    
      <category term="Platform ClassLoader" scheme="http://homoefficio.github.io/tags/Platform-ClassLoader/"/>
    
      <category term="System ClassLoader" scheme="http://homoefficio.github.io/tags/System-ClassLoader/"/>
    
      <category term="자바 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="부트스트랩 클래스로더" scheme="http://homoefficio.github.io/tags/%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="애플리케이션 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="플랫폼 클래스로더" scheme="http://homoefficio.github.io/tags/%ED%94%8C%EB%9E%AB%ED%8F%BC-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="시스템 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
  </entry>
  
  <entry>
    <title>Java 클래스로더 훑어보기</title>
    <link href="http://homoefficio.github.io/2018/10/13/Java-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94-%ED%9B%91%EC%96%B4%EB%B3%B4%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2018/10/13/Java-클래스로더-훑어보기/</id>
    <published>2018-10-13T12:58:48.000Z</published>
    <updated>2018-10-13T15:49:56.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-ClassLoader-훑어보기"><a href="#Java-ClassLoader-훑어보기" class="headerlink" title="Java ClassLoader 훑어보기"></a>Java ClassLoader 훑어보기</h1><p>아주 예전에 SCJP 시험볼 때나 살펴본 이후로 자바의 클래스로더를 직접 다뤄야 할 일은 솔직히 없었다. 그래서 거의 잊고 살아왔는데 요즘 Quartz를 다루면서 Quartz에 없는 기능인 외부 Job 클래스 로딩 기능을 만들면서 정말로 오랜만에 들여다보게 됐다.</p><p>클래스로더는 Java9에 모듈 시스템이 도입되면서 적지 않은 변경이 있었다. 자세한 내용은 <a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-D867DCCC-CEB5-4AFA-9D11-9C62B7A3FAB1" target="_blank" rel="noopener">https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-D867DCCC-CEB5-4AFA-9D11-9C62B7A3FAB1</a> 를 참고하고, 먼저 Java8 까지 적용됐던 내용을 기준으로 되짚어보자.</p><h1 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h1><h2 id="3가지-기본-클래스로더"><a href="#3가지-기본-클래스로더" class="headerlink" title="3가지 기본 클래스로더"></a>3가지 기본 클래스로더</h2><p><img src="https://i.imgur.com/cs5Qyoe.png" alt="Imgur"></p><h3 id="Bootstrap-ClassLoader"><a href="#Bootstrap-ClassLoader" class="headerlink" title="Bootstrap ClassLoader"></a>Bootstrap ClassLoader</h3><ul><li>부트스트랩 클래스로더는 3가지 기본 클래스로더 중 최상위 클래스로더로서, 쉽게 말하면 <code>jre/lib/rt.jar</code>에 담긴 JDK 클래스 파일을 로딩한다. </li><li>Native C로 구현돼 있어서, <code>String.class.getClassLoader()</code>는 그냥 <code>null</code>을 반환한다. Primordial ClassLoader 라고 불리기도 한다.</li></ul><h3 id="Extension-ClassLoader"><a href="#Extension-ClassLoader" class="headerlink" title="Extension ClassLoader"></a>Extension ClassLoader</h3><ul><li>익스텐션 클래스로더는 <code>jre/lib/ext</code> 폴더나 <code>java.ext.dirs</code> 환경 변수로 지정된 폴더에 있는 클래스 파일을 로딩한다. </li><li>Java로 구현되어 있으며 <code>sun.misc.Launcher</code> 클래스 안에 static 클래스로 구현되어 있으며, <code>URLClassLoader</code>를 상속하고 있다.</li></ul><h3 id="Application-ClassLoader"><a href="#Application-ClassLoader" class="headerlink" title="Application ClassLoader"></a>Application ClassLoader</h3><ul><li>애플리케이션 클래스로더는 <code>-classpath(또는 -cp)</code>나 JAR 파일 안에 있는 Manifest 파일의 <code>Class-Path</code> 속성값으로 지정된 폴더에 있는 클래스를 로딩한다.</li><li>익스텐션 클래스로더와 마찬가지로 Java로 구현되어 있으며, <code>sun.misc.Launcher</code> 클래스 안에 static 클래스로 구현되어 있으며, <code>URLClassLoader</code>를 상속하고 있다.</li><li>개발자가 애플리케이션 구동을 위해 직접 작성한 대부분의 클래스는 이 애플리케이션 클래스로더에 의해 로딩된다.</li></ul><h2 id="3가지-원칙"><a href="#3가지-원칙" class="headerlink" title="3가지 원칙"></a>3가지 원칙</h2><p>자바 클래스로더는 3이라는 숫자와 친해 보인다. 기본 클래스로더가 3가지이고, 작동 원칙도 3가지다.</p><h3 id="Delegation-Principle"><a href="#Delegation-Principle" class="headerlink" title="Delegation Principle"></a>Delegation Principle</h3><p>위임 원칙은 클래스 로딩이 필요할 때 <strong>3가지 기본 클래스로더의 윗 방향으로 클래스 로딩을 위임하는 것</strong>을 말한다. <code>main()</code> 메서드가 포함된 <code>ClassLoaderRunner</code> 클래스에서 개발자가 직접 작성한 <code>Internal</code> 클래스를 로딩하는 과정을 그림으로 표현하면 다음과 같다.</p><p><img src="https://i.imgur.com/kijdBjb.png" alt="Imgur"></p><ol><li><p><code>ClassLoaderRunner</code>는 자기 자신을 로딩한 애플리케이션 클래스로더에게 <code>Internal</code> 클래스 로딩을 요청한다.</p></li><li><p>클래스 로딩 요청을 받은 애플리케이션 클래스로더는 <code>Internal</code>을 스스로 직접 로딩하지 않고 상위 클래스로더인 익스텐션 클래스로더에게 위임한다.</p></li><li><p>클래스 로딩 요청을 받은 익스텐션 클래스로더도 <code>Internal</code>을 스스로 직접 로딩하지 않고 상위 클래스로더인 부트스트랩 클래스로더에게 위임한다.</p></li><li><p>부트스트랩 클래스로더는 <code>rt.jar</code>에서 <code>Internal</code>을 찾아서</p><p> 4.1 있으면 로딩 후 반환하고</p></li><li><p>없으면 익스텐션 클래스로더가 <code>jre/lib/ext</code> 폴더나 <code>java.ext.dirs</code> 환경 변수로 지정된 폴더에서 <code>Internal</code>을 찾아서</p><p> 5.1 있으면 로딩 후 반환하고</p></li><li><p>없으면 애플리케이션 클래스로더가 클래스패스에서 <code>Internal</code>을 찾아서</p><p> 6.1 있으면 로딩 후 반환하고</p></li><li><p>없으면 <code>ClassNotFoundException</code>이 발생한다.</p></li></ol><p>이런 식으로 동작하는 이유는 두 번째 원칙인 Visibility Principle과 관련이 있다.</p><h3 id="Visibility-Principle"><a href="#Visibility-Principle" class="headerlink" title="Visibility Principle"></a>Visibility Principle</h3><p>가시범위 원칙은 <strong>하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 볼 수 있지만, 상위 클래스로더는 하위 클래스로더가 로딩한 클래스를 볼 수 없다</strong>는 원칙이다.</p><p>만약에 개발자가 만든 클래스를 로딩하는 애플리케이션 클래스로더가 부트스트랩 클래스로더에 의해 로딩된 <code>String.class</code>를 볼 수 없다면 애플리케이션은 <code>String.class</code>를 사용할 수 없을 것이다. 따라서 하위에서는 상위를 볼 수 있어야 애플리케이션이 제대로 동작할 수 있다.</p><p>상위에서도 하위를 볼 수 있다면 상/하위 구분이 사실상 없어진다. 클래스로더를 3가지로 나눈 이유가 있을텐데 상위가 하위를 볼 수 있으면 구분 의미가 희석돼버린다.</p><p>따라서 하위에서는 상위를 볼 수 있지만 상위에서는 하위를 볼 수 없어야 한다.</p><h3 id="Uniqueness-Principle"><a href="#Uniqueness-Principle" class="headerlink" title="Uniqueness Principle"></a>Uniqueness Principle</h3><p>유일성 원칙은 <strong>하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 다시 로딩하지 않게 해서 로딩된 클래스의 유일성을 보장</strong>하는 것이다. 유일성을 식별하는 기준은 클래스의 <code>binary name</code>인데, <code>toString()</code>으로 찍다보면 가끔 보이는 <code>java.lang.String</code>, <code>javax.swing.JSpinner$DefaultEditor</code>, <code>java.security.KeyStore$Builder$FileBuilder$1</code>, <code>java.net.URLClassLoader$3$1</code> 이런 것들이 바로 <code>binary name</code>이다. <code>binary name</code>의 자세한 내용은 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1</a> 를 참고한다.</p><h1 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h1><p>Java 9 에서도 기본 클래스로더의 3계층 구조와 3가지 원칙은 그대로 유효하다. 다만 모듈 시스템 도입에 맞춰 이름과 범위, 구현 내용 등이 바뀌었다.</p><p><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-EEED398E-AE37-4D12-AB10-49F82F720027" target="_blank" rel="noopener">https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-EEED398E-AE37-4D12-AB10-49F82F720027</a> 요 내용 중 ClassLoader에 관련된 내용만 추려보면 다음과 같다.</p><h2 id="한-표-요약"><a href="#한-표-요약" class="headerlink" title="한 표 요약"></a>한 표 요약</h2><table><thead><tr><th>Java 8</th><th>Java 9</th><th>달라진 점</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>이름 그대로</td><td>- rt.jar 등이 없어짐에 따라 로딩할 수 있는 클래스의 범위가 전반적으로 축소 <br> - 따라서 parent classloader 인자로 <code>null</code>을 넘겨주며 Bootstrap ClassLoader를 parent classloader로 사용했던 코드 수정 필요할 수 있음</td></tr><tr><td>Extension ClassLoader</td><td>Platform ClassLoader</td><td>- <code>jre/lib/ext</code>, <code>java.ext.dirs</code>를 지원하지 않음 <br> - Java SE의 모든 클래스와 Java SE에는 없지만 JCP에 의해 표준화 된 모듈 내의 클래스를 볼 수 있으며, Java 8에 비해 볼 수 있는 범위가 확장됨 <br> - <code>URLClassLoader</code>가 아닌 <code>BuiltinClassLoader</code>를 상속받아 <code>ClassLoaders</code> 클래스의 내부 static 클래스로 구현됨</td></tr><tr><td>Application ClassLoader</td><td>System ClassLoader</td><td>- 클래스패스, 모듈패스에 있는 클래스 로딩 <br> - <code>URLClassLoader</code>가 아닌 <code>BuiltinClassLoader</code>를 상속받아 <code>ClassLoaders</code> 클래스의 내부 static 클래스로 구현됨</td></tr></tbody></table><h2 id="rt-jar-tools-jar-가-제거됨"><a href="#rt-jar-tools-jar-가-제거됨" class="headerlink" title="rt.jar, tools.jar 가 제거됨"></a>rt.jar, tools.jar 가 제거됨</h2><p><code>rt.jar</code>, <code>tools.jar</code> 등 기본으로 제공되던 jar 파일이 없어지고 그 안에 있던 내용들은 모듈 시스템에 맞게 더 효율적으로 재편되어 <code>lib</code> 폴더 안에 저장된다. 이에 따라 <code>rt.jar</code>내의 모든 클래스를 로딩할 수 있던 Bootstrap ClassLoader가 로딩할 수 있는 클래스의 범위도 전체적으로 줄어들었다.</p><p>따라서 <strong>Bootstrap ClassLoader를 parent classloader로 사용하던 코드에서는 문제가 발생할 수 있다.</strong> </p><p>이럴 때는 <strong>Bootstrap Classloader를 의미하는 <code>null</code> 대신 <code>Classloader.getPlatformClassLoader()</code>를 인자로 넘겨서 가시 범위가 확장된 Platform ClassLoader를 parent classloader로 사용하면 된다.</strong></p><h2 id="jre-lib-ext-java-ext-dirs-lib-endorsed-java-endorsed-dirs-가-제거됨"><a href="#jre-lib-ext-java-ext-dirs-lib-endorsed-java-endorsed-dirs-가-제거됨" class="headerlink" title="jre/lib/ext, java.ext.dirs, lib/endorsed, java.endorsed.dirs 가 제거됨"></a>jre/lib/ext, java.ext.dirs, lib/endorsed, java.endorsed.dirs 가 제거됨</h2><p><code>jre/lib/ext</code>, <code>lib/endorsed</code> 가 파일시스템에 존재하거나 <code>java.ext.dirs</code>, <code>java.endorsed.dirs</code>가 환경변수로 설정되어 있으면 <code>javac</code>나 <code>java</code>는 실행이 종료된다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><p>Java에는 3가지 기본 클래스로더가 있다.</p><ol><li><p>부트스트랩 클래스로더</p></li><li><p>익스텐션 클래스로더(Java 9부터는 플랫폼 클래스로더)</p></li><li><p>애플리케이션 클래스로더(Java 9부터 시스템 클래스로더)</p></li></ol><p>클래스로더 동작에는 3가지 원칙이 있다.</p><ol><li><p>위임 원칙: 클래스로딩 작업을 상위 클래스로더에 위임한다.</p></li><li><p>가시 범위 원칙: 하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 볼 수 있지만, 상위 클래스로더는 하위 클래스로더가 로딩한 클래스를 볼 수 없다.</p></li><li><p>유일성 원칙: 하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 다시 로딩하지 않게 해서 로딩된 클래스의 유일성을 보장한다.</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-ClassLoader-훑어보기&quot;&gt;&lt;a href=&quot;#Java-ClassLoader-훑어보기&quot; class=&quot;headerlink&quot; title=&quot;Java ClassLoader 훑어보기&quot;&gt;&lt;/a&gt;Java ClassLoader 훑어보기&lt;/
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="ClassLoader" scheme="http://homoefficio.github.io/tags/ClassLoader/"/>
    
      <category term="Default ClassLoader" scheme="http://homoefficio.github.io/tags/Default-ClassLoader/"/>
    
      <category term="Bootstrap ClassLoader" scheme="http://homoefficio.github.io/tags/Bootstrap-ClassLoader/"/>
    
      <category term="Extension ClassLoader" scheme="http://homoefficio.github.io/tags/Extension-ClassLoader/"/>
    
      <category term="Application ClassLoader" scheme="http://homoefficio.github.io/tags/Application-ClassLoader/"/>
    
      <category term="ClassLoader Delegation" scheme="http://homoefficio.github.io/tags/ClassLoader-Delegation/"/>
    
      <category term="Delegation Principle" scheme="http://homoefficio.github.io/tags/Delegation-Principle/"/>
    
      <category term="Visibility Principle" scheme="http://homoefficio.github.io/tags/Visibility-Principle/"/>
    
      <category term="Uniqueness Principle" scheme="http://homoefficio.github.io/tags/Uniqueness-Principle/"/>
    
      <category term="Java 9" scheme="http://homoefficio.github.io/tags/Java-9/"/>
    
      <category term="Platform ClassLoader" scheme="http://homoefficio.github.io/tags/Platform-ClassLoader/"/>
    
      <category term="System ClassLoader" scheme="http://homoefficio.github.io/tags/System-ClassLoader/"/>
    
      <category term="자바 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="부트스트랩 클래스로더" scheme="http://homoefficio.github.io/tags/%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="애플리케이션 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="플랫폼 클래스로더" scheme="http://homoefficio.github.io/tags/%ED%94%8C%EB%9E%AB%ED%8F%BC-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
      <category term="시스템 클래스로더" scheme="http://homoefficio.github.io/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94/"/>
    
  </entry>
  
  <entry>
    <title>스펙따라 만들어보는 OAuth 1.0a Client</title>
    <link href="http://homoefficio.github.io/2018/08/27/%EC%8A%A4%ED%8E%99%EB%94%B0%EB%9D%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EB%8A%94-OAuth-1-0a-Client/"/>
    <id>http://homoefficio.github.io/2018/08/27/스펙따라-만들어보는-OAuth-1-0a-Client/</id>
    <published>2018-08-26T15:20:58.000Z</published>
    <updated>2018-10-13T15:49:56.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="스펙따라-만들어보는-OAuth-1-0a-Client"><a href="#스펙따라-만들어보는-OAuth-1-0a-Client" class="headerlink" title="스펙따라 만들어보는 OAuth 1.0a Client"></a>스펙따라 만들어보는 OAuth 1.0a Client</h1><h2 id="OAuth-탄생-배경"><a href="#OAuth-탄생-배경" class="headerlink" title="OAuth 탄생 배경"></a>OAuth 탄생 배경</h2><ul><li><p>많은 서비스가 API를 통해 서로 연결</p><blockquote><p><strong>내가 A라는 앱에 쓴 글이 내 트위터 타임라인에도 표시되면 좋겠다.</strong></p></blockquote></li><li><p>하지만 A 앱은 내 트위터 타임라인에 글을 쓸 권한이 없다.</p></li><li><p>물론 A 앱이 내 트위터 계정 정보를 알고 있다면 A 앱이 내 트위터 타임라인에 글을 쓸 수 있겠지만,</p></li><li><p>필요한 것은 글을 쓸 수 있는 권한 뿐인데 계정 정보를 모두 A 앱에게 알려줄 필요는 없다.</p></li><li><p>따라서 내가 A 앱에게 글을 쓸 권한을 줬다는 사실을 트위터에게 알려주고,</p></li><li><p>그 사실을 트위터가 확인할 수 있다면,</p></li><li><p>내 계정 정보를 A 앱에게 알려주지 않고도 A 앱이 트위터에 글을 쓸 수 있게 된다.</p></li><li><p><strong>내가 A 앱에 쓴 글을 내 트위터 타임라인에도 표시</strong>하려면 결국 다음의 질문에 대한 답이 필요하다.</p><blockquote><p><strong>내가 A 앱에게 권한을 줬다는 사실을 트위터에게 어떻게 알려줄 수 있을까?</strong></p></blockquote></li></ul><h1 id="OAuth-1-0a"><a href="#OAuth-1-0a" class="headerlink" title="OAuth 1.0a"></a>OAuth 1.0a</h1><p>어떤 행위(내가 A 앱에게 트위터에 글을 쓸 권한을 준 행위)가 이루어졌음을 프로그래밍을 통해 증명하는 여러 방식 중에 대표적으로 서명(Signature)이라는 것이 있다.</p><p>아래 그림은 서명 방식 중에서 HMAC(Hashed Message Authentication Code)를 보여주고 있다.</p><p><img src="https://www.thinqloud.com/wp-content/uploads/2017/07/blog_banner_2-1.jpg" alt=""><br>(출처: <a href="https://www.thinqloud.com/hmac-authentication-in-salesforce/" target="_blank" rel="noopener">https://www.thinqloud.com/hmac-authentication-in-salesforce/</a>)</p><ul><li>송신자와 수신자가 비밀키를 공유하고,</li><li>송신자는 평문(빨간 문서 아이콘)과 비밀키를 함께 해시한 값(MAC)과 평문을 함께 수신자에게 보내면,</li><li>수신자는 송신자가 보낸 평문과 송신자와 공유하고 있는 비밀키를 함께 해시한 값(Hash Output)을 계산하고,</li><li>계산한 값이 송신자가 보낸 MAC 값과 같은지 비교해서 평문(어떤 행위)이 송신자로부터 전송되었음을 확인한다.</li></ul><p>OAuth 1.0a는 권한을 줬다는 사실을 위와 같은 서명 방식을 이용해서 증명한다. </p><p>과정이 조금 복잡한 면이 있어서 요즘은 조금 더 간단하고 편리한 OAuth 2.0이 더 많이 사용되지만, 편리한 만큼 보안성을 양보해야 한다. </p><p>OAuth 1.0a를 이해하면 OAuth 2.0을 쉽게 이해할 수 있으므로 학습 관점에서는 OAuth 1.0a를 먼저 공부하는 것이 의미가 있다.</p><p>이제 OAuth 1.0a를 좀더 구체적으로 알아보자.</p><h2 id="등장-인물-이라-쓰고-용어라고-읽"><a href="#등장-인물-이라-쓰고-용어라고-읽" class="headerlink" title="등장 인물(이라 쓰고 용어라고 읽..)"></a>등장 인물(이라 쓰고 용어라고 읽..)</h2><ul><li>Resource Owner: 트위터 계정을 가지고 있는 트위터 사용자. 앱 A에 대한 사용권한도 가지고 있다.</li><li>Client: 트위터 API를 이용해서 트위터에 글을 남기려는 앱 A.</li><li><p>Server: API로 서비스를 제공하는 트위터.</p></li><li><p>Client Credentials: 등록을 요청한 Client 앱에게 Server가 발급한 등록 정보</p></li><li>Temporary Credentials: Client의 권한 부여 요청을 확인하고 Server가 발급한 임시 확인 정보</li><li>Token Credentials: 사용자로부터 권한을 부여받았음을 확인하고 Server가 발급한 접근 토큰 정보</li></ul><p>참고로 다음과 같이 가리키는 대상은 같지만 <a href="https://oauth.net/core/1.0/" target="_blank" rel="noopener">OAuth 1.0</a>과 <a href="https://tools.ietf.org/html/rfc5849" target="_blank" rel="noopener">OAuth 1.0a</a>에서의 용어가 다르며, 커뮤니티 버전인 OAuth 1.0의 용어를 그대로 쓰고 있는 자료도 많다.</p><table><thead><tr><th>OAuth 1.0</th><th>OAuth 1.0a</th></tr></thead><tbody><tr><td>User</td><td>Resource Owner</td></tr><tr><td>Consumer</td><td>Client</td></tr><tr><td>Service Provider</td><td>Server</td></tr><tr><td>Consumer Key and Secret</td><td>Client Credentials</td></tr><tr><td>Request Token and Secret</td><td>Temporary Credentials</td></tr><tr><td>Access Token and Secret</td><td>Token Credentials</td></tr></tbody></table><p><strong>1.0의 용어가 더 구별하기 쉽고 직관적이어서 학습하기에 좋으므로 본 글에서는 1.0 용어를 사용한다.</strong> 1.0 용어로 이해한 후에는 1.0a의 용어도 쉽게 받아들일 수 있을 것이다.</p><p>한 가지 짚고 넘어갈 용어로 Secret이 있는데, 서명 방식에서 <strong>Secret은 Service Provider가 Consumer에게 발급하고 둘이 각자 보유하고 있다가 필요할 떄 사용할 뿐 온라인으로 주고 받지 않는 정보</strong>다.</p><h2 id="사전-조건"><a href="#사전-조건" class="headerlink" title="사전 조건"></a>사전 조건</h2><ul><li>Consumer는 Service Provider의 API를 이용할 수 있도록 등록되어 있어야 한다.</li><li>User는 Consumer와 Service Provider 모두를 사용할 수 있는 권한을 가지고 있다.</li></ul><h2 id="Service-Provider로부터-확인-받아야-하는-사항"><a href="#Service-Provider로부터-확인-받아야-하는-사항" class="headerlink" title="Service Provider로부터 확인 받아야 하는 사항"></a>Service Provider로부터 확인 받아야 하는 사항</h2><ul><li>Consumer는 User로부터 권한 부여 요청을 받았다는 사실을 Service Provider로부터 확인 받아야 함 - (1)</li><li>User는 Service Provider의 사용자임을 Service Provider로부터 확인 받아야 함 - (2)</li><li>User는 Consumer에게 권한을 부여했음을 Service Provider로부터 확인 받아야 함 - (3)</li></ul><p>이 3가지 확인을 받기위한 절차를 개략적으로 생각해보자</p><h2 id="절차-개요"><a href="#절차-개요" class="headerlink" title="절차 개요"></a>절차 개요</h2><ol><li><p>User가 Consumer에 글을 쓰고 ‘Service Provider에도 남기기’ 버튼을 누른다.</p></li><li><p>Consumer는 자신의 등록 정보를 바탕으로 Signature를 만들고 Service Provider에게 Signature를 보내서 사용자로부터 권한 부여 요청을 받았음을 Service Provider에게 알리고, Service Provider는 권한 부여 요청을 확인했다는 임시 증표(Request Token)를 저장하고 Request Token을 Consumer에게 발급한다. (1)</p></li><li><p>Consumer는 권한 부여 요청 확인 증표(Request Token)와 함께 User의 요청을 Service Provider의 인가(권한 부여) 화면으로 리다이렉트한다.</p></li><li><p>User가 Service Provider에 로그인 한 상태가 아니라면 로그인 한다. (2)</p></li><li><p>인가 화면에는 ‘Consumer에게 권한 부여’ 버튼이 표시된다.</p></li><li><p>User가 ‘Consumer에게 권한 부여’ 버튼을 클릭하면, Service Provider는 User가 (Request Token을 확인하고) Consumer에게 권한을 부여했음을 확인하고, 확인 코드(Verifier 또는 Authorization_code)를 저장 및 User에게 반환하고 Consumer가 제공하는 callback 화면으로 리다이렉트한다. (3)</p></li><li><p>리다이렉트를 통해 권한 부여 확인 코드를 전달 받은 Consumer는 Consumer Key, Request Token, Verifier 등을 대상으로 Consumer Secret, Request Token Secret를 이용해서 Signature를 만들고 Service Provider에게 Signature를 보낸다.</p></li><li><p>Service Provider는 Consumer가 보낸 Signature를 확인하고 User만 접근할 수 있었던 보호 자원에 대한 접근 증표(Access Token)를 Consumer에게 발급한다.</p></li><li><p>이후 Consumer는 Access Token를 Service Provider에게 보여주면서 User를 대신해서 보호 자원에 접근한다.</p></li></ol><p>6번까지 진행되면 확인해야 할 3가지 사항은 모두 확인했으므로 바로 보호 자원에 대한 Access Token을 발급할 수 있지만, 6번에서 발급하면 증표가 User에게 직접 발급되고 User의 Local Storage나 Session에 남을 수 있으므로 유출 가능성이 발생한다. 따라서 6번에서는 발급하지 않고 8번에서 Consumer에게 발급한다.</p><p>위 과정에서 ‘권한 부여 요청 확인 증표’를 <code>Request Token</code>, ‘권한 부여 확인 코드’를 <code>Verifier 또는 AuthorizationCode</code>, ‘보호 자원 접근 증표’를 <code>Access Token</code>이라고 부른다.</p><h2 id="Sequence-Diagram"><a href="#Sequence-Diagram" class="headerlink" title="Sequence Diagram"></a>Sequence Diagram</h2><p>위 절차 개요를 좀더 상세하게 시퀀스 다이어그램으로 표현해보면 다음과 같다.</p><p><img src="https://i.imgur.com/quqloI2.png" alt="Imgur"></p><p>(<a href="http://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art014" target="_blank" rel="noopener">http://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art014</a> 내용 참고하여 재구성)</p><p>초록색 화살표는 브라우저와 웹 서버의 통신을 나타내며, 파란색 화살표는 HTTP API 호출을 나타낸다.</p><p>이제 시퀀스 다이어그램을 토대로 실제 구현해보자.</p><h1 id="OAuth-1-0a-구현-Consumer"><a href="#OAuth-1-0a-구현-Consumer" class="headerlink" title="OAuth 1.0a 구현 - Consumer"></a>OAuth 1.0a 구현 - Consumer</h1><p>첫 번째 시나리오는 직접 구현한 Consumer를 통해 Service Provider인 트위터의 API를 사용해서 트위터에 글을 올리는 것이다. </p><h2 id="사전-조건-1"><a href="#사전-조건-1" class="headerlink" title="사전 조건"></a>사전 조건</h2><p>먼저 트위터에 내가 만들 Consumer 앱을 등록해야 한다. 참고로 OAuth 1.0a에서 Consumer라고 부르는 애플리케이션을 트위터에서는 트위터 앱(Twitter App)이라고 부른다.</p><p>Consumer 앱을 트위터에 등록하려면 먼저 트위터 개발자 계정이 있어야 한다. <a href="https://developer.twitter.com/en/docs/basics/developer-portal/overview" target="_blank" rel="noopener">트위터 개발자 포털</a>에서 개발자 계정을 신청할 수 있다.</p><p>개발자 계정 신청과 트위터 앱 등록 과정 설명은 아래의 화면 캡처로 대신한다.</p><h3 id="트위터-개발자-계정-신청"><a href="#트위터-개발자-계정-신청" class="headerlink" title="트위터 개발자 계정 신청"></a>트위터 개발자 계정 신청</h3><p><img src="https://i.imgur.com/OiGrOKX.png" alt="Imgur"></p><p><img src="https://i.imgur.com/Lp1vUPB.png" alt="Imgur"></p><p><img src="https://i.imgur.com/R1NUNqg.png" alt="Imgur"></p><p><img src="https://i.imgur.com/hV1K0xX.png" alt="Imgur"></p><p><img src="https://i.imgur.com/csco9Qs.png" alt="Imgur"></p><p><img src="https://i.imgur.com/J6ltjT6.png" alt="Imgur"></p><p><img src="https://i.imgur.com/ZgGGlFB.png" alt="Imgur"></p><p><img src="https://i.imgur.com/Ap50ZcF.png" alt="Imgur"></p><p><img src="https://i.imgur.com/AXkdALv.png" alt="Imgur"></p><p><img src="https://i.imgur.com/9QjOwMn.png" alt="Imgur"></p><p><img src="https://i.imgur.com/EJKOIXN.png" alt="Imgur"></p><h3 id="트위터-앱-등록"><a href="#트위터-앱-등록" class="headerlink" title="트위터 앱 등록"></a>트위터 앱 등록</h3><p><img src="https://i.imgur.com/3DWV3GB.png" alt="Imgur"></p><p><img src="https://i.imgur.com/85q36Jq.png" alt="Imgur"></p><p><img src="https://i.imgur.com/ikYSSYN.png" alt="Imgur"></p><p><img src="https://i.imgur.com/4OyDBKp.png" alt="Imgur"></p><p><img src="https://i.imgur.com/P8CcCqg.png" alt="Imgur"></p><p><img src="https://i.imgur.com/SYsQSMF.png" alt="Imgur"></p><h2 id="Consumer-앱-개발"><a href="#Consumer-앱-개발" class="headerlink" title="Consumer 앱 개발"></a>Consumer 앱 개발</h2><p>Consumer 앱은 OAuth 1.0a 흐름을 파악하는데 필요한 최소한의 기능만을 담아 간단하게 개발한다. 기능은 다음과 같다.</p><ul><li>글을 쓸 수 있는 폼 화면</li><li>권한 부여 요청 전송 (시퀀스 다이어그램 2번)</li><li>서명 생성 기능</li><li>접근 토큰 요청 전송 (시퀀스 다이어그램 14번)</li><li>트위터에 글 쓰기 (시퀀스 다이어그램 20번)</li></ul><p>편의상 스프링 부트로 개발하며, 프로젝트 생성 등의 자세한 과정은 생략한다.</p><p>OAuth 1.0a Spec인 <a href="https://tools.ietf.org/html/rfc5849" target="_blank" rel="noopener">RFC-5849</a>를 따라 Consumer가 갖춰야 할 기능을 구현해보자. 전체 소스 코드는 <a href="https://github.com/HomoEfficio/scratchpad-oauth10a-consumer" target="_blank" rel="noopener">여기</a>에 있다.</p><h3 id="프로젝트-생성"><a href="#프로젝트-생성" class="headerlink" title="프로젝트 생성"></a>프로젝트 생성</h3><p>스프링 이니셜라이저에서 다음과 같이 최소한의 starter만 선택해서 프로젝트를 생성한다.</p><p><img src="https://i.imgur.com/DcmkDvi.png" alt="Imgur"></p><h3 id="글-쓰는-폼-화면"><a href="#글-쓰는-폼-화면" class="headerlink" title="글 쓰는 폼 화면"></a>글 쓰는 폼 화면</h3><p>글 쓰는 폼 화면도 최대한 단순하게 구성했다.</p><p><img src="https://i.imgur.com/xEk7x8p.png" alt="Imgur"></p><p>User가 ‘트위터에 남기기’ 버튼을 클릭하면, Consumer 앱이 트위터에 Request Token 발급을 요청한다. 이 부분부터 자세히 살펴보자.</p><h2 id="Request-Token-발급-요청"><a href="#Request-Token-발급-요청" class="headerlink" title="Request Token 발급 요청"></a>Request Token 발급 요청</h2><p>Request Token 발급 요청 내용은 스펙의 <a href="https://tools.ietf.org/html/rfc5849#section-2.1" target="_blank" rel="noopener">2.1 Temporary Credentials</a>에 나와있다. Service Provider에게 전송해야할 정보는 다음과 같다고 예시에 나와 있지만,</p><ul><li><code>oauth_consumer_key</code>: Service Provider로부터 발급받은 Consumer key</li><li><code>oauth_signature_method</code>: 서명 방식. <code>HMAC-SHA1</code>, <code>RSA-SHA1</code>,<code>PLAINTEXT</code>의 3가지 방식이 있다.</li><li><code>oauth_callback</code>: Request Token 발급 후 Service Provider가 제공하는 권한 부여 화면에서 User가 Consumer에게 권한을 부여하면 리다이렉트 되는 Consumer의 callback API URI</li><li><code>oauth_signature</code>: 서명 값</li></ul><p>실제로는 <a href="https://tools.ietf.org/html/rfc5849#section-3.1" target="_blank" rel="noopener">3.1 Making Requests</a>에 나온 것처럼 다음과 같은 정보도 함께 전송해야 한다.</p><ul><li><code>oauth_token</code>: Request Token 발급 요청 시에는 <code>oauth_token</code>이 없으므로 생략 가능</li><li><code>oauth_timestamp</code>: 1970.01.01 00:00:00 기준 요청 당시의 초 값</li><li><code>oauth_nonce</code>: 임의의 문자열 값으로 replay attack을 막는데 사용되며, timestamp, consumer key/secret과 request/access token이 같은 요청에 대해서 nonce 값은 유일해야 한다.</li><li><code>oauth_version</code>: 선택 사항이며 <code>1.0</code>이어야 한다.</li></ul><p>이 규약은 Request Token 발급 요청 뿐아니라 Access Token 발급 요청 시에도 마찬가지로 적용된다.</p><p>대부분 이미 정해져 있거나 임의의 값 등으로 쉽게 구할 수 있지만, <code>oauth_signature</code>는 스펙에 정해진 규칙에 따라 계산 로직을 구현해줘야 한다.</p><p>이 글에서는 3가지 서명 방식 중 <code>HMAC-SHA1</code>만 다룬다. <code>PLAINTEXT</code>는 서명 방식으로 분류하고 있지만 실제로는 서명 방식이 아니며, <code>RSA-SHA1</code>는 shared-secret 대신 공개키/비밀키를 사용한다는 점만 <code>HMAC-SHA1</code>와 다르다.</p><h2 id="Token-Signature"><a href="#Token-Signature" class="headerlink" title="Token Signature"></a>Token Signature</h2><p>토큰 발급 요청을 위한 서명 생성 방법은 <a href="https://tools.ietf.org/html/rfc5849#section-3.4" target="_blank" rel="noopener">3.4 Signature</a>에 나와있다.</p><p>요약하면 다음과 같다.</p><ol><li><p>Signature Base String 생성</p></li><li><p>Signature Base String을 Base64로 인코딩 한 값을 Secret으로 서명</p></li></ol><h3 id="Signature-Base-String-생성"><a href="#Signature-Base-String-생성" class="headerlink" title="Signature Base String 생성"></a>Signature Base String 생성</h3><p>Signature Base String 생성 방식은 코드로 보는 것이 이해하기 쉬울 것 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateBaseString</span><span class="params">(AbstractOAuth10aRequestHeader header)</span> </span>&#123;</span><br><span class="line">    String httpMethod = header.getHttpMethod();</span><br><span class="line">    String baseUri = getBaseStringUri(header);</span><br><span class="line">    String requestParameters = getRequestParameters(header);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(httpMethod)</span><br><span class="line">            .append(<span class="string">'&amp;'</span>).append(getPercentEncoded(baseUri))</span><br><span class="line">            .append(<span class="string">'&amp;'</span>).append(getPercentEncoded(requestParameters));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>요약하면 Signature Base String은 HTTP 메서드, Base String URI(Token 발급 요청 URI), Token 발급 요청 파라미터를 <a href="https://tools.ietf.org/html/rfc5849#section-3.6" target="_blank" rel="noopener">Percent encoding</a> 한 후 &amp;를 구분자로 이어 붙여서 만든다.</p><p>여기서 주의할 것은 <strong>Java의 <code>URLEncoder.encode</code>는 OAuth 1.0a 스펙에서 말하는 Percent encoding과 차이가 있다는 점이다.</strong> Percent encoding 값이 잘못되면 서명값이 잘못 나오고, 잘못 나온 서명값은 서버 쪽에서 계산한 서명값과 일치하지 않으므로 요청이 계속 실패하게 된다. 서명값이 틀리면 요청에 사용된 여러 데이터중 어떤 데이터가 잘못 되어 서명값이 틀리는지 찾아내는 데 엄청난 고통이 뒤따른다.</p><p>검색해보면 아래와 같은 내용이 나오는데 이걸 사용하면 Request Token 발급과 Access Token 발급에는 성공하지만, 마지막으로 트위터에 특수 문자가 포함된 글을 남길 때 계속 실패한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUrlEncoded</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> URLEncoder.encode(value, StandardCharsets.UTF_8.name())</span><br><span class="line">                .replaceAll(<span class="string">"\\+"</span>, <span class="string">"%20"</span>)</span><br><span class="line">                .replaceAll(<span class="string">"%21"</span>, <span class="string">"!"</span>)</span><br><span class="line">                .replaceAll(<span class="string">"%27"</span>, <span class="string">"'"</span>)</span><br><span class="line">                .replaceAll(<span class="string">"%28"</span>, <span class="string">"("</span>)</span><br><span class="line">                .replaceAll(<span class="string">"%29"</span>, <span class="string">")"</span>)</span><br><span class="line">                .replaceAll(<span class="string">"%7E"</span>, <span class="string">"~"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>정말 며칠동안 계속 Trial-Error로 잘못된 부분을 찾느라 고생했는데, 결국 해결사는 스프링이었다. <strong>스프링의 <code>UriUtils</code> 클래스에서 제공하는 <code>UriUtils.encode()</code>와 <code>UriUtils.decode()</code>가 정확히 Percent Encoding을 구현</strong>하고 있어서 최종적으로 올바른 서명값을 계산해낼 수 있었다.</p><h3 id="Token-발급-요청-파라미터"><a href="#Token-발급-요청-파라미터" class="headerlink" title="Token 발급 요청 파라미터"></a>Token 발급 요청 파라미터</h3><p>Base String URI 구성을 마치면 Token 발급 요청 파라미터를 구성해야 한다.</p><p>Token 발급 요청 파라미터는 <a href="https://tools.ietf.org/html/rfc5849#section-3.4.1.3" target="_blank" rel="noopener">3.4.1.3.  Request Parameters</a>에 나와있다. 요약하면 다음과 같다.</p><ol><li>Token 발급 요청 URI에 있는 Query String을 이름/값으로 파싱하고 URL decoding 한다.</li><li>Authorization 헤더에 있는 헤더 정보를 이름/값으로 파싱하고 URL decoding 한다.</li><li>발급 요청이 single-part 이고 <code>Content-Type</code> 헤더 값이 <code>application/x-www-form-urlencoded</code>라면 HTTP 요청 body 값을 이름/값으로 파싱하고 URL decoding 한다.</li><li>위의 값들을 normalization 한다. normalization 방식은 다음과 같다.<ol><li>파라미터 이름과 값을 URL encoding 한다.</li><li>파라미터를 이름 기준 오름차순으로 정렬한다. 이름이 동일할 경우 값 기준 오름차순으로 정렬한다.</li><li>파라미터 이름과 값을 <code>=</code>로 이어 붙인다.</li><li>이어 붙인 파라미터를 <code>&amp;</code>로 이어 붙인다.</li></ol></li></ol><p>스펙에서는 고맙게도 이에 대한 테스트 케이스를 제공해주는데 아래와 같은 토큰 발급 요청이 있다면,</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /request?<span class="attribute">b5</span>=%3D%253D&amp;a3=a&amp;c%40=&amp;a2=r%20b HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Authorization: OAuth <span class="attribute">realm</span>=<span class="string">"Example"</span>,</span><br><span class="line">              <span class="attribute">oauth_consumer_key</span>=<span class="string">"9djdj82h48djs9d2"</span>,</span><br><span class="line">              <span class="attribute">oauth_token</span>=<span class="string">"kkk9d7dh3k39sjv7"</span>,</span><br><span class="line">              <span class="attribute">oauth_signature_method</span>=<span class="string">"HMAC-SHA1"</span>,</span><br><span class="line">              <span class="attribute">oauth_timestamp</span>=<span class="string">"137131201"</span>,</span><br><span class="line">              <span class="attribute">oauth_nonce</span>=<span class="string">"7d8f3e4a"</span>,</span><br><span class="line">              <span class="attribute">oauth_signature</span>=<span class="string">"djosJKDKJSD8743243%2Fjdk33klY%3D"</span></span><br><span class="line"></span><br><span class="line">c2&amp;<span class="attribute">a3</span>=2+q</span><br></pre></td></tr></table></figure><p>토큰 발급 요청 파라미터는 다음의 결과값을 갖게 된다.<br>(가독성을 위해 줄바꿈을 적용했으나 그런다고 가독성이 좋아지지는..)</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a2=r%<span class="number">20</span>b<span class="variable">&amp;a3</span>=<span class="number">2</span>%<span class="number">20</span>q<span class="variable">&amp;a3</span>=a<span class="variable">&amp;b5</span>=%<span class="number">3</span>D%<span class="number">253</span>D<span class="variable">&amp;c</span>%<span class="number">40</span>=<span class="variable">&amp;c2</span>=<span class="variable">&amp;oauth_consumer_key</span>=<span class="number">9</span>dj</span><br><span class="line">dj82h48djs9d2<span class="variable">&amp;oauth_nonce</span>=<span class="number">7</span>d8f3e4a<span class="variable">&amp;oauth_signature_method</span>=HMAC-SHA1</span><br><span class="line"><span class="variable">&amp;oauth_timestamp</span>=<span class="number">137131201</span><span class="variable">&amp;oauth_token</span>=kkk9d7dh3k39sjv7</span><br></pre></td></tr></table></figure><p>토큰 발급 요청 파라미터를 구하는 로직을 스펙을 읽고 정확하게 파악하는 것이 어렵지만, 일단 파악하면 구현 자체는 어렵지 않다. 필요하다면 <a href="https://github.com/HomoEfficio/scratchpad-oauth10a-consumer/blob/master/src/main/java/io/homo/efficio/scratchpad/oauth10a/consumer/util/OAuth10aSignatureSupport.java" target="_blank" rel="noopener">이걸</a> 참고하면 된다.</p><h3 id="서명-생성"><a href="#서명-생성" class="headerlink" title="서명 생성"></a>서명 생성</h3><p>서명 생성은 <a href="https://tools.ietf.org/html/rfc5849#section-3.4.2" target="_blank" rel="noopener">3.4.2.  HMAC-SHA1</a>에 나와있다. 서명에는 키와 데이터가 필요한데 <code>HMAC-SHA1</code> 방식의 키는 Consumer Secret과 Token Secret을 <code>&amp;</code>로 이어 붙인 값이다.</p><p>Request Token 발급 요청할 때는 Token Secret이 없는 상태이므로 그냥 <code>ConsumerSecret값&amp;</code>이 키가 된다.</p><p>서명에 사용될 데이터는 위에서 구한 토큰 발급 요청 파라미터다.</p><p>서명 값은 <code>javax.crypto.Mac</code> 클래스를 이용해서 계산할 수 있으며, 검색해보면 찾을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillSignature</span><span class="params">(AbstractOAuth10aRequestHeader header)</span> </span>&#123;</span><br><span class="line">    String key = header.getKey();</span><br><span class="line">    String baseString = generateBaseString(header);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> SecretKeySpec signingKey = <span class="keyword">new</span> SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), OAuth10aConstants.HMAC_SHA1_ALGORITHM_NAME);</span><br><span class="line">        <span class="keyword">final</span> Mac mac = Mac.getInstance(OAuth10aConstants.HMAC_SHA1_ALGORITHM_NAME);</span><br><span class="line">        mac.init(signingKey);</span><br><span class="line">        <span class="keyword">final</span> String signature = Base64.getEncoder().encodeToString(mac.doFinal(baseString.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        header.setOauthSignature(signature);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidKeyException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="괴로운-부분"><a href="#괴로운-부분" class="headerlink" title="괴로운 부분"></a>괴로운 부분</h3><p>결론만 보면 쉬운 것 같지만 <strong>직접 구현한 로직으로 만든 서명이 실제로 맞는지 검증을 하는 쉬운 방법이 없다는 게 OAuth 1.0a Consumer를 구현하는 과정 중에 가장 괴로운 부분이다.</strong> </p><p>서명이 맞는지 확인 하는 유일한 방법은 Service Provider인 트위터에 서명을 전송하고 트위터의 응답을 받아보는 것 밖에 없다. 그런데 서명이 맞지 않을 때는 다음과 같이 401 Authorization Required 만 확인할 수 있을 뿐이고,</p><blockquote><p>org.springframework.web.client.HttpClientErrorException: 401 Authorization Required</p></blockquote><p>디버거를 활용해서 확인해보면 아래와 같이 트위터가 알려주는 정보를 확인할 수는 있는데, 빈 문자열이 반환된다.</p><p><img src="https://i.imgur.com/awb2ePA.png" alt="Imgur"></p><p>빈 문자열이 반환되니 <a href="https://developer.twitter.com/en/docs/basics/response-codes.html" target="_blank" rel="noopener">트위터 응답 코드 문서</a>도 도움이 되지 않는다. 실로 막막하고 괴롭다.</p><p>서버의 서명 검증이라는 것이 결국 HTTP 헤더로 전달받은 정보를 이용해서 계산되므로, 어느 부분이 틀렸는지 더 구체적인 정보를 알려줄 수 있을텐데 보안 때문인지 트위터는 오류 세부 내용을 알려주지 않는다.</p><p>오랜 고생 끝에 결국 성공하고 나서 정리한 최선의 방법론은 다음과 같다.</p><ol><li>Percent Encoding은 스프링에서 제공하는 <code>UriUtils</code> 클래스를 활용해서 처리한다.</li><li>스펙에 나온 Base String URI 테스트 케이스를 통과하도록 Base String URI를 구성하는 로직을 정확하게 구현한다.</li><li>Request Token 발급과 Access Token 발급까지는 Service Provider 별로 다를 게 없고 스펙대로만 구현하면 되므로, 의도대로 동작하지 않으면 스펙을 보고 구현 내용을 점검한다.</li><li>Protected Resources에 대한 접근 요청 규격은 Service Provider 별로 다르므로 Access Token 발급까지는 성공했는데 자원 접근 요청에서 실패한다면 Service Provider의 문서를 꼼꼼히 살펴서 요청 규격을 맞춰준다.</li><li>400 Bad Request 에러가 발생하면 헤더 구성 내용 중 이름 오류나 누락된 항목이 있는지 다시 한 번 살펴보고, 401 Authorization Required 에러가 발생하면 서명값 계산 로직을 다시 살펴본다.</li></ol><p>여기까지 Request Token 발급 요청과 Access Token 발급 요청을 위한 서명 생성까지 다뤘다. 실제 화면으로 작업 흐름을 되짚어 보고 Access Token 발급까지 확인해보자.</p><h3 id="User의-권한-부여-신청"><a href="#User의-권한-부여-신청" class="headerlink" title="User의 권한 부여 신청"></a>User의 권한 부여 신청</h3><p><img src="https://i.imgur.com/ROuYV2h.png" alt="Imgur"></p><h3 id="Consumer가-서명-생성-후-Service-Provider에-전송해서-Request-Token을-발급-받고-Service-Provider가-제공하는-User의-권한-부여-화면으로-리다이렉트"><a href="#Consumer가-서명-생성-후-Service-Provider에-전송해서-Request-Token을-발급-받고-Service-Provider가-제공하는-User의-권한-부여-화면으로-리다이렉트" class="headerlink" title="Consumer가 서명 생성 후 Service Provider에 전송해서 Request Token을 발급 받고, Service Provider가 제공하는 User의 권한 부여 화면으로 리다이렉트"></a>Consumer가 서명 생성 후 Service Provider에 전송해서 Request Token을 발급 받고, Service Provider가 제공하는 User의 권한 부여 화면으로 리다이렉트</h3><p><img src="https://i.imgur.com/KVmocfW.png" alt="Imgur"></p><h3 id="User가-앱-인증을-클릭하면-Consumer의-callback-API로-리다이렉트"><a href="#User가-앱-인증을-클릭하면-Consumer의-callback-API로-리다이렉트" class="headerlink" title="User가 앱 인증을 클릭하면 Consumer의 callback API로 리다이렉트"></a>User가 앱 인증을 클릭하면 Consumer의 callback API로 리다이렉트</h3><p><img src="https://i.imgur.com/BpTOODs.png" alt="Imgur"></p><h3 id="callback-API에서-서명-생성-후-Service-Provider에-전송해서-Access-Token-발급"><a href="#callback-API에서-서명-생성-후-Service-Provider에-전송해서-Access-Token-발급" class="headerlink" title="callback API에서 서명 생성 후 Service Provider에 전송해서 Access Token 발급"></a>callback API에서 서명 생성 후 Service Provider에 전송해서 Access Token 발급</h3><p><img src="https://i.imgur.com/4eia8Qv.png" alt="Imgur"></p><h2 id="보호된-자원에-접근"><a href="#보호된-자원에-접근" class="headerlink" title="보호된 자원에 접근"></a>보호된 자원에 접근</h2><p>Access Token 까지 발급 받았으니 이제 Access Token을 사용해서 보호된 자원(Protected Resources)에 사용자를 대신해서 접근하는 과정만 남았다.</p><p>앞에서도 언급했지만 일단 여기까지 왔으면 서명 생성 로직은 제대로 구현되었다고 볼 수 있다. 보호된 자원에 접근하는 과정과 앞선 Request Token, Access Token 발급 과정 사이의 가장 큰 차이점 두 가지는 다음과 같다.</p><ol><li>보호된 자원에 접근할 때는 드디어 사용자의 데이터(예를 들면 트위터에 남기고자 하는 글)가 처음으로 요청에 포함된다.</li><li>보호된 자원 접근 요청 규격은 Service Provider의 규격을 참고해야 한다.</li></ol><p>차례대로 알아보자.</p><h3 id="자원-접근-요청-발송은-어디에서-해야되나"><a href="#자원-접근-요청-발송은-어디에서-해야되나" class="headerlink" title="자원 접근 요청 발송은 어디에서 해야되나?"></a>자원 접근 요청 발송은 어디에서 해야되나?</h3><p>최초의 글 남기기 요청에서 권한 부여 확인 후 끊김 없이 연속적으로 글 남기가 까지 완료하려면, 일단 <strong>접근 요청을 날리는 위치는 Access Token 발급 요청을 전송하고, Access Token을 반환받는 callback URL API여야 한다.</strong></p><p>Access Token을 받은 후, <code>Session</code>에서 사용자 데이터를 읽어와서 Access Token 정보와 함께 자원 접근 요청을 날리면 된다.</p><h3 id="사용자-데이터-처리"><a href="#사용자-데이터-처리" class="headerlink" title="사용자 데이터 처리"></a>사용자 데이터 처리</h3><p>앞의 작업 흐름 화면에 보면 사용자 데이터는 가장 앞 단계에서 입력된다. 따라서 이 데이터를 Request Token, Access Token 발급 과정을 거쳐서 자원 접근 요청을 보낼때까지 유지시켜줘야 결과적으로 사용자 데이터를 보호된 자원 접근에 사용할 수 있다. 가장 간단한 방법은 <code>Session</code>에 담아두는 것이다.</p><p>시퀀스 다이어그램 6번 과정에서 사용자 데이터(트위터에 남길 글)를 <code>Session</code>에 담아두면 여러 번의 리다이렉트를 거치면서 최종 요청 단계인 20번 과정까지 <code>Session</code>에 사용자 데이터가 유지 된다.</p><p><img src="https://i.imgur.com/quqloI2.png" alt="Imgur"></p><h3 id="자원-접근-요청-규격"><a href="#자원-접근-요청-규격" class="headerlink" title="자원 접근 요청 규격"></a>자원 접근 요청 규격</h3><p>자원 접근 요청 규격은 Service Provider가 정한 규격에 따라야 한다. 트위터에 글을 남기는 요청 규격은 <a href="https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/post-statuses-update" target="_blank" rel="noopener">여기</a>에 다음과 같이 예제가 나와 있다.</p><blockquote><p>$ curl –request POST<br>–url ‘<a href="https://api.twitter.com/1.1/statuses/update.json" target="_blank" rel="noopener">https://api.twitter.com/1.1/statuses/update.json</a>?<br>status=Test%20tweet%20using%20the%20POST%20statuses%2Fupdate%20endpoint’<br>–header ‘authorization: OAuth oauth_consumer_key=”YOUR_CONSUMER_KEY”,<br>oauth_nonce=”AUTO_GENERATED_NONCE”, oauth_signature=”AUTO_GENERATED_SIGNATURE”,<br>oauth_signature_method=”HMAC-SHA1”, oauth_timestamp=”AUTO_GENERATED_TIMESTAMP”,<br>oauth_token=”USERS_ACCESS_TOKEN”, oauth_version=”1.0”‘<br>–header ‘content-type: application/json’</p></blockquote><p>POST 방식이지만 사용자 데이터를 request body가 아니라 Query String으로 붙여서 보내고 있다. 따라서 글 남기기 요청 시에도 POST 방식을 쓰되 남길 글을 request body가 아니라 Query String에 붙여서 보내야 하고, 서명 생성 시에도 요청 URL에 Query String이 포함되어야 한다.</p><h3 id="자원-접근-요청-구현-내용"><a href="#자원-접근-요청-구현-내용" class="headerlink" title="자원 접근 요청 구현 내용"></a>자원 접근 요청 구현 내용</h3><p>앞에서 다룬 3가지 주요 내용을 구현한 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/callback"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestTokenCredentials</span><span class="params">(HttpServletRequest request, VerifierResponse verifierResponse)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Access Token 발급 요청 전송</span></span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    <span class="keyword">final</span> String requestTokenSecret = (String) session.getAttribute(<span class="string">"RTS"</span>);</span><br><span class="line">    <span class="keyword">final</span> AbstractOAuth10aRequestHeader tcHeader =</span><br><span class="line">            <span class="keyword">new</span> OAuth10aTokenCredentialsRequestHeader(</span><br><span class="line">                    <span class="keyword">this</span>.tokenCredentialsUrl,</span><br><span class="line">                    <span class="keyword">this</span>.consumerKey,</span><br><span class="line">                    <span class="keyword">this</span>.consumerSecret,</span><br><span class="line">                    verifierResponse.getOauth_token(),</span><br><span class="line">                    requestTokenSecret,</span><br><span class="line">                    verifierResponse.getOauth_verifier());</span><br><span class="line">    <span class="keyword">final</span> ResponseEntity&lt;TokenCredentials&gt; responseEntity =</span><br><span class="line">            <span class="keyword">this</span>.twitterService.getCredentials(tcHeader, TokenCredentials.class);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"access_token: &#123;&#125;"</span>, Objects.requireNonNull(responseEntity.getBody()).toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 자원 접근 요청 전송</span></span><br><span class="line">    <span class="keyword">final</span> NextAction nextAction = (NextAction) session.getAttribute(OAuth10aConstants.NEXT_ACTION);</span><br><span class="line">    log.info(<span class="string">"nextAction: &#123;&#125;"</span>, nextAction);    </span><br><span class="line">    <span class="keyword">final</span> OAuth10aProtectedResourcesRequestHeader resourcesRequestHeader =</span><br><span class="line">            <span class="keyword">new</span> OAuth10aProtectedResourcesRequestHeader(</span><br><span class="line">                    nextAction,</span><br><span class="line">                    <span class="keyword">this</span>.consumerKey,</span><br><span class="line">                    <span class="keyword">this</span>.consumerSecret,</span><br><span class="line">                    responseEntity.getBody().getOauth_token(),</span><br><span class="line">                    responseEntity.getBody().getOauth_token_secret());</span><br><span class="line">    log.info(<span class="string">"OAuth10aProtectedResourcesRequestHeader: &#123;&#125;"</span>, resourcesRequestHeader);</span><br><span class="line">    <span class="keyword">final</span> ResponseEntity&lt;Object&gt; actionResponseEntity =</span><br><span class="line">            <span class="keyword">this</span>.twitterService.doNextAction(resourcesRequestHeader, nextAction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 접근 요청 후처리</span></span><br><span class="line">    <span class="keyword">if</span> (actionResponseEntity.getStatusCode().equals(HttpStatus.OK)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Mention is written!!!"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> actionResponseEntity.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="실제-글이-트위터에-남겨지는-진행-과정"><a href="#실제-글이-트위터에-남겨지는-진행-과정" class="headerlink" title="실제 글이 트위터에 남겨지는 진행 과정"></a>실제 글이 트위터에 남겨지는 진행 과정</h2><p>전체 과정은 다음과 같이 진행된다.</p><h3 id="글-쓰고-트위터에-남기기-클릭"><a href="#글-쓰고-트위터에-남기기-클릭" class="headerlink" title="글 쓰고 트위터에 남기기 클릭"></a>글 쓰고 트위터에 남기기 클릭</h3><p><img src="https://i.imgur.com/AdU3bB6.png" alt="Imgur"></p><h3 id="Consumer가-서명-생성-후-Service-Provider에-전송해서-Request-Token을-발급-받고-Service-Provider가-제공하는-User의-권한-부여-화면으로-리다이렉트-1"><a href="#Consumer가-서명-생성-후-Service-Provider에-전송해서-Request-Token을-발급-받고-Service-Provider가-제공하는-User의-권한-부여-화면으로-리다이렉트-1" class="headerlink" title="Consumer가 서명 생성 후 Service Provider에 전송해서 Request Token을 발급 받고, Service Provider가 제공하는 User의 권한 부여 화면으로 리다이렉트"></a>Consumer가 서명 생성 후 Service Provider에 전송해서 Request Token을 발급 받고, Service Provider가 제공하는 User의 권한 부여 화면으로 리다이렉트</h3><p><img src="https://i.imgur.com/A2rXtbb.png" alt="Imgur"></p><h3 id="User가-앱-인증을-클릭하면-Consumer의-Callback-API로-리다이렉트"><a href="#User가-앱-인증을-클릭하면-Consumer의-Callback-API로-리다이렉트" class="headerlink" title="User가 앱 인증을 클릭하면 Consumer의 Callback API로 리다이렉트"></a>User가 앱 인증을 클릭하면 Consumer의 Callback API로 리다이렉트</h3><p><img src="https://i.imgur.com/ZsnjElz.png" alt="Imgur"></p><p>Callback API로 리다이렉트 되면 내부적으로 다음 2가지 과정이 진행된다.</p><ol><li>callback API에서 서명 생성 후 Service Provider에 전송해서 Access Token 발급 요청 전송</li><li>Access Token을 발급 받은 후 Service Provider의 자원에 접근 요청 전송(글쓰기 요청 전송)</li></ol><h3 id="접근-요청이-성공하면-화면에-성공-메시지-표시됨"><a href="#접근-요청이-성공하면-화면에-성공-메시지-표시됨" class="headerlink" title="접근 요청이 성공하면 화면에 성공 메시지 표시됨"></a>접근 요청이 성공하면 화면에 성공 메시지 표시됨</h3><p><img src="https://i.imgur.com/7wCyEr2.png" alt="Imgur"></p><h3 id="트위터에-접속하면-글이-써진-것을-확인할-수-있음"><a href="#트위터에-접속하면-글이-써진-것을-확인할-수-있음" class="headerlink" title="트위터에 접속하면 글이 써진 것을 확인할 수 있음"></a>트위터에 접속하면 글이 써진 것을 확인할 수 있음</h3><p><img src="https://i.imgur.com/Ks3ZjrK.png" alt="Imgur"></p><h1 id="매우-귀중한-보너스"><a href="#매우-귀중한-보너스" class="headerlink" title="매우 귀중한 보너스!!"></a>매우 귀중한 보너스!!</h1><p>고생은 나 하나로 족하다. Request Token 발급 요청, Access Token 발급 요청, 자원 접근 요청에 사용되는 서명값 계산 로직을 검증할 수 있는 테스트 케이스를 선사한다.</p><p>중간에 사용되는 <code>*Header</code>나 <code>OAuth10aSignatureSupport</code> 클래스는 구현 방식에 따라 달라질 수 있으니 신경쓰지 말고 아래 나오는 URL, ConsumerKey, ConsumerSecret, RequestTokenKey, RequestTokenSecret, AccessToken, AccessTokenSecret, Nonce, TimeStamp와 Signature 값으로 각자의 구현 로직을 테스트할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OAuth10aSignatureSupportTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OAuth10aSignatureSupport oa10aSigSupport = <span class="keyword">new</span> OAuth10aSignatureSupport();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestToken__sigTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        OAuth10aTemporaryCredentialRequestHeader header = <span class="keyword">new</span> OAuth10aTemporaryCredentialRequestHeader(</span><br><span class="line">                <span class="string">"https://api.twitter.com/oauth/request_token"</span>,</span><br><span class="line">                <span class="string">"YourAppConsumerKey"</span>,</span><br><span class="line">                <span class="string">"YourAppConsumerSecret"</span>,</span><br><span class="line">                <span class="string">"YourAppCallbackURL"</span></span><br><span class="line">        );</span><br><span class="line">        header.setOauthNonce(<span class="string">"NDg0ZDNjOTktYTJlMC00YmI5LThhMDktZDBkZGQ0MDA0ZTIw"</span>);</span><br><span class="line">        header.setOauthTimestamp(<span class="string">"1535288634"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        oa10aSigSupport.fillSignature(header);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertThat(header.getOauthSignature()).isEqualTo(<span class="string">"DNpRbry9XwYfEf+KXz4tV5Ufbpk="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accessToken__sigTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        OAuth10aTokenCredentialsRequestHeader header = <span class="keyword">new</span> OAuth10aTokenCredentialsRequestHeader(</span><br><span class="line">                <span class="string">"https://api.twitter.com/oauth/access_token"</span>,</span><br><span class="line">                <span class="string">"YourAppConsumerKey"</span>,</span><br><span class="line">                <span class="string">"YourAppConsumerSecret"</span>,</span><br><span class="line">                <span class="string">"YourRequestToken"</span>,</span><br><span class="line">                <span class="string">"YourRequestTokenSecret"</span>,</span><br><span class="line">                <span class="string">"YourOAuthVerifier"</span></span><br><span class="line">        );</span><br><span class="line">        header.setOauthNonce(<span class="string">"ZmRmNDQ5Y2YtN2IwNC00YzFkLTgxODItN2YwZmEzYjRhZTJj"</span>);</span><br><span class="line">        header.setOauthTimestamp(<span class="string">"1535289096"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        oa10aSigSupport.fillSignature(header);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertThat(header.getOauthSignature()).isEqualTo(<span class="string">"64lbyOhFJRcmudwWSwrmL1cQhEQ="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">protectedResources__sigTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        NextAction nextAction = <span class="keyword">new</span> NextAction(</span><br><span class="line">                HttpMethod.POST,</span><br><span class="line">                <span class="string">"https://api.twitter.com/1.1/statuses/update.json?status=OAuth10a%20Test"</span>,</span><br><span class="line">                <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        OAuth10aProtectedResourcesRequestHeader header =</span><br><span class="line">                <span class="keyword">new</span> OAuth10aProtectedResourcesRequestHeader(</span><br><span class="line">                        nextAction,</span><br><span class="line">                        <span class="string">"YourAppConsumerKey"</span>,</span><br><span class="line">                        <span class="string">"YourAppConsumerSecret"</span>,</span><br><span class="line">                        <span class="string">"YourAccessToken"</span>,</span><br><span class="line">                        <span class="string">"YourAccessTokenSecret"</span></span><br><span class="line">                );</span><br><span class="line">        header.setOauthTimestamp(<span class="string">"1535272771"</span>);</span><br><span class="line">        header.setOauthNonce(<span class="string">"Y2I0Yjk4ZDItZjg2OS00Y2VjLThkMjgtY2RmMWY0YzZiOTlj"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        oa10aSigSupport.fillSignature(header);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertThat(header.getOauthSignature()).isEqualTo(<span class="string">"de5B57uqqbMG/Z/6vm5i5kJaxxA="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;스펙따라-만들어보는-OAuth-1-0a-Client&quot;&gt;&lt;a href=&quot;#스펙따라-만들어보는-OAuth-1-0a-Client&quot; class=&quot;headerlink&quot; title=&quot;스펙따라 만들어보는 OAuth 1.0a Client&quot;&gt;&lt;/a&gt;스펙
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="OAuth" scheme="http://homoefficio.github.io/tags/OAuth/"/>
    
      <category term="OAuth 1.0a" scheme="http://homoefficio.github.io/tags/OAuth-1-0a/"/>
    
      <category term="Consumer" scheme="http://homoefficio.github.io/tags/Consumer/"/>
    
      <category term="Twitter" scheme="http://homoefficio.github.io/tags/Twitter/"/>
    
      <category term="Request Token" scheme="http://homoefficio.github.io/tags/Request-Token/"/>
    
      <category term="Temporary Credentials" scheme="http://homoefficio.github.io/tags/Temporary-Credentials/"/>
    
      <category term="OAuth verifier" scheme="http://homoefficio.github.io/tags/OAuth-verifier/"/>
    
      <category term="OAuth Callback" scheme="http://homoefficio.github.io/tags/OAuth-Callback/"/>
    
      <category term="Access Token" scheme="http://homoefficio.github.io/tags/Access-Token/"/>
    
      <category term="Token Credentials" scheme="http://homoefficio.github.io/tags/Token-Credentials/"/>
    
      <category term="Percent Encoding" scheme="http://homoefficio.github.io/tags/Percent-Encoding/"/>
    
      <category term="Signature" scheme="http://homoefficio.github.io/tags/Signature/"/>
    
      <category term="HMAC-SHA1" scheme="http://homoefficio.github.io/tags/HMAC-SHA1/"/>
    
      <category term="Spring Boot" scheme="http://homoefficio.github.io/tags/Spring-Boot/"/>
    
      <category term="트위터" scheme="http://homoefficio.github.io/tags/%ED%8A%B8%EC%9C%84%ED%84%B0/"/>
    
      <category term="요청 토큰" scheme="http://homoefficio.github.io/tags/%EC%9A%94%EC%B2%AD-%ED%86%A0%ED%81%B0/"/>
    
      <category term="접근 토큰" scheme="http://homoefficio.github.io/tags/%EC%A0%91%EA%B7%BC-%ED%86%A0%ED%81%B0/"/>
    
      <category term="스프링 부트" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java Quartz Scheduler - Job Chaining 구현</title>
    <link href="http://homoefficio.github.io/2018/08/12/Java-Quartz-Scheduler-Job-Chaining-%EA%B5%AC%ED%98%84/"/>
    <id>http://homoefficio.github.io/2018/08/12/Java-Quartz-Scheduler-Job-Chaining-구현/</id>
    <published>2018-08-12T00:07:12.000Z</published>
    <updated>2018-10-13T15:49:56.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Quartz-Scheduler-Job-Chaining-구현"><a href="#Java-Quartz-Scheduler-Job-Chaining-구현" class="headerlink" title="Java Quartz Scheduler - Job Chaining 구현"></a>Java Quartz Scheduler - Job Chaining 구현</h1><p>Java로 Job Scheduling을 쉽게(참 조심스러운 단어.. ㅋㅋ) 할 수 있게 해주는 <a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">쿼츠(Quartz) 스케줄러</a>가 있다.</p><p>이 사이트에 나와있는 문서들은 여태 본 기술 사이트 문서 중에 가장 맘에 드는 스타일로 구성되어 있다. 길지 않은 설명, 간략하면서도 필요한 정보를 모두 담고 있는 다양한 기본 예제와 실무형 Cookbook까지 정말 마음에 쏙 든다. 게다가 스프링부트 스타터로도 제공되므로 더욱 편리하게 프로젝트에서 사용할 수 있다.</p><p>그런데 옥의 티랄까.. 독립적인 Job은 훌륭한 문서와 쉬운 Fluent API 덕에 간단하게 구현할 수 있는데, 연속적인 Job 실행은 간단하게 구현할 수 있는 방법이 없는 것 같다. 그래서 검색을 해보니 결국에는 Job 실행에 사용되는 Context 객체 안에 다음에 실행할 Job을 넣어주고 스케줄링하는 방식으로 연속적인 Job 실행을 구현할 수 있다. </p><p>그래서 간단하면서도 용도에 맞게 조금만 확장하면 아주 쓸만한 구현 예제를 만들어 봤다. 전체 코드는 <a href="https://github.com/HomoEfficio/quartz-scratchpad" target="_blank" rel="noopener">https://github.com/HomoEfficio/quartz-scratchpad</a> 에 있다.</p><h2 id="Quartz-기초-개념"><a href="#Quartz-기초-개념" class="headerlink" title="Quartz 기초 개념"></a>Quartz 기초 개념</h2><p>쿼츠에 대한 감을 잡는 데는 단 한 줄이면 충분하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduler.scheduleJob(jobDetail, trigger);</span><br></pre></td></tr></table></figure><ul><li><code>jobDetail</code>에는 Job의 실제 구현 내용과 Job 실행에 필요한 제반 상세 정보가 담겨 있다.</li><li><code>trigger</code>에는 Job을 언제, 어떤 주기로, 언제부터 언제까지 실행할지에 대한 정보가 담겨 있다.</li><li>scheduler는 <code>jobDetail</code>과 <code>trigger</code>에 담긴 정보를 이용해서 실제 Job의 실행 스케줄링을 담당한다.</li></ul><h2 id="Quartz-기초-예제"><a href="#Quartz-기초-예제" class="headerlink" title="Quartz 기초 예제"></a>Quartz 기초 예제</h2><p>쿼츠 스케줄링을 통해 로그를 찍는 간단한 예제를 살펴보자.</p><h3 id="HelloJob"><a href="#HelloJob" class="headerlink" title="HelloJob"></a>HelloJob</h3><p>단순히 로그를 찍는 Job</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.homo.efficio.scratchpad.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> homo.efficio@gmail.com</span></span><br><span class="line"><span class="comment"> * created on 2018-08-12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"### Hello Job is being executed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QuartzTest"><a href="#QuartzTest" class="headerlink" title="QuartzTest"></a>QuartzTest</h3><p>HelloJob을 스케줄링하고 실행하는 테스트. 물론 <code>public static void main()</code>으로 해도 무방하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.homo.efficio.scratchpad.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDetail;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Trigger;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.JobBuilder.newJob;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.TriggerBuilder.newTrigger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> homo.efficio@gmail.com</span></span><br><span class="line"><span class="comment"> * created on 2018-08-12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloJob</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Job 구현 내용이 담긴 HelloJob으로 JobDetail 생성</span></span><br><span class="line">        JobDetail jobDetail = newJob(HelloJob.class)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 실행 시점을 결정하는 Trigger 생성</span></span><br><span class="line">        Trigger trigger = newTrigger()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 스케줄러 실행 및 JobDetail과 Trigger 정보로 스케줄링</span></span><br><span class="line">        Scheduler defaultScheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">        defaultScheduler.start();</span><br><span class="line">        defaultScheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">        Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>);  <span class="comment">// Job이 실행될 수 있는 시간 여유를 준다</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 스케줄러 종료</span></span><br><span class="line">        defaultScheduler.shutdown(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="테스트-결과"><a href="#테스트-결과" class="headerlink" title="테스트 결과"></a>테스트 결과</h3><p>다음과 같이 HelloJob에 구현된 로그 출력이 성공적으로 수행된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">00:53:15.137 [DefaultQuartzScheduler_Worker-1] INFO io.homo.efficio.scratchpad.quartz.HelloJob - ### Hello Job is being executed!</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Job-Chaining-기본-틀-구현"><a href="#Job-Chaining-기본-틀-구현" class="headerlink" title="Job Chaining 기본 틀 구현"></a>Job Chaining 기본 틀 구현</h2><p>이제 위의 간단한 HelloJob을 넘어서 Job을 연속적으로 실행할 수 있는 Job Chaining을 구현해보자.</p><p>연속 실행 기능을 가질 추상 클래스인 <code>BaseJob</code>을 만들고, 실제 구현 내용을 담은 HelloJob은 <code>BaseJob</code>을 상속하게 만든다.</p><h3 id="BaseJob"><a href="#BaseJob" class="headerlink" title="BaseJob"></a>BaseJob</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.homo.efficio.scratchpad.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> homo.efficio@gmail.com</span></span><br><span class="line"><span class="comment"> * created on 2018-08-12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        doExecute(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doExecute</span><span class="params">(JobExecutionContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HelloJob-1"><a href="#HelloJob-1" class="headerlink" title="HelloJob"></a>HelloJob</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.homo.efficio.scratchpad.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> homo.efficio@gmail.com</span></span><br><span class="line"><span class="comment"> * created on 2018-08-12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJob</span> <span class="keyword">extends</span> <span class="title">BaseJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doExecute</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"### Hello Job is being executed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="테스트-재실행"><a href="#테스트-재실행" class="headerlink" title="테스트 재실행"></a>테스트 재실행</h3><p>테스트 코드는 바꿀 필요 없다. 실행해보면 전과 마찬가지로 로그가 성공적으로 출력된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">01:22:41.393 [DefaultQuartzScheduler_Worker-1] INFO io.homo.efficio.scratchpad.quartz.HelloJob - ### Hello Job is being executed!</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="템플릿-메서드-패턴-적용"><a href="#템플릿-메서드-패턴-적용" class="headerlink" title="템플릿 메서드 패턴 적용"></a>템플릿 메서드 패턴 적용</h3><p><code>BaseJob</code>에 템플릿 메서드 패턴을 적용해서 Job 실행 <code>전처리</code>, <code>Job 실행</code>, <code>후처리</code>, <code>다음 Job Scheduling</code>이라는 파이프라인을 구성한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.homo.efficio.scratchpad.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> homo.efficio@gmail.com</span></span><br><span class="line"><span class="comment"> * created on 2018-08-12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        beforeExecute(context);</span><br><span class="line">        doExecute(context);</span><br><span class="line">        afterExecute(context);</span><br><span class="line">        scheduleNextJob(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"%%% Before executing job"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doExecute</span><span class="params">(JobExecutionContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"%%% After executing job"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleNextJob</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"$$$ Schedule Next Job"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="테스트-재실행-1"><a href="#테스트-재실행-1" class="headerlink" title="테스트 재실행"></a>테스트 재실행</h3><p>테스트를 재실행해보면 다음과 같이 <code>전처리</code>, <code>Job 실행</code>, <code>후처리</code>, <code>다음 Job 스케줄링</code>이 실행됨을 알 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">01</span>:<span class="number">41</span>:<span class="number">16.254</span> [DefaultQuartzScheduler_Worker-<span class="number">1</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - %%% Before executing job</span><br><span class="line">01:41:16.254 [DefaultQuartzScheduler_Worker-1] INFO io.homo.efficio.scratchpad.quartz.HelloJob - ### Hello Job is being executed!</span><br><span class="line"><span class="number">01</span>:<span class="number">41</span>:<span class="number">16.254</span> [DefaultQuartzScheduler_Worker-<span class="number">1</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - %%% After executing job</span><br><span class="line"><span class="number">01</span>:<span class="number">41</span>:<span class="number">16.254</span> [DefaultQuartzScheduler_Worker-<span class="number">1</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - $$$ Schedule Next Job</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Job-Chaining-실제-구현"><a href="#Job-Chaining-실제-구현" class="headerlink" title="Job Chaining 실제 구현"></a>Job Chaining 실제 구현</h2><p>여기에서는 쿼츠에 대한 부연 설명이 조금 필요하다.</p><p><code>execute()</code> 메서드에 넘겨지는 <code>JobExecutionContext</code>에는 Job 실행에 필요한 다양한 정보를 담을 수 있다. 그 중에서도 <code>JobDataMap</code>을 이용하면 자유롭게 Key-Value 데이터를 담을 수 있다. 다음과 같이 테스트 코드를 바꿔서 정보를 담아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloJob</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JobDataMap을 이용해서 원하는 정보 담기</span></span><br><span class="line">    JobDataMap jobDataMap = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">    jobDataMap.put(<span class="string">"JobName"</span>, <span class="string">"Job Chain 1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Job 구현 내용이 담긴 HelloJob으로 JobDetail 생성</span></span><br><span class="line">    JobDetail jobDetail = newJob(HelloJob.class)</span><br><span class="line">            .usingJobData(jobDataMap)  <span class="comment">// &lt;- jobDataMap 주입</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    ... 이하 생략 ...</span><br></pre></td></tr></table></figure><p>그리고 <code>HelloJob</code> 클래스도 <code>JobDataMap</code>에 담긴 정보를 사용하도록 바꿔보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJob</span> <span class="keyword">extends</span> <span class="title">BaseJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doExecute</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"### &#123;&#125; is being executed!"</span>,</span><br><span class="line">                context.getJobDetail().getJobDataMap().get(<span class="string">"JobName"</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트를 재실행하면 다음과 같이 <code>JobDataMap</code>에 담은 정보가 함께 출력된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>:<span class="number">57</span>:<span class="number">06.889</span> [DefaultQuartzScheduler_Worker-<span class="number">1</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - %%% Before executing job</span><br><span class="line">01:57:06.889 [DefaultQuartzScheduler_Worker-1] INFO io.homo.efficio.scratchpad.quartz.HelloJob - ### Job Chain 1 is being executed!</span><br><span class="line"><span class="number">01</span>:<span class="number">57</span>:<span class="number">06.891</span> [DefaultQuartzScheduler_Worker-<span class="number">1</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - %%% After executing job</span><br><span class="line"><span class="number">01</span>:<span class="number">57</span>:<span class="number">06.891</span> [DefaultQuartzScheduler_Worker-<span class="number">1</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - $$$ Schedule Next Job</span><br></pre></td></tr></table></figure><p>이제 <code>JobDataMap</code>에 다음 Job에 대한 정보를 담으면 Job Chaining을 할 수 있을 것 같다.</p><h3 id="Chaining-기본-아이디어"><a href="#Chaining-기본-아이디어" class="headerlink" title="Chaining 기본 아이디어"></a>Chaining 기본 아이디어</h3><p>Job과 JobDataMap은 일대일 관계이므로, </p><ul><li>Chaining 할 모든 Job 정보를 큐에 담고, </li><li>그 큐를 처음 실행되는 Job의 <code>JobDataMap</code>에 담은 후에, </li><li>Job 실행이 완료되면 후처리 단계에서 실행이 완료된 Job을 큐에서 하나씩 빼주고,</li><li>다음 Job을 실행할 때 그 큐를 다음 Job의 <code>JobDataMap</code>에 넣어주고 스케줄링</li><li>큐가 비워지면 Chaining은 종료된다. </li></ul><h3 id="Chaining-할-여러-Job-생성"><a href="#Chaining-할-여러-Job-생성" class="headerlink" title="Chaining 할 여러 Job 생성"></a>Chaining 할 여러 Job 생성</h3><p>Job 3개를 Chaining해서 실행할 수 있도록 테스트 코드를 변경한다. </p><p>예제에서는 편의상 3개의 Job에 모두 <code>HelloJob.class</code>만을 사용했지만, 실제로는 서로 다른 클래스를 사용해도 무방하다. 또한 <a href="http://www.quartz-scheduler.org/api/2.2.1/org/quartz/JobBuilder.html" target="_blank" rel="noopener">JobBuilder API</a>를 참고하면 Job마다 원하는 대로 식별자를 줄 수도 있고 오류 시 재실행 옵션 등 다양하게 설정할 수 있다. <a href="http://www.quartz-scheduler.org/api/2.2.1/org/quartz/TriggerBuilder.html" target="_blank" rel="noopener">TriggerBuilder API</a>를 참고하면 <code>Trigger</code>도 원하는 대로 더 다양하게 구성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloJob</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Job 1 구성</span></span><br><span class="line">        JobDataMap jobDataMap1 = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">        jobDataMap1.put(<span class="string">"JobName"</span>, <span class="string">"Job Chain 1"</span>);</span><br><span class="line">        JobDetail jobDetail1 = newJob(HelloJob.class)</span><br><span class="line">                .usingJobData(jobDataMap1)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Job 2 구성</span></span><br><span class="line">        JobDataMap jobDataMap2 = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">        jobDataMap2.put(<span class="string">"JobName"</span>, <span class="string">"Job Chain 2"</span>);</span><br><span class="line">        JobDetail jobDetail2 = newJob(HelloJob.class)</span><br><span class="line">                .usingJobData(jobDataMap2)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Job 3 구성</span></span><br><span class="line">        JobDataMap jobDataMap3 = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">        jobDataMap3.put(<span class="string">"JobName"</span>, <span class="string">"Job Chain 3"</span>);</span><br><span class="line">        JobDetail jobDetail3 = newJob(HelloJob.class)</span><br><span class="line">                .usingJobData(jobDataMap3)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><h3 id="Job-정보를-JobDataMap에-저장"><a href="#Job-정보를-JobDataMap에-저장" class="headerlink" title="Job 정보를 JobDataMap에 저장"></a>Job 정보를 JobDataMap에 저장</h3><p>실행할 모든 Job의 <code>JobDetail</code>를 첫 번째 <code>JobDetail</code>의 <code>JobDataMap</code>에 담는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행할 모든 Job의 JobDetail를 jobDetail1의 JobDataMap에 담는다.</span></span><br><span class="line">List&lt;JobDetail&gt; jobDetailQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">jobDetailQueue.add(jobDetail1);</span><br><span class="line">jobDetailQueue.add(jobDetail2);</span><br><span class="line">jobDetailQueue.add(jobDetail3);</span><br><span class="line"><span class="comment">// 주의사항: 아래와 같이 jopDataMap1에 저장하면 반영되지 않는다.</span></span><br><span class="line"><span class="comment">// jobDataPam1.put("JobDetailQueue", jobDetailQueue);</span></span><br><span class="line"><span class="comment">// 아래와 같이 jobDetail1에서 getJobDataMap()으로 새로 가져온 JobDataMap에 저장해야 한다.</span></span><br><span class="line">jobDetail1.getJobDataMap().put(<span class="string">"JobDetailQueue"</span>, jobDetailQueue);</span><br></pre></td></tr></table></figure><p>테스트 코드의 나머지 부분은 변경할 것이 없다.</p><p>나머지는 <code>BaseJob</code>에서 처리한다.</p><h3 id="후처리-단계에서-완료된-Job을-큐에서-제거"><a href="#후처리-단계에서-완료된-Job을-큐에서-제거" class="headerlink" title="후처리 단계에서 완료된 Job을 큐에서 제거"></a>후처리 단계에서 완료된 Job을 큐에서 제거</h3><p><code>BaseJob</code>의 후처리 메서드인 <code>afterExecute()</code>를 다음과 같이 작성해서 큐에서 완료된 Job을 제거한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"%%% After executing job"</span>);</span><br><span class="line">    Object object = context.getJobDetail().getJobDataMap().get(<span class="string">"JobDetailQueue"</span>);</span><br><span class="line">    List&lt;JobDetail&gt; jobDetailQueue = (List&lt;JobDetail&gt;) object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jobDetailQueue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        jobDetailQueue.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="다음-Job-스케줄링"><a href="#다음-Job-스케줄링" class="headerlink" title="다음 Job 스케줄링"></a>다음 Job 스케줄링</h3><p><code>scheduleNextJob()</code> 메서드를 다음과 같이 변경해서, 완료된 Job이 제거된 큐를 <code>JobDataMap</code>에 담고 즉시 실행하는 <code>Trigger</code>를 만들어서 스케줄링 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleNextJob</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"$$$ Schedule Next Job"</span>);</span><br><span class="line">    Object object = context.getJobDetail().getJobDataMap().get(<span class="string">"JobDetailQueue"</span>);</span><br><span class="line">    List&lt;JobDetail&gt; jobDetailQueue = (List&lt;JobDetail&gt;) object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jobDetailQueue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        JobDetail nextJobDetail = jobDetailQueue.get(<span class="number">0</span>);</span><br><span class="line">        nextJobDetail.getJobDataMap().put(<span class="string">"JobDetailQueue"</span>, jobDetailQueue);</span><br><span class="line">        Trigger nowTrigger = newTrigger().startNow().build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 아래의 팩토리 메서드는 이름이 같으면 여러번 호출해도 항상 동일한 스케줄러를 반환한다.</span></span><br><span class="line">            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">            scheduler.start();</span><br><span class="line">            scheduler.scheduleJob(nextJobDetail, nowTrigger);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="테스트-재실행-2"><a href="#테스트-재실행-2" class="headerlink" title="테스트 재실행"></a>테스트 재실행</h3><p>다음과 같이 Job 1, 2, 3이 모두 연속적으로 실행되는 것을 확인할 수 있다. 각 Job마다 서로 다른 워커 스레드에서 실행되는 것도 확인할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">02</span>:<span class="number">33</span>:<span class="number">47.650</span> [DefaultQuartzScheduler_Worker-<span class="number">1</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - %%% Before executing job</span><br><span class="line">02:33:47.650 [DefaultQuartzScheduler_Worker-1] INFO io.homo.efficio.scratchpad.quartz.HelloJob - ### Job Chain 1 is being executed!</span><br><span class="line"><span class="number">02</span>:<span class="number">33</span>:<span class="number">47.651</span> [DefaultQuartzScheduler_Worker-<span class="number">1</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - %%% After executing job</span><br><span class="line"><span class="number">02</span>:<span class="number">33</span>:<span class="number">47.652</span> [DefaultQuartzScheduler_Worker-<span class="number">1</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - $$$ Schedule Next Job</span><br><span class="line">...</span><br><span class="line"><span class="number">02</span>:<span class="number">33</span>:<span class="number">47.655</span> [DefaultQuartzScheduler_Worker-<span class="number">2</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - %%% Before executing job</span><br><span class="line">02:33:47.656 [DefaultQuartzScheduler_Worker-2] INFO io.homo.efficio.scratchpad.quartz.HelloJob - ### Job Chain 2 is being executed!</span><br><span class="line"><span class="number">02</span>:<span class="number">33</span>:<span class="number">47.656</span> [DefaultQuartzScheduler_Worker-<span class="number">2</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - %%% After executing job</span><br><span class="line"><span class="number">02</span>:<span class="number">33</span>:<span class="number">47.656</span> [DefaultQuartzScheduler_Worker-<span class="number">2</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - $$$ Schedule Next Job</span><br><span class="line">...</span><br><span class="line"><span class="number">02</span>:<span class="number">33</span>:<span class="number">47.658</span> [DefaultQuartzScheduler_Worker-<span class="number">3</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - %%% Before executing job</span><br><span class="line">02:33:47.658 [DefaultQuartzScheduler_Worker-3] INFO io.homo.efficio.scratchpad.quartz.HelloJob - ### Job Chain 3 is being executed!</span><br><span class="line"><span class="number">02</span>:<span class="number">33</span>:<span class="number">47.658</span> [DefaultQuartzScheduler_Worker-<span class="number">3</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - %%% After executing job</span><br><span class="line"><span class="number">02</span>:<span class="number">33</span>:<span class="number">47.659</span> [DefaultQuartzScheduler_Worker-<span class="number">3</span>] INFO io.homo.efficio.scratchpad.quartz.BaseJob - $$$ Schedule Next Job</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>예제에서는 단순함을 위해 연속적으로 실행될 여러 Job을 관리하는 객체를 따로 만들지 않고 테스트 객체가 그 역할을 담당했지만, 실무에서는 예를 들면 <code>Batch</code> 같은 객체를 두고 그 안에 <code>List&lt;Job&gt;</code>을 둬서 책임 분리를 하는 것도 좋다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><blockquote><p>쿼츠 스케줄러(Quartz Scheduler)는 문서화가 정말로 잘 되어 있고 API 설계도 잘 되어 있어서 정말 금방 익혀서 사용할 수 있다.</p><p>다만, 연속적으로 Job을 실행할 수 있는 Job Chaining이 기본 사항으로 지원되지 않아 아쉽지만,</p><p>템플릿 메서드 패턴을 적용하면 어렵지 않게 Job Chaining을 구현해서 적용할 수 있다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-Quartz-Scheduler-Job-Chaining-구현&quot;&gt;&lt;a href=&quot;#Java-Quartz-Scheduler-Job-Chaining-구현&quot; class=&quot;headerlink&quot; title=&quot;Java Quartz Schedu
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Quartz" scheme="http://homoefficio.github.io/tags/Quartz/"/>
    
      <category term="Scheduler" scheme="http://homoefficio.github.io/tags/Scheduler/"/>
    
      <category term="Job Chaining" scheme="http://homoefficio.github.io/tags/Job-Chaining/"/>
    
      <category term="Template Method Pattern" scheme="http://homoefficio.github.io/tags/Template-Method-Pattern/"/>
    
      <category term="쿼츠" scheme="http://homoefficio.github.io/tags/%EC%BF%BC%EC%B8%A0/"/>
    
      <category term="스케줄러" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC/"/>
    
      <category term="Job 연속 실행" scheme="http://homoefficio.github.io/tags/Job-%EC%97%B0%EC%86%8D-%EC%8B%A4%ED%96%89/"/>
    
      <category term="Job 순차 실행" scheme="http://homoefficio.github.io/tags/Job-%EC%88%9C%EC%B0%A8-%EC%8B%A4%ED%96%89/"/>
    
      <category term="템플릿 메서드 패턴" scheme="http://homoefficio.github.io/tags/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4/"/>
    
  </entry>
  
  <entry>
    <title>EOS 계정 생성</title>
    <link href="http://homoefficio.github.io/2018/07/09/EOS-%EA%B3%84%EC%A0%95-%EC%83%9D%EC%84%B1/"/>
    <id>http://homoefficio.github.io/2018/07/09/EOS-계정-생성/</id>
    <published>2018-07-08T15:18:11.000Z</published>
    <updated>2018-10-13T15:49:56.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EOS-계정-생성"><a href="#EOS-계정-생성" class="headerlink" title="EOS 계정 생성"></a>EOS 계정 생성</h1><p>공식 문서 <a href="https://developers.eos.io/eosio-nodeos/docs/learn-about-wallets-keys-and-accounts-with-cleos#section-creating-an-account" target="_blank" rel="noopener">https://developers.eos.io/eosio-nodeos/docs/learn-about-wallets-keys-and-accounts-with-cleos#section-creating-an-account</a> 를 기준으로 약간의 커스터마이징과 과도한 친절함을 가미했다.</p><p>블록체인의 상태에 영향을 미치는 액션을 수행하려면 계정이 필요하다.</p><p><code>cleos</code>를 써서 <code>nodeos</code>로 하여금 계정을 생성하고 생성된 계정을 블록체인에 발행하게 할 수 있다. 계정을 생성하려면 기존 계정과 기존 계정의 key가 필요하다. 이를 위해 지갑이 필요하며, 지갑을 사용하려면 <code>keosd</code>를 실행해야 한다.</p><p>또한 계정을 생성하고 발행할 <code>nodeos</code>를 실행해서 EOS 노드를 띄워야 한다.</p><p>이런 관계는 아래 그림을 보면 더 쉽게 이해할 수 있다.</p><p><img src="https://i.imgur.com/nnJYbmt.png" alt="Imgur"></p><h2 id="keosd-실행"><a href="#keosd-실행" class="headerlink" title="keosd 실행"></a>keosd 실행</h2><p>계정 생성을 하려면 <code>keosd</code>와 <code>nodeos</code>를 동시에 띄워야 하는데, <code>keosd</code>를 <code>cleos</code>를 통하지 않고 직접 실행하면 8888 포트에서 실행되는데 <code>nodeos</code>도 8888 포트에서 실행되게 설정되어 있으므로 <code>keosd</code>의 설정을 변경해야 하는데, 아래 두 가지 방식 중 하나를 택해서 <code>keosd</code>를 실행하면 된다. 여기에서는 <code>keosd</code> 실행 시 옵션 지정 방식으로 진행한다.</p><h3 id="keosd-설정-파일-수정"><a href="#keosd-설정-파일-수정" class="headerlink" title="keosd 설정 파일 수정"></a>keosd 설정 파일 수정</h3><p><code>keosd</code> 설정 파일은 <code>--data-dir</code>로 지갑 데이터 저장 위치를 따로 지정하지 않았다면 기본값으로 <code>~/eosio-wallet/</code>에 저장된 <code>config.ini</code> 파일이다. <code>http-server-address = 127.0.0.1:8888</code>로 되어 있는 것을 <code>http-server-address = 127.0.0.1:8899</code>로 변경한다.</p><p><img src="https://i.imgur.com/QETOABh.png" alt="Imgur"></p><h3 id="keosd-실행-시-옵션-지정"><a href="#keosd-실행-시-옵션-지정" class="headerlink" title="keosd 실행 시 옵션 지정"></a>keosd 실행 시 옵션 지정</h3><p>다음과 같이 혹시 실행 중일 수 있는 <code>keosd</code>를 종료하고 새로 <code>keosd</code>를 실행한다. EOSIO 빌드 및 설치 과정에서 <code>make install</code>을 해줬다면 어느 디렉터리에서 실행해도 무방하다.</p><blockquote><p>pkill keosd</p><p>keosd --http-server-address=localhost:8899</p><p>1.0.9부터는 아래와 같이 --http-validate-host=false를 추가해줘야 cleos로 계정 생성 시 에러가 발생하지 않는다.</p><p>keosd --http-server-address=localhost:8899 --http-validate-host=false</p></blockquote><p><img src="https://i.imgur.com/W2LvKKU.png" alt="Imgur"></p><h2 id="nodeos-실행"><a href="#nodeos-실행" class="headerlink" title="nodeos 실행"></a>nodeos 실행</h2><p>새로운 터미널에서 <code>nodeos</code> 명령으로 EOS 노드를 띄운다.</p><blockquote><p>nodeos -e -p eosio --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin --http-validate-host=false</p></blockquote><p><em><code>nodeos</code> 명령으로 EOS 노드를 띄우는 자세한 내용은 <a href="https://homoefficio.github.io/2018/06/06/EOS-Single-Node-Testnet-실행/">EOS Single Node Testnet 실행</a>을 참고한다.</em></p><p><img src="https://i.imgur.com/PQ3oqEt.png" alt="Imgur"></p><h2 id="계정-생성-준비"><a href="#계정-생성-준비" class="headerlink" title="계정 생성 준비"></a>계정 생성 준비</h2><h3 id="사전-준비"><a href="#사전-준비" class="headerlink" title="사전 준비"></a>사전 준비</h3><p>EOS 블록체인에서 계정을 생성하려면 여러가지 사전 준비가 필요하다.</p><ul><li>nodeos: 계정 생성도 트랜잭션이므로 nodeos가 실행되어 있어야 한다.</li><li>이미 존재하는 계정: 계정 생성이 이미 존재하는 계정이 실행하는 트랜잭션이므로 이미 존재하는 계정이 필요하다.</li><li>이미 존재하는 계정의 키가 연동된 지갑: 계정 생성의 주체인 authorizing_account의 서명, 즉 authorizing_account의 개인키가 필요하며, 개인키를 읽어올 수 있도록 authorizing_account의 개인키가 연동된 지갑이 있어야한다.</li><li>keosd: 지갑을 사용하므로, <code>keosd</code>가 실행되어 있어야 한다.</li><li>새로 생성할 계정의 owner 자격에 사용될 공개키</li><li>새로 생성할 계정의 active 자격에 사용될 공개키</li></ul><p>Single Node Testnet 에는 EOS 노드를 부트스트랩하는 <code>eosio</code> 계정 하나만 존재하므로, 최초의 사용자 계정을 만들 때는 <code>eosio</code> 계정을 사용할 수 밖에 없다. 그리고 <code>eosio</code> 계정으로 서명을 하므로 <code>eosio</code> 계정의 비밀키가 필요하다.</p><p><code>eosio</code> 계정의 비밀키는 리눅스의 경우 <code>~/.local/share/eosio/nodeos/config/config.ini</code>, 맥의 경우 <code>~/Libraries/Application Support/eosio/nodeos/config/config.ini</code> 파일 안에 <code>signature-provider</code>라는 항목의 <code>KEY</code>에 명시되어 있다.</p><h3 id="이미-존재하는-계정의-키가-연동된-지갑-생성"><a href="#이미-존재하는-계정의-키가-연동된-지갑-생성" class="headerlink" title="이미 존재하는 계정의 키가 연동된 지갑 생성"></a>이미 존재하는 계정의 키가 연동된 지갑 생성</h3><p>아래의 명령으로 계정 생성에 사용되는 <code>eosio</code> 계정의 키와 연동된 지갑 <code>temp</code>를 만든다.</p><blockquote><p>cleos --wallet-url=<a href="http://localhost:8899" target="_blank" rel="noopener">http://localhost:8899</a> wallet create -n temp</p></blockquote><p>!15</p><p>아래와 같이 지갑 목록을 조회하면 <code>temp</code> 지갑이 표시되며, 지갑 이름 옆의 <code>*</code> 표시는 지갑의 잠금이 해제되어 있음을 의미한다.</p><p>!16</p><h3 id="새로-생성할-계정에-사용될-키-생성"><a href="#새로-생성할-계정에-사용될-키-생성" class="headerlink" title="새로 생성할 계정에 사용될 키 생성"></a>새로 생성할 계정에 사용될 키 생성</h3><p>새로 생성할 계정의 <code>owner_key</code>, <code>active_key</code>에 사용될 키 두 개 생성</p><blockquote><p>cleos create key</p></blockquote><p>!17</p><p><img src="https://i.imgur.com/ecbRbVy.png" alt="Imgur"></p><h3 id="계정-생성-명령"><a href="#계정-생성-명령" class="headerlink" title="계정 생성 명령"></a>계정 생성 명령</h3><p>계정 생성 명령은 다음과 같다.</p><blockquote><p>cleos create account ${authorizing_account} ${new_account} ${owner_key} ${active_key}</p></blockquote><ul><li><code>${authorizing_account}</code>: 새 계정을 생성해서 블록체인에 발행하는 역할을 담당하는 기존 계정</li><li><code>${new_account}</code>: 새로 생성될 계정의 이름</li><li><code>${owner_key}</code>: 새로 생성될 계정의 owner 자격(authority)에 할당될 공개키</li><li><code>${active_key}</code>: 새로 생성될 계정의 active 자격(authority)에 할당될 공개키</li></ul><h4 id="새-계정-이름-규칙"><a href="#새-계정-이름-규칙" class="headerlink" title="새 계정 이름 규칙"></a>새 계정 이름 규칙</h4><ul><li>12글자까지 허용</li><li>허용되는 문자: <code>.12345abcdefghijklmnopqrstuvwxyz</code></li></ul><h4 id="owner-자격-owner-authority"><a href="#owner-자격-owner-authority" class="headerlink" title="owner 자격(owner authority)"></a>owner 자격(owner authority)</h4><p>계정의 소유권을 나타내는 자격이다. owner 자격을 필요로 하는 트랜잭션은 별로 없지만 소유자 권한을 변경하는 액션에는 owner 자격이 필요하다.</p><p>owner 자격에 할당된 키는 콜드 저장소(cold storage)에 저장하는 것이 좋으며 누구와도 공유하지 말아야 한다.</p><p>도용된 권한(permission)을 복구하는데도 owner 자격이 필요하다.</p><h4 id="active-자격-active-authority"><a href="#active-자격-active-authority" class="headerlink" title="active 자격(active authority)"></a>active 자격(active authority)</h4><p>송/수금, 블록 생산자(BP, Block Producer) 투표 및 고차원의 계정 사항 변경에 사용되는 자격이다. 대부분의 트랜잭션은 이 active 자격으로 생성할 수 있다.</p><h3 id="계정-생성"><a href="#계정-생성" class="headerlink" title="계정 생성"></a>계정 생성</h3><p>계정 생성 과정을 이해하기 위해 먼저 앞서 다룬 사전 조건과 시나리오를 정리해보자.</p><h4 id="authorizing-account-계정-생성을-실행하는-계정"><a href="#authorizing-account-계정-생성을-실행하는-계정" class="headerlink" title="${authorizing_account}(계정 생성을 실행하는 계정)"></a>${authorizing_account}(계정 생성을 실행하는 계정)</h4><p>Single Node Testnet에 이미 존재하는 유일한 계정은 Single Node를 실행할 때 사용되는 <code>eosio</code>밖에 없다. 따라서 처음 커스텀 계정을 생성할 때는 <code>eosio</code> 계정을 사용해야 한다. 이는 <code>eosio</code> 계정의 비밀키도 알아야 한다는 의미이며 비밀키 확인 방법은 위 ‘사전 준비’ 부분에 나와있다.</p><h4 id="new-account"><a href="#new-account" class="headerlink" title="${new_account}"></a>${new_account}</h4><p>새 계정 이름은 규칙에 맞에 임의로 지정하면 된다. 예제에서는 <code>homo.efficio</code>로 한다.</p><h4 id="owner-key-active-key"><a href="#owner-key-active-key" class="headerlink" title="${owner_key}, ${active_key}"></a>${owner_key}, ${active_key}</h4><p>새로 생성될 계정의 owner 자격과 active 자격에 사용할 키는 앞서 <a href="https://homoefficio.github.io/2018/06/06/EOS-지갑-만들기-및-Key-연동/">EOS 지갑 만들기 및 Key 연동</a>에서 ‘Homo-Efficio’ 지갑에 연동했던 두 개의 키의 공개키를 사용한다.</p><ul><li>owner 자격에 사용할 <code>${owner_key}</code>: <code>EOS5pBeZiRgKRrLCCCFZ23EuP2d7XXK8UhYdbRSauXjyGrPjApLAW</code></li><li>active 자격에 사용할 <code>${active_key}</code>: <code>EOS8cQKoirjCNSVVywC7WwhuzSg1bC5Q5vG5YhDmAcwf3bVoPys3e</code></li></ul><h4 id="시나리오-이해"><a href="#시나리오-이해" class="headerlink" title="시나리오 이해"></a>시나리오 이해</h4><p>계정 생성 시나리오를 정리하면 다음과 같다.</p><blockquote><p><code>homo.efficio</code>라는 신규 계정 생성에 <code>eosio</code>라는 기존 계정을 사용하며,</p><p>‘Homo-Efficio’ 지갑에 연동했던 두 개의 키를 새로 생성할 계정의 <code>owner_key</code>, <code>active_key</code>로 설정한다.</p></blockquote><p>그림으로 나타내면 다음과 같다.</p><p><img src="https://i.imgur.com/YNsQPK1.png" alt="Imgur"></p><p>결국에는 키를 매개체로 해서 <code>Homo-Efficio</code>라는 지갑과 <code>homo.efficio</code>라는 계정이 간접적으로 연결되는 모양새다. 위 그림을 토대로 새 계정이 생성된 후 새 계정과 지갑의 관계를 정리해보면 다음과 같다.</p><blockquote><p><code>homo.efficio</code>라는 계정으로 어떤 트랜잭션을 발생시킬 때</p><p>필요한 키 정보를 <code>Homo-Efficio</code>라는 지갑에서 가져온다.</p></blockquote><h2 id="계정-생성-실행"><a href="#계정-생성-실행" class="headerlink" title="계정 생성 실행"></a>계정 생성 실행</h2><h3 id="오류-테스트"><a href="#오류-테스트" class="headerlink" title="오류 테스트"></a>오류 테스트</h3><p>시험 삼아 길이가 12자를 넘는 계정 이름으로 계정을 생성해보면 다음과 같은 에러가 발생한다.</p><p><img src="https://i.imgur.com/sRJcHHm.png" alt="Imgur"></p><h3 id="지갑-잠금-오류"><a href="#지갑-잠금-오류" class="headerlink" title="지갑 잠금 오류"></a>지갑 잠금 오류</h3><p>지갑 잠금 해제 되지 않은 상태에서 계정 생성을 실행하면 다음과 같은 에러가 발생한다.</p><p><img src="https://i.imgur.com/vdL9ahu.png" alt="Imgur"></p><p>지갑 잠금 오류는 <code>keosd</code> 실행 화면에도 로그가 찍힌다.</p><p><img src="https://i.imgur.com/MKyVMjT.png" alt="Imgur"></p><h3 id="지갑-잠금-해제-후-계정-생성"><a href="#지갑-잠금-해제-후-계정-생성" class="headerlink" title="지갑 잠금 해제 후 계정 생성"></a>지갑 잠금 해제 후 계정 생성</h3><p>계정 생성의 주체인 <code>eosio</code> 계정의 키를 연동하는 지갑가 연동되어 있는 지갑을 해제한 후, <code>homo.efficio</code> 계정 생성을 실행하면 다음과 같은 에러가 발생한다.</p><p><img src="https://i.imgur.com/Sj1QugF.png" alt="Imgur"></p><p>이 에러는 <code>keosd</code> 관련 오류가 아니므로 <code>keosd</code> 화면에는 별다른 로그가 찍히지 않지만, <code>nodeos</code> 화면에 더 자세한 에러 로그가 찍힌다.</p><p><img src="https://i.imgur.com/Ak37Z07.png" alt="Imgur"></p><p>에러 내용은 serialization 수행 시간이 초과된 것이 원인인 것 같다.</p><p>혹시 잠금 해제해야할 지갑이 <code>Homo-Efficio</code>가 아니라 <code>default</code> 지갑인가 싶어서 다음과 같이 <code>Homo-Efficio</code> 지갑을 다시 잠그고 <code>default</code> 지갑을 잠금 해제한 후 다시 계정 생성을 시도하면, 이번에는 계정이 이미 있다는 에러가 발생한다.</p><p><img src="https://i.imgur.com/CnPqN3N.png" alt="Imgur"></p><p><code>nodeos</code> 화면에 더 자세한 로그가 찍힌다.</p><p><img src="https://i.imgur.com/MgN1qwB.png" alt="Imgur"></p><p><code>cleos get account homo.efficio</code> 명령으로 계정을 확인해보면 계정이 생성되어 있는 것으로 나온다.</p><p><img src="https://i.imgur.com/OpWGCPH.png" alt="Imgur"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EOS-계정-생성&quot;&gt;&lt;a href=&quot;#EOS-계정-생성&quot; class=&quot;headerlink&quot; title=&quot;EOS 계정 생성&quot;&gt;&lt;/a&gt;EOS 계정 생성&lt;/h1&gt;&lt;p&gt;공식 문서 &lt;a href=&quot;https://developers.eos.io/e
      
    
    </summary>
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/tags/BlockChain/"/>
    
      <category term="EOS" scheme="http://homoefficio.github.io/tags/EOS/"/>
    
      <category term="블록체인" scheme="http://homoefficio.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="이오스" scheme="http://homoefficio.github.io/tags/%EC%9D%B4%EC%98%A4%EC%8A%A4/"/>
    
      <category term="development" scheme="http://homoefficio.github.io/tags/development/"/>
    
      <category term="개발" scheme="http://homoefficio.github.io/tags/%EA%B0%9C%EB%B0%9C/"/>
    
      <category term="dapp" scheme="http://homoefficio.github.io/tags/dapp/"/>
    
      <category term="디앱" scheme="http://homoefficio.github.io/tags/%EB%94%94%EC%95%B1/"/>
    
      <category term="Wallet" scheme="http://homoefficio.github.io/tags/Wallet/"/>
    
      <category term="Account" scheme="http://homoefficio.github.io/tags/Account/"/>
    
      <category term="nodeos" scheme="http://homoefficio.github.io/tags/nodeos/"/>
    
      <category term="keosd" scheme="http://homoefficio.github.io/tags/keosd/"/>
    
      <category term="cleos" scheme="http://homoefficio.github.io/tags/cleos/"/>
    
      <category term="지갑" scheme="http://homoefficio.github.io/tags/%EC%A7%80%EA%B0%91/"/>
    
      <category term="계정" scheme="http://homoefficio.github.io/tags/%EA%B3%84%EC%A0%95/"/>
    
  </entry>
  
  <entry>
    <title>EOS 지갑 만들기 및 Key 연동</title>
    <link href="http://homoefficio.github.io/2018/06/06/EOS-%EC%A7%80%EA%B0%91-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%8F-Key-%EC%97%B0%EB%8F%99/"/>
    <id>http://homoefficio.github.io/2018/06/06/EOS-지갑-만들기-및-Key-연동/</id>
    <published>2018-06-05T23:55:13.000Z</published>
    <updated>2018-10-13T15:49:56.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EOS-지갑-만들기-및-Key-연동"><a href="#EOS-지갑-만들기-및-Key-연동" class="headerlink" title="EOS 지갑 만들기 및 Key 연동"></a>EOS 지갑 만들기 및 Key 연동</h1><p>공식 문서인 <a href="https://developers.eos.io/eosio-nodeos/docs/learn-about-wallets-keys-and-accounts-with-cleos" target="_blank" rel="noopener">https://developers.eos.io/eosio-nodeos/docs/learn-about-wallets-keys-and-accounts-with-cleos</a> 를 기준으로 약간의 커스터마이징과 과도한 친절함을 가미했다.</p><h2 id="EOSIO-아키텍처-다시-보기"><a href="#EOSIO-아키텍처-다시-보기" class="headerlink" title="EOSIO 아키텍처 다시 보기"></a>EOSIO 아키텍처 다시 보기</h2><p><img src="https://i.imgur.com/nnJYbmt.png" alt="Imgur"></p><p>이 글에서는 위 3가지 컴포넌트 중 <code>cleos</code>와 <code>keosd</code>에 대해 알아본다.</p><h2 id="지갑과-계정"><a href="#지갑과-계정" class="headerlink" title="지갑과 계정"></a>지갑과 계정</h2><h3 id="지갑-Wallet"><a href="#지갑-Wallet" class="headerlink" title="지갑(Wallet)"></a>지갑(Wallet)</h3><p>지갑은 블록체인의 상태에 영향을 미치는 연산을 승인할 때 필요한 공개키-비밀키 쌍을 담고 있는 저장소다. 지갑 데이터는 <code>keosd</code>에 의해 관리 되지만 대부분 직접 <code>keosd</code> 명령을 실행하지 않고 <code>cleos</code>를 통해 <code>keosd</code>를 실행한다.</p><p><code>keosd</code>는 지갑 파일을 기본 옵션으로 <code>~/eosio-wallet</code> 디렉터리에 저장한다.</p><h3 id="계정-Account"><a href="#계정-Account" class="headerlink" title="계정(Account)"></a>계정(Account)</h3><p>계정은 블록체인에 대한 접근 권한을 가진 식별자라고 할 수 있다. <code>nodeos</code>가 계정의 발행과 블록체인에 대한 계정 관련 액션(action)을 관리하지만, <code>cleos</code>를 통해서도 관리할 수 있다.</p><h3 id="지갑과-계정의-관계"><a href="#지갑과-계정의-관계" class="headerlink" title="지갑과 계정의 관계"></a>지갑과 계정의 관계</h3><p>직관적으로는 계정이 지갑을 가지고 있을 것 같지만, EOS의 지갑과 계정은 직접적인 관계가 없다. 계정은 지갑의 존재를 모르고, 지갑은 계정의 존재를 모른다. 둘 사이에 직접적인 관계가 없음은 위의 EOSIO 아키텍처 그림에서도 알 수 있다. <code>nodeos</code>와 <code>keosd</code> 사이에는 직접적인 관계가 없고 서로의 존재를 모른다.</p><p>둘 사이에 간접적이나마 관계가 발생하는 것은 서명이 필요할 때다. 지갑을 사용하면 보안을 위해 암호화되어 잠금 처리를 할 수 있는 로컬 저장 공간에서 서명을 효율적으로 가져올 수 있다. 키 조회를 담당하는 <code>keosd</code>와 키를 사용하는 서명을 필요로 하는 액션 처리를 담당하는 <code>nodeos</code> 사이에서 <code>cleos</code>가 효과적인 중재자 역할을 담당한다.</p><h2 id="지갑-목록-확인"><a href="#지갑-목록-확인" class="headerlink" title="지갑 목록 확인"></a>지갑 목록 확인</h2><p><img src="https://i.imgur.com/GDyaXFi.png" alt="Imgur"></p><p>위 캡처 화면 내용은 다음과 같다.</p><ol><li><p><code>cleos wallet</code> 명령으로 <code>keosd</code>를 실행하기 전에는 <code>~/eosio-wallet</code> 디렉터리는 생성되어 있지 않다.</p></li><li><p><code>cleos wallet list</code> 명령을 실행하면 <code>keosd</code>가 실행되고 지갑 목록이 표시된다. 아직 지갑을 생성하지 않았으므로 지갑 목록은 비어 있다. 이처럼 <code>cleos wallet</code> 명령을 통해 <code>keosd</code>가 자동으로 실행되므로 별도로 직접 <code>keosd</code> 명령을 실행할 필요가 없다.</p></li><li><p><code>ps -ef | grep keosd</code> 명령을 실행하면 <code>keosd</code>가 실행되어 있고 <code>http://127.0.0.1/8900</code>으로 접근할 수 있음을 알 수 있다.</p></li><li><p><code>keosd</code>가 실행되면서 <code>~/eosio-wallet</code> 디렉터리와 <code>keosd</code> 설정 파일인 <code>config.ini</code> 파일이 생성된다.</p></li></ol><h2 id="지갑-생성"><a href="#지갑-생성" class="headerlink" title="지갑 생성"></a>지갑 생성</h2><p>지갑의 생성도 다음과 같이 <code>cleos</code> 명령을 통해 실행한다. 지갑은 <code>nodeos</code>의 실행 여부와 관계없이 생성될 수 있다.</p><blockquote><p>cleos wallet create</p></blockquote><p><img src="https://i.imgur.com/aykCLV4.png" alt="Imgur"></p><p>이름이 default인 지갑은 이제 <code>keosd</code>의 관리 대상에 포함되며, 생성된 지갑의 마스터 패스워드가 생성되고 화면에 표시된다. 이 패스워드로 지갑 파일의 잠금을 해제할 수 있으므로 분실되지 않도록 잘 보관해야 한다.</p><p><code>keosd</code>는 지갑 파일을 <code>~/eosio-wallet</code> 폴더에 저장한다(eos/programs/keosd/main.cpp 에 하드코딩 되어 있음).</p><blockquote><p>ll ~/eosio-wallet</p></blockquote><p><img src="https://i.imgur.com/E7AjVZC.png" alt="Imgur"></p><p><em>참고: 공식 문서(<a href="https://developers.eos.io/eosio-nodeos/docs/learn-about-wallets-keys-and-accounts-with-cleos" target="_blank" rel="noopener">https://developers.eos.io/eosio-nodeos/docs/learn-about-wallets-keys-and-accounts-with-cleos</a>) 에는 <code>keosd</code>의 <code>--data-dir</code> 옵션으로 지갑 파일이 저장되는 데이터 폴더를 지정할 수 있다고 언급되어 있다. 하지만 이후 내용에서 <code>keosd</code>를 직접 실행하는 부분이 없고 <code>cleos</code>만을 사용하며, <code>keosd</code>를 사용하지 않으므로 <code>--data-dir</code>를 써서 지갑 데이터가 저장될 위치를 따로 지정할 기회가 없고, 결국 기본값대로 <code>~/eosio-wallet</code> 폴더에 지갑 파일이 생성된다.</em></p><p><code>-n</code> 옵션을 이용하면 이름을 지정해서 지갑을 생성할 수도 있다. <del>따옴표를 이용하면 공백이 포함된 이름도 가능하다.</del> 이 글을 처음 쓸 때는 공백이 허용됐었는데 아래 화면과 같이 2018-06-07에 관련 소스가 변경되어 <strong>공백은 허용되지 않고 알파벳과 숫자, <code>._-</code>만 허용</strong>된다.</p><p><img src="https://i.imgur.com/7OHbxxl.png" alt="Imgur"></p><p><del>따라서 아래에 나오는, 공백이 포함된 <code>Homo Efficio</code>는 더이상 유효하지 않으며 <code>Homo-Efficio</code>라고 썼다고 가정하자(다시 다 캡처해서 올리자니 눈물이.. ㅠㅜ).</del> 다시 캡처해서 업데이트 완료.</p><blockquote><p>cleos wallet create -n Homo-Efficio</p></blockquote><p><img src="https://i.imgur.com/gLIL4rG.png" alt="Imgur"></p><h2 id="지갑-목록-확인-1"><a href="#지갑-목록-확인-1" class="headerlink" title="지갑 목록 확인"></a>지갑 목록 확인</h2><blockquote><p>cleos wallet list</p></blockquote><p><img src="https://i.imgur.com/2dZ310g.png" alt="Imgur"></p><p>생성한 지갑 목록이 표시된다. <code>*</code>표는 지갑이 잠금 해제(unlocked) 되어 있음을 의미한다.</p><p><code>cleos wallet create</code> 명령으로 생성된 지갑은 편의상 잠금 해제된다.</p><h2 id="지갑-잠금"><a href="#지갑-잠금" class="headerlink" title="지갑 잠금"></a>지갑 잠금</h2><p>아래와 같이 ‘Homo-Efficio’ 지갑을 잠그고 지갑 목록을 확인하면 ‘Homo-Efficio’ 지갑 옆에는 <code>*</code> 표시가 나타나지 않는다.</p><blockquote><p>cleos wallet lock -n Homo-Efficio</p><p>cleos wallet list</p></blockquote><p><img src="https://i.imgur.com/xW91sHG.png" alt="Imgur"></p><p>지갑이 잠긴 상태에서는 블록체인에 상태 변화를 일으키는 액션을 수행할 수 없다.</p><h2 id="지갑-열기"><a href="#지갑-열기" class="headerlink" title="지갑 열기"></a>지갑 열기</h2><p>이제 <code>keosd</code>를 종료하고 다시 시작하면 어떤 현상이 발생하는지 알아보자.</p><p><code>cleos wallet stop</code> 명령으로 <code>keosd</code>를 종료할 수도 있고, </p><p><img src="https://i.imgur.com/P8Xsg3T.png" alt="Imgur"></p><p>브라우저에서 <code>http://localhost:8900/v1/keosd/stop</code>에 접속해서 <code>keosd</code>를 종료할 수도 있다.</p><p><img src="https://i.imgur.com/fhcKGJr.png" alt="Imgur"></p><p><code>ps -ef | grep keosd</code>로 확인하면 <code>keosd</code> 프로세스가 죽은 것을 확인할 수 있다.</p><p><img src="https://i.imgur.com/Uj5I3g7.png" alt="Imgur"></p><p>다시 <code>cleos wallet list</code> 명령을 실행하면 <code>keosd</code>가 자동으로 실행되지만 앞에서 생성한 지갑 목록은 표시되지 않는다.</p><p><img src="https://i.imgur.com/n6e6JDW.png" alt="Imgur"></p><p>이유는 <code>cleos wallet create</code>로 지갑을 생성했을 때는 지갑이 잠금해제 된 상태로 만들어지고 열린(open) 상태가 되지만, <code>keosd</code>가 종료되면 지갑은 자동으로 잠금 상태가 되고 닫힌 상태가 되기 때문이다.</p><p><code>cleos wallet open</code> 명령을 실행하면 <code>default</code> 지갑이 열리고 <code>cleos wallet list</code> 명령을 실행하면 지갑 목록에 표시되지만, 잠금 상태는 해제되지 않으므로 <code>*</code>는 표시되지 않는다.</p><p><img src="https://i.imgur.com/NjyKtDO.png" alt="Imgur"></p><p><code>cleos wallet unlock</code> 명령을 실행하고 패스워드를 입력하면 <code>default</code> 지갑이 잠금 해제 되어 <code>*</code>가 표시된다.</p><p><img src="https://i.imgur.com/f9sE5RX.png" alt="Imgur"></p><p>이름을 지정해서 만든 ‘Homo-Efficio’ 지갑도 열고, 잠금해제 한다.</p><p><img src="https://i.imgur.com/bfROC9w.png" alt="Imgur"></p><h2 id="Key-생성-및-지갑-연동"><a href="#Key-생성-및-지갑-연동" class="headerlink" title="Key 생성 및 지갑 연동"></a>Key 생성 및 지갑 연동</h2><p>EOSIO의 공개키/비밀키를 생성하는 방법은 여러가지가 있지만, 일단 <code>cleos</code>를 사용해서 만들어보자.</p><blockquote><p>cleos create key</p></blockquote><p><img src="https://i.imgur.com/DvhU7nF.png" alt="Imgur"></p><p>거듭 강조하지만 튜토리얼 말고 실제 사용할 때는 Private key를 아무에게도 노출해서는 안되며 분실되지 않도록 잘 보관해야 한다.</p><p>‘Homo-Efficio’ 지갑에 방금 생성한 key를 연동해보자. 역시 <code>cleos</code>를 사용한다.</p><blockquote><p>cleos wallet import -n Homo-Efficio PRIVATE_KEY_VALUE</p></blockquote><p><img src="https://i.imgur.com/fmOi9sd.png" alt="Imgur"></p><p>연동할 때 입력한 비밀키의 쌍인 공개키 값이 화면에 표시된다. 앞에서 공개키/비밀키 생성 시 Public key로 표시된 값과 같다.</p><p>하나의 지갑에 여러개의 키를 연동할 수 있다. 다음과 같이 키 쌍을 하나더 생성하고 연동해보자.</p><p><img src="https://i.imgur.com/2yxG8zF.png" alt="Imgur"></p><p><code>cleos wallet keys</code> 명령을 사용하면 잠금 해제된 모든 지갑에 연동된 공개키의 목록이 표시된다.</p><blockquote><p>cleos wallet keys</p></blockquote><p><img src="https://i.imgur.com/oX2XZpd.png" alt="Imgur"></p><p><em>참고: 키 2개를 연동한 Homo-Efficio를 지정해서 공개키를 조회했는데 3개가 조회되어 나온다. 이유는 지갑을 생성하면 따로 연동하지 않아도 기본으로 1개의 키(default 지갑에 연동된 것과 같은 키)가 새로 생성한 지갑에 연동되기 때문 -&gt; 이 부분은 v1.0.4에서 패치되어 default 지갑에 연동된 것과 같은 키는 지갑에 연동되지 않고 사용자가 직접 지갑에 연동한 키만 연동된다. 따라서 v1.0.4 이후 버전에서는 직접 연동한 2개만 화면에 표시된다.</em></p><p><del>특정 지갑에 연동된 키 목록만을 조회하는 방법은 없는 것 같다.</del> EOSIO 1.0.2 에서는 다음과 같이 <code>private_keys</code> 서브명령으로 특정 지갑에 연동된 공개키/비밀키 쌍 목록을 조회할 수 있다. 실행하려면 지갑의 비밀번호가 필요하며 비밀키까지 같이 확인할 수 있다.</p><blockquote><p>cleos wallet private_keys</p></blockquote><p><img src="https://i.imgur.com/nMamX8Q.png" alt="Imgur"></p><blockquote><p>cleos wallet private_keys -n Homo-Efficio</p></blockquote><p><img src="https://i.imgur.com/JOhBJGs.png" alt="Imgur"></p><p><em>참고: 키 2개를 연동한 Homo-Efficio를 지정해서 비밀키를 조회했는데 3개가 조회되어 나온다. 이유는 지갑을 생성하면 따로 연동하지 않아도 기본으로 1개의 키(default 지갑에 연동된 것과 같은 키)가 새로 생성한 지갑에 연동되기 때문 -&gt; 이 부분은 v1.0.4에서 패치되어 default 지갑에 연동된 것과 같은 키는 지갑에 연동되지 않고 사용자가 직접 지갑에 연동한 키만 연동된다. 따라서 v1.0.4 이후 버전에서는 직접 연동한 2개만 화면에 표시된다.</em></p><p><code>cleos wallet create_key</code> 명령을 사용하면 <code>cleos create key</code>와 <code>cleos wallet import</code> 두 번의 명령으로 하던 작업을 한 번의 명령으로 실행할 수 있다.</p><p><img src="https://i.imgur.com/l0svF16.png" alt="Imgur"></p><blockquote><p>cleos wallet keys</p></blockquote><p><img src="https://i.imgur.com/SG4coWx.png" alt="Imgur"></p><blockquote><p>cleos wallet private_keys -n Homo-Efficio</p></blockquote><p><img src="https://i.imgur.com/QZNJkNB.png" alt="Imgur"></p><p><em>참고: 3개가 아니라 4개가 나오는 이유는 앞서 말한 것과 같음</em></p><h2 id="지갑-백업"><a href="#지갑-백업" class="headerlink" title="지갑 백업"></a>지갑 백업</h2><p>지갑의 백업은 단순하다 <code>~/eosio-wallet</code> 디렉터리에 있는 지갑 파일을 다른 곳으로 복사해서 백업하면 된다.</p><p><img src="https://i.imgur.com/qIVEGAq.png" alt="Imgur"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EOS-지갑-만들기-및-Key-연동&quot;&gt;&lt;a href=&quot;#EOS-지갑-만들기-및-Key-연동&quot; class=&quot;headerlink&quot; title=&quot;EOS 지갑 만들기 및 Key 연동&quot;&gt;&lt;/a&gt;EOS 지갑 만들기 및 Key 연동&lt;/h1&gt;&lt;p&gt;공식
      
    
    </summary>
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/tags/BlockChain/"/>
    
      <category term="EOS" scheme="http://homoefficio.github.io/tags/EOS/"/>
    
      <category term="블록체인" scheme="http://homoefficio.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="이오스" scheme="http://homoefficio.github.io/tags/%EC%9D%B4%EC%98%A4%EC%8A%A4/"/>
    
      <category term="development" scheme="http://homoefficio.github.io/tags/development/"/>
    
      <category term="개발" scheme="http://homoefficio.github.io/tags/%EA%B0%9C%EB%B0%9C/"/>
    
      <category term="dapp" scheme="http://homoefficio.github.io/tags/dapp/"/>
    
      <category term="디앱" scheme="http://homoefficio.github.io/tags/%EB%94%94%EC%95%B1/"/>
    
      <category term="Wallet" scheme="http://homoefficio.github.io/tags/Wallet/"/>
    
      <category term="Account" scheme="http://homoefficio.github.io/tags/Account/"/>
    
      <category term="nodeos" scheme="http://homoefficio.github.io/tags/nodeos/"/>
    
      <category term="keosd" scheme="http://homoefficio.github.io/tags/keosd/"/>
    
      <category term="cleos" scheme="http://homoefficio.github.io/tags/cleos/"/>
    
      <category term="지갑" scheme="http://homoefficio.github.io/tags/%EC%A7%80%EA%B0%91/"/>
    
  </entry>
  
  <entry>
    <title>EOS Single Node Testnet 실행</title>
    <link href="http://homoefficio.github.io/2018/06/06/EOS-Single-Node-Testnet-%EC%8B%A4%ED%96%89/"/>
    <id>http://homoefficio.github.io/2018/06/06/EOS-Single-Node-Testnet-실행/</id>
    <published>2018-06-05T23:45:33.000Z</published>
    <updated>2018-10-13T15:49:56.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EOS-Single-Node-Testnet-실행"><a href="#EOS-Single-Node-Testnet-실행" class="headerlink" title="EOS Single Node Testnet 실행"></a>EOS Single Node Testnet 실행</h1><p>공식 문서인 <a href="https://developers.eos.io/eosio-nodeos/docs/local-single-node-testnet" target="_blank" rel="noopener">https://developers.eos.io/eosio-nodeos/docs/local-single-node-testnet</a> 를 기준으로 약간의 커스터마이징과 과도한 친절함을 가미했다.</p><h2 id="사전-조건"><a href="#사전-조건" class="headerlink" title="사전 조건"></a>사전 조건</h2><p><a href="https://homoefficio.github.io/2018/06/06/EOS-소스-구성-빌드-및-테스트/">https://homoefficio.github.io/2018/06/06/EOS-소스-구성-빌드-및-테스트/</a> 에서와 같이 빌드를 성공적으로 마치면 아래와 같이 build 디렉토리에 빌드 결과물이 생성된다.</p><p><img src="https://i.imgur.com/3JFK47Y.png" alt="Imgur"></p><h2 id="EOSIO-아키텍처-다시-보기"><a href="#EOSIO-아키텍처-다시-보기" class="headerlink" title="EOSIO 아키텍처 다시 보기"></a>EOSIO 아키텍처 다시 보기</h2><p><img src="https://i.imgur.com/nnJYbmt.png" alt="Imgur"></p><p>이 글에서는 위 3가지 컴포넌트 중 <code>nodeos</code> 실행에 대해 알아본다.</p><h2 id="nodeos-실행"><a href="#nodeos-실행" class="headerlink" title="nodeos 실행"></a>nodeos 실행</h2><blockquote><p>cd build/programs/nodeos</p><p>./nodeos -e -p eosio --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin</p><p>1.0.9 부터는<br>./nodeos -e -p eosio --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin --http-validate-host=false</p></blockquote><ul><li><code>-e</code>: 체인이 stale 상태이더라도 블록을 생성할 수 있도록 한다.</li><li><code>-p</code>: 실행될 노드에 의해 제어되는 블록 생산자의 계정 이름을 지정한다.<ul><li>예제에서는 <code>eosio</code>가 블록 생산자 계정이며, <code>eosio</code> 계정의 Key는 <code>nodeos</code>의 설정 파일인 <code>~/.local/share/eosio/config/config.ini</code>(Mac OS: <code>~/Library/Application Support/eosio/nodeos/config/config.ini</code>)에서 확인할 수 있다.</li></ul></li><li><code>--plugin</code>: <code>nodeos</code>에서 사용할 플러그인을 지정한다. 여러번 지정할 수 있다.<ul><li>예제에서는 <code>eosio::chain_api_plugin</code>, <code>eosio::history_api_plugin</code> 플러그인을 사용한다.</li></ul></li></ul><p>위와 같이 실행하면 아래와 같이 싱글 노드로 구성된 테스트넷이 실행되고, 블록도 매우 빠른 속도(0.5초)로 계속 생성된다.</p><p><img src="https://i.imgur.com/BJNM5Et.png" alt="Imgur"></p><p>싱글 노드로 구성된 테스트넷에는 아래 그림과 같이 <code>keosd</code>, <code>cleos</code>, <code>nodeos</code> 모두 하나의 호스트 안에서 실행된다.</p><p><img src="https://i.imgur.com/ehc7Jpa.png" alt="Imgur"></p><p><code>nodeos</code>가 실행되면 아래와 같이 <code>~/.local/share/eosio</code>(Mac OS: <code>~/Library/Application Support/eosio</code>) 디렉터리에 테스트넷 관련 데이터 및 설정 파일이 생성된다.</p><p><img src="https://i.imgur.com/dOsfBVI.png" alt="Imgur"></p><p><code>~/.local/share/eosio/nodeos/config/config.ini</code>(Mac OS: <code>~/Library/Application Support/eosio/nodeos/config/config.ini</code>) 파일에 여러가지 네트워크 설정 사항이 담겨 있다.</p><p><code>~/.local/share/eosio/nodeos/data</code>(Mac OS: <code>~/Library/Application Support/eosio/nodeos/data</code>) 디렉터리에는 공유 메모리, 로그 등 EOS 블록체인 관련 여러 런타임 데이터가 저장된다. 데이터 디렉터리의 위치는 <code>nodeos</code> 실행 시 <code>--data-dir</code> 옵션으로 다른 위치를 지정할 수도 있다.</p><p><code>nodeos</code>는 CTRL+C로 종료할 수 있으며 화면은 다음과 같다. #184번 블록까지 생성한 후 종료되었다.</p><p><img src="https://i.imgur.com/pgbzFRE.png" alt="Imgur"></p><p>다시 <code>./nodeos -e -p eosio --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin</code> 명령으로 실행하면 다음과 같이 #185번 블록부터 다시 블록 생성이 이어진다.</p><p><img src="https://i.imgur.com/pbCVcz1.png" alt="Imgur"></p><h2 id="cleos-에서-nodeos-정보-확인"><a href="#cleos-에서-nodeos-정보-확인" class="headerlink" title="cleos 에서 nodeos 정보 확인"></a>cleos 에서 nodeos 정보 확인</h2><p><code>nodeos</code>를 실행한 터미널 말고 다른 새 터미널의 eos 디렉터리에서 아래 명령 실행</p><blockquote><p>./build/programs/cleos/cleos --url <a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a> get info</p></blockquote><p><img src="https://i.imgur.com/99DPIh2.png" alt="Imgur"></p><h2 id="nodeos-종료"><a href="#nodeos-종료" class="headerlink" title="nodeos 종료"></a>nodeos 종료</h2><p><code>CTRL+C</code>로 종료한다. 더 우아한 방법이 있을거라 생각했지만 <code>nodeos --help</code>로 확인해본 결과 종료 옵션은 없는 것 같다. </p><p>계속 켜두어도 되지만 다음 과정인 지갑 만들기 및 Key 연동에서는 <code>nodeos</code>를 사용하지 않으므로 종료해도 무방하다.</p><p>이것으로 <code>nodeos</code> 실행을 마쳤다. 다음에는 <a href="https://homoefficio.github.io/2018/06/06/EOS-지갑-만들기-및-Key-연동/">EOS 지갑 만들기 및 Key 연동</a>에서 지갑을 만들고 Key를 생성해서 연동하는 방법을 알아본다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EOS-Single-Node-Testnet-실행&quot;&gt;&lt;a href=&quot;#EOS-Single-Node-Testnet-실행&quot; class=&quot;headerlink&quot; title=&quot;EOS Single Node Testnet 실행&quot;&gt;&lt;/a&gt;EOS Sing
      
    
    </summary>
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/tags/BlockChain/"/>
    
      <category term="EOS" scheme="http://homoefficio.github.io/tags/EOS/"/>
    
      <category term="블록체인" scheme="http://homoefficio.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="이오스" scheme="http://homoefficio.github.io/tags/%EC%9D%B4%EC%98%A4%EC%8A%A4/"/>
    
      <category term="development" scheme="http://homoefficio.github.io/tags/development/"/>
    
      <category term="개발" scheme="http://homoefficio.github.io/tags/%EA%B0%9C%EB%B0%9C/"/>
    
      <category term="dapp" scheme="http://homoefficio.github.io/tags/dapp/"/>
    
      <category term="디앱" scheme="http://homoefficio.github.io/tags/%EB%94%94%EC%95%B1/"/>
    
      <category term="Testnet" scheme="http://homoefficio.github.io/tags/Testnet/"/>
    
      <category term="테스트넷" scheme="http://homoefficio.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%84%B7/"/>
    
  </entry>
  
  <entry>
    <title>EOS Visual Studio Code 개발 환경 구성</title>
    <link href="http://homoefficio.github.io/2018/06/06/EOS-Visual-Studio-Code-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1/"/>
    <id>http://homoefficio.github.io/2018/06/06/EOS-Visual-Studio-Code-개발-환경-구성/</id>
    <published>2018-06-05T23:31:22.000Z</published>
    <updated>2018-10-13T15:49:56.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EOS-Visual-Studio-Code-개발-환경-구성"><a href="#EOS-Visual-Studio-Code-개발-환경-구성" class="headerlink" title="EOS Visual Studio Code 개발 환경 구성"></a>EOS Visual Studio Code 개발 환경 구성</h1><p><a href="https://infinitexlabs.com/setup-ide-for-eos-development/" target="_blank" rel="noopener">https://infinitexlabs.com/setup-ide-for-eos-development/</a> 를 참고해서 작성한 EOS 개발 환경 구성</p><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><h3 id="다운로드-및-설치"><a href="#다운로드-및-설치" class="headerlink" title="다운로드 및 설치"></a>다운로드 및 설치</h3><p><a href="https://code.visualstudio.com/docs/setup/linux" target="_blank" rel="noopener">https://code.visualstudio.com/docs/setup/linux</a> 참고해서 .deb 파일 다운로드 후 설치</p><h3 id="VS-Code-Extension-설치"><a href="#VS-Code-Extension-설치" class="headerlink" title="VS Code Extension 설치"></a>VS Code Extension 설치</h3><p>아래와 같이 Extension 버튼을 누르고</p><p><img src="https://i.imgur.com/etrHfut.png" alt="Imgur"></p><p>다음 항목을 차례로 설치한다.</p><ul><li><p>C/C++ by MicroSoft</p></li><li><p>CMake by twxs</p></li><li><p>CMake Tools by vector-of-bool</p></li><li><p>WebAssembly Dmitriy Tsvettsikh</p></li></ul><p><img src="https://i.imgur.com/ml1iOWX.png" alt="Imgur"></p><p>Extension은 아래와 같이 <code>~/.vscode</code> 아래에 설치된다.</p><p><img src="https://i.imgur.com/5mhpfwG.png" alt="Imgur"></p><h2 id="EOS-프로젝트-열기"><a href="#EOS-프로젝트-열기" class="headerlink" title="EOS 프로젝트 열기"></a>EOS 프로젝트 열기</h2><p>VS Code에는 IntelliJ나 Eclipse에 익숙한 개발자에게는 살짝 당황스러운 것이 <code>New Project...</code>나 <code>Import...</code> 같은 메뉴가 없다.</p><p>아래 화면과 같이 Explorer 버튼을 누른 후 Open Folder를 클릭해서 EOS 프로젝트 루트 폴더를 지정한다.</p><p><img src="https://i.imgur.com/ZnIGQD8.png" alt="Imgur"></p><p>열고 나면 다음과 같이 파일 변화를 감지하는 watch가 제대로 동작을 할 수 없다고 나온다.</p><p><img src="https://i.imgur.com/VGfTDvh.png" alt="Imgur"></p><p>버튼을 눌러보면 <a href="https://code.visualstudio.com/docs/setup/linux#_visual-studio-code-is-unable-to-watch-for-file-changes-in-this-large-workspace-error-enospc" target="_blank" rel="noopener">여기</a> 로 이동해서 아래와 같은 내용이 표시된다.</p><p><img src="https://i.imgur.com/gcvmYnM.png" alt="Imgur"></p><p>대략 워크스페이스가 너무 많은 파일을 가지고 있는 게 문제라는 얘기인데, 설명에 나온 것처럼 <code>/etc/sysctl.conf</code> 파일을 열어서 아래의 내용을 추가해준다. 524,288개의 파일까지 변경 감지가 가능하다는 설정이다.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs<span class="selector-class">.inotify</span><span class="selector-class">.max_user_watches</span>=<span class="number">524288</span></span><br></pre></td></tr></table></figure><p>파일을 저장하고 <code>sudo sysctl -p</code> 명령을 실행해서 설정 내용을 적용한다.</p><p>아래 화면을 보면 설정 내용을 적용하기 전에는 8192 였고, 설정 후 524288 이 적용되었음을 확인할 수 있다.</p><p><img src="https://i.imgur.com/lAFDUyE.png" alt="Imgur"></p><p>언어 팩 설치 관련 팝업은 아래와 같이 설정 아이콘을 누르고 Don’t Show Again 을 클릭해서 다시 안 보이게 할 수도 있고, 설치해서 한글로 사용할 수도 있다.</p><p><img src="https://i.imgur.com/SQEEum1.png" alt="Imgur"></p><h2 id="작업-편의를-위한-Tasks-작성"><a href="#작업-편의를-위한-Tasks-작성" class="headerlink" title="작업 편의를 위한 Tasks 작성"></a>작업 편의를 위한 Tasks 작성</h2><p>일반적인 컴파일, 빌드를 위한 Tasks와 스마트 컨트랙의 ABI를 만들어내는 Tasks를 작성한다.</p><p><code>SHIFT+CTRL+P</code>를 눌러서 Command Palette를 띄우고 <code>Tasks</code>를 입력한 후 <code>Configure Task</code>를 선택한다.</p><p><img src="https://i.imgur.com/KmYnWqz.png" alt="Imgur"></p><p><code>Create tasks.json file from template</code>를 선택한다.</p><p><img src="https://i.imgur.com/KmYnWqz.png" alt="Imgur"></p><p><code>Others</code>를 선택한다.</p><p><img src="https://i.imgur.com/0akpWnP.png" alt="Imgur"></p><p>아래와 같이 <code>.vscode</code> 폴더 아래에 <code>tasks.json</code> 파일 템플릿이 표시된다.</p><p><img src="https://i.imgur.com/B41aoV5.png" alt="Imgur"></p><p><code>tasks.json</code> 파일 내용을 다음과 같이 수정한다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"reveal"</span>: <span class="string">"always"</span>,</span><br><span class="line">    <span class="attr">"options"</span>: &#123;</span><br><span class="line">        <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"CMake"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"sh $&#123;workspaceRoot&#125;/.vscode/scripts/compile.sh"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"Build"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"sh $&#123;workspaceRoot&#125;/.vscode/scripts/build.sh"</span>            </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"Generate ABI"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"sh $&#123;workspaceRoot&#125;/.vscode/scripts/generate.sh $&#123;fileDirname&#125; $&#123;fileBasenameNoExtension&#125;"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 Task에 해당하는 셸 파일을 작성한다.</p><h3 id="compile-sh"><a href="#compile-sh" class="headerlink" title="compile.sh"></a>compile.sh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 필요한 모든 빌드 파일 생성</span></span><br><span class="line">cmake -G <span class="string">'Unix Makefiles'</span> -DCMAKE_BUILD_TYPE=Debug ..</span><br></pre></td></tr></table></figure><h3 id="build-sh"><a href="#build-sh" class="headerlink" title="build.sh"></a>build.sh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 필요한 모든 빌드 파일 생성</span></span><br><span class="line">cmake -G <span class="string">'Unix Makefiles'</span> -DCMAKE_BUILD_TYPE=Debug ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 빌드</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="generate-sh"><a href="#generate-sh" class="headerlink" title="generate.sh"></a>generate.sh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Current working directory -"</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">eosiocpp -g <span class="variable">$2</span>.abi <span class="variable">$2</span>.cpp</span><br></pre></td></tr></table></figure><h2 id="Tasks를-위한-단축키-설정"><a href="#Tasks를-위한-단축키-설정" class="headerlink" title="Tasks를 위한 단축키 설정"></a>Tasks를 위한 단축키 설정</h2><p><code>compile</code>, <code>build</code>, <code>generate</code> task를 편리하게 실행할 수 있는 단축키를 등록한다. </p><p><code>File &gt; Preferences &gt; Keyboard Shortcuts</code> 클릭</p><p><img src="https://i.imgur.com/UdBaQzE.png" alt="Imgur"></p><p><code>keybindings.json</code> 클릭</p><p><img src="https://i.imgur.com/VEluHdM.png" alt="Imgur"></p><p>아래와 같이 단축키를 등록한다. 기존의 단축키와 충돌만 나지 않는다면 취향에 맞게 다른 키를 등록할 수도 있다. </p><p><img src="https://i.imgur.com/aO5SviF.png" alt="Imgur"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EOS-Visual-Studio-Code-개발-환경-구성&quot;&gt;&lt;a href=&quot;#EOS-Visual-Studio-Code-개발-환경-구성&quot; class=&quot;headerlink&quot; title=&quot;EOS Visual Studio Code 개발 환경 구
      
    
    </summary>
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/tags/BlockChain/"/>
    
      <category term="EOS" scheme="http://homoefficio.github.io/tags/EOS/"/>
    
      <category term="블록체인" scheme="http://homoefficio.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="이오스" scheme="http://homoefficio.github.io/tags/%EC%9D%B4%EC%98%A4%EC%8A%A4/"/>
    
      <category term="development" scheme="http://homoefficio.github.io/tags/development/"/>
    
      <category term="개발" scheme="http://homoefficio.github.io/tags/%EA%B0%9C%EB%B0%9C/"/>
    
      <category term="dapp" scheme="http://homoefficio.github.io/tags/dapp/"/>
    
      <category term="디앱" scheme="http://homoefficio.github.io/tags/%EB%94%94%EC%95%B1/"/>
    
      <category term="Visual Studio Code" scheme="http://homoefficio.github.io/tags/Visual-Studio-Code/"/>
    
      <category term="vscode" scheme="http://homoefficio.github.io/tags/vscode/"/>
    
      <category term="IDE" scheme="http://homoefficio.github.io/tags/IDE/"/>
    
      <category term="개발 환경" scheme="http://homoefficio.github.io/tags/%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD/"/>
    
      <category term="비주얼 스튜디오 코드" scheme="http://homoefficio.github.io/tags/%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4-%EC%BD%94%EB%93%9C/"/>
    
  </entry>
  
  <entry>
    <title>EOS 소스 구성, 빌드 및 테스트</title>
    <link href="http://homoefficio.github.io/2018/06/06/EOS-%EC%86%8C%EC%8A%A4-%EA%B5%AC%EC%84%B1-%EB%B9%8C%EB%93%9C-%EB%B0%8F-%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    <id>http://homoefficio.github.io/2018/06/06/EOS-소스-구성-빌드-및-테스트/</id>
    <published>2018-06-05T23:28:37.000Z</published>
    <updated>2018-10-13T15:49:56.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EOS-소스-구성-빌드-및-테스트"><a href="#EOS-소스-구성-빌드-및-테스트" class="headerlink" title="EOS 소스 구성, 빌드 및 테스트"></a>EOS 소스 구성, 빌드 및 테스트</h1><p><a href="https://github.com/EOSIO/eos/releases/tag/v1.0.0" target="_blank" rel="noopener">EOSIO 1.0.0</a>이 출시되었다. </p><p>공식 문서인 <a href="https://github.com/EOSIO/eos/wiki/Local-Environment" target="_blank" rel="noopener">https://github.com/EOSIO/eos/wiki/Local-Environment</a> 를 기준으로 약간의 커스터마이징과 과도한 친절함을 가미했다. </p><p>참고로 이 글은 EOSIO 1.0.0의 바로 앞 버전인 <a href="https://github.com/EOSIO/eos/releases/tag/dawn-v4.2.0" target="_blank" rel="noopener">EOSIO Dawn 4.2</a>를 기준으로 작성되었으나 EOSIO 1.0.0 에서도 그대로 적용할 수 있다. <em>EOS는 버전업이 상당히 잦다. 내용 일부는 버전업에 맞춰 계속 업데이트 한다.</em></p><h2 id="EOSIO-아키텍처"><a href="#EOSIO-아키텍처" class="headerlink" title="EOSIO 아키텍처"></a>EOSIO 아키텍처</h2><p>EOSIO는 여러개의 컴포넌트로 구성되어 있다. 가장 중요한 3가지는 다음과 같다.</p><ul><li><code>nodeos</code>: 서버 사이드 블록체인 노드</li><li><code>cleos</code>: 블록체인과의 상호작용 및 지갑 관리 컴포넌트인 <code>keosd</code>에 대한 CLI(명령행 인터페이스)</li><li><code>keosd</code>: EOSIO 지갑 관리 컴포넌트</li></ul><p>위 3가지 컴포넌트의 관계는 다음 그림과 같다.</p><p><img src="https://i.imgur.com/nnJYbmt.png" alt="Imgur"></p><h2 id="사전-조건"><a href="#사전-조건" class="headerlink" title="사전 조건"></a>사전 조건</h2><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>공식 문서에 아래와 같이 안내 되어 있다. 이 글은 Linux Mint 18.3에서 빌드하고 작성했다.</p><ol><li>Amazon 2017.09 and higher.</li><li>Centos 7.</li><li>Fedora 25 and higher (Fedora 27 recommended).</li><li>Mint 18.</li><li>Ubuntu 16.04 (Ubuntu 16.10 recommended).</li><li>MacOS Darwin 10.12 and higher (MacOS 10.13.x recommended).</li></ol><h3 id="용량"><a href="#용량" class="headerlink" title="용량"></a>용량</h3><ul><li>RAM: 8G 이상</li><li>Disk: 20G 이상</li></ul><h2 id="소스-가져오기"><a href="#소스-가져오기" class="headerlink" title="소스 가져오기"></a>소스 가져오기</h2><p>문서에는 EOSIO의 리포지토리를 직접 clone하도록 안내하고 있지만, Pull Request도 보내면서 개발하려면 각자 fork 뜬 리포지토리를 clone하는 것이 좋다.</p><p>각자 fork 뜬 리포지토리의 URL을 <code>https://github.com/YOUR_USERNAME/eos</code>라고 하면, 다음과 같이 clone 하면 된다.</p><blockquote><p>$ git clone <a href="https://github.com/YOUR_USERNAME/eos" target="_blank" rel="noopener">https://github.com/YOUR_USERNAME/eos</a> --recursive</p></blockquote><h2 id="빌드"><a href="#빌드" class="headerlink" title="빌드"></a>빌드</h2><p>EOSIO 에서 제공하는 빌드 스크립트를 실행하면 된다.</p><blockquote><p>$ cd eos</p><p>$ ./eosio_build.sh</p></blockquote><h3 id="자잘한-버그-수정"><a href="#자잘한-버그-수정" class="headerlink" title="자잘한 버그 수정"></a>자잘한 버그 수정</h3><blockquote><p>아래 기술한 빌드 스크립트 에러는 이미 Pull Request가 받아들여져서 현재 릴리스 버전인 EOSIO 1.0.1 에서는 발생하지 않으나, 참고로 내용만 남겨둔다.</p></blockquote><p>그런데 우분투 용 빌드 스크립트에는 의존 관계 구성 관련 사소한 버그가 있어서, 빌드 스크립트를 살짝 고치고 Pull Request를 날려두었다.</p><p><a href="https://github.com/EOSIO/eos/pull/2979/files" target="_blank" rel="noopener">https://github.com/EOSIO/eos/pull/2979/files</a></p><p>이 글을 보는 시점에 Pull Request가 반영되어있다면 아래 내용은 무시하고 다음 단원으로 건너뛰면 된다.</p><p>원본 그대로 실행하면 먼저 다음과 같이 라이브러리를 설치해야 한다는 안내가 나온다. </p><p><img src="https://i.imgur.com/FdCnNY9.png" alt="Imgur"></p><p>메시지가 살짝 깨져 나오지만 일단 넘어가고, 1 을 입력하고 엔터를 치면 설치가 안 되고 다음과 같은 에러가 난다.</p><p><img src="https://i.imgur.com/9EyuWR0.png" alt="Imgur"></p><p>위의 Pull Request 링크를 참고해서 <code>scripts/eosio_build_ubuntu.sh</code>파일을 수정하고 다시 <code>./eosio_build.sh</code>를 실행해서, 라이브러리 설치 문의 시 1을 입력하고 엔터를 치면 다음과 같이 라이브러리 설치가 정상적으로 진행된다.</p><p><img src="https://i.imgur.com/uI88CPW.png" alt="Imgur"></p><h2 id="기다림"><a href="#기다림" class="headerlink" title="기다림"></a>기다림</h2><p>라이브러리 설치 후 Boost, mongoDB, LLVM 등도 빌드하는데 넉넉 잡아 120분 정도 소요되었다. 느긋한 기다림이 필요하다. 생산 되는 로그량도 20,000라인을 넘는다.</p><p>몇 가지 화면 캡처를 떠놨으니 미리 구경해보자.</p><h3 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h3><p>별 문제없이 설치된다.</p><p><img src="https://i.imgur.com/QS1BX2K.png" alt="Imgur"></p><h3 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h3><p>별 문제없이 설치된다.</p><p><img src="https://i.imgur.com/TgsjIC5.png" alt="Imgur"></p><p><img src="https://i.imgur.com/KhhsDyP.png" alt="Imgur"></p><p><img src="https://i.imgur.com/AvnGEG0.png" alt="Imgur"></p><h3 id="secp256k1-zkp"><a href="#secp256k1-zkp" class="headerlink" title="secp256k1-zkp"></a>secp256k1-zkp</h3><p>mongoDB 설치까지 완료된 후 지루할만 하니 에러가 나준다(이것도 Pull Request가 받아들여져서 더는 발생하지 않을 것이다).</p><p><img src="https://i.imgur.com/HqkYJ7q.png" alt="Imgur"></p><p><code>aclocal</code>이 없다는 얘긴데 <code>automake</code>를 설치하면 해결된다.</p><blockquote><p>$ sudo apt install automake</p></blockquote><p><img src="https://i.imgur.com/Dy1kTfc.png" alt="Imgur"></p><p><code>automake</code> 설치 완료 되면 다시 <code>./eosio_build.sh</code>를 실행한다.</p><p><img src="https://i.imgur.com/tkyTrmz.png" alt="Imgur"></p><p>아까 받아둔 파일이 있어서 문제라고 하니 개뿐하게 지워주고, 다시 <code>./eosio_build.sh</code>를 실행한다.</p><p><img src="https://i.imgur.com/QBGDIzg.png" alt="Imgur"></p><h3 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h3><p>이제 secp256k1-zkp도 깔끔하게 설치되고 다음 단계인 LLVM으로 넘어간다. LLVM은 별 문제없이 설치된다.</p><p><img src="https://i.imgur.com/KOsUI6Q.png" alt="Imgur"></p><p><img src="https://i.imgur.com/zICvgid.png" alt="Imgur"></p><h3 id="EOSIO"><a href="#EOSIO" class="headerlink" title="EOSIO"></a>EOSIO</h3><p>이제 드디어 EOSIO 설치로 넘어간다. EOSIO는 별 문제없이 설치된다.</p><p><img src="https://i.imgur.com/wcPRLJl.png" alt="Imgur"></p><p><img src="https://i.imgur.com/G4bcK1s.png" alt="Imgur"></p><p>드디어 빌드가 완성 되었다. 총 90분 정도 걸렸다고 나오는데, 중간에 오류 나기 전에 설치되는 것들까지 감안하면 CPU i5-2500 3.3GHz, RAM 8G 정도로 넉넉잡아 2시간은 걸린 것 같다.</p><h2 id="테스트"><a href="#테스트" class="headerlink" title="테스트"></a>테스트</h2><p>위 빌드 결과에 안내해준 대로 테스트를 수행해보자.</p><blockquote><p>export PATH=${HOME}/opt/mongodb/bin:$PATH</p><p>/home/hanmomhanda/opt/mongodb/bin/mongod -f /home/hanmomhanda/opt/mongodb/mongod.conf &amp;</p><p>cd /home/hanmomhanda/gitRepo/crypto/eos/build</p><p>make test</p></blockquote><p><img src="https://i.imgur.com/EVWbJK4.png" alt="Imgur"></p><p><img src="https://i.imgur.com/SQh7tA0.png" alt="Imgur"></p><p>테스트도 시간은 10여분 정도 걸렸지만 문제없이 모두 통과한다.</p><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p><code>/eos/build</code> 디렉터리에서 <code>sudo make install</code>을 실행해서 설치하면 실행 파일이 v1.1.0 부터는 <code>/usr/local/eosio/bin</code>에 설치된다(1.0.#에서는 <code>/usr/local/bin</code>에 설치됐었다). 따라서, <code>sudo update-alternatives --install /usr/local/bin/nodeos nodeos /usr/local/eosio/bin/nodeos 1</code>와 같이 해줘야 PATH 설정 없이도 편리하게 사용할 수 있다.</p><p><img src="https://i.imgur.com/jgB2MUx.png" alt="Imgur"></p><p><img src="https://i.imgur.com/lu1eUF2.png" alt="Imgur"></p><p><img src="https://i.imgur.com/ljgjYaO.png" alt="Imgur"></p><h2 id="원본-리포지토리-upstream-와-Fork-리포지토리-Sync"><a href="#원본-리포지토리-upstream-와-Fork-리포지토리-Sync" class="headerlink" title="원본 리포지토리(upstream)와 Fork 리포지토리 Sync"></a>원본 리포지토리(upstream)와 Fork 리포지토리 Sync</h2><h3 id="upstream-remote-추가"><a href="#upstream-remote-추가" class="headerlink" title="upstream remote 추가"></a>upstream remote 추가</h3><p><a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/" target="_blank" rel="noopener">https://help.github.com/articles/configuring-a-remote-for-a-fork/</a> 를 참고해서 다음을 실행한다.</p><ol><li><p>현재 remote 확인</p><blockquote><p>$ git remote -v</p></blockquote> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  https:<span class="regexp">//gi</span>thub.com<span class="regexp">/YOUR_USERNAME/</span>eos.git (fetch)</span><br><span class="line">origin  https:<span class="regexp">//gi</span>thub.com<span class="regexp">/YOUR_USERNAME/</span>eos.git (push)</span><br></pre></td></tr></table></figure></li><li><p>원본 리포지토리를 가리키는 upstream 추가</p><blockquote><p>$ git remote add upstream <a href="https://github.com/EOSIO/eos.git" target="_blank" rel="noopener">https://github.com/EOSIO/eos.git</a></p></blockquote></li><li><p>upstream 확인</p><blockquote><p>$ git remote -v</p></blockquote> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">origin    https:<span class="regexp">//gi</span>thub.com<span class="regexp">/YOUR_USERNAME/</span>eos.git (fetch)</span><br><span class="line">origin    https:<span class="regexp">//gi</span>thub.com<span class="regexp">/YOUR_USERNAME/</span>eos.git (push)</span><br><span class="line">upstream  https:<span class="regexp">//gi</span>thub.com<span class="regexp">/EOSIO/</span>eos.git (fetch)</span><br><span class="line">upstream  https:<span class="regexp">//gi</span>thub.com<span class="regexp">/EOSIO/</span>eos.git (push)</span><br></pre></td></tr></table></figure></li></ol><h3 id="원본-리포지토리와-Sync"><a href="#원본-리포지토리와-Sync" class="headerlink" title="원본 리포지토리와 Sync"></a>원본 리포지토리와 Sync</h3><p>EOSIO 프로젝트가 진행되면서 버전이 올라가면 로컬 개발 환경의 버전도 맞춰줘야 한다.</p><p>그냥 일반적인 remote 리포지토리와 Sync하는 것과 다르지 않다.</p><p><a href="https://help.github.com/articles/syncing-a-fork/" target="_blank" rel="noopener">https://help.github.com/articles/syncing-a-fork/</a> 를 참고하되, <code>git merge</code> 뿐아니라 <code>git rebase</code>도 물론 쓸 수 있다.</p><p>로컬의 master 브랜치에서 다음과 같이 <code>git fetch upstream</code>으로 EOSIO 의 최신 내용을 가져온다.</p><blockquote><p>git fetch upstream</p></blockquote><p><img src="https://i.imgur.com/LNdlV8e.png" alt="Imgur"></p><p>rebase로 EOSIO의 최신 버전을 베이스로 설정한다(merge도 가능).</p><blockquote><p>git rebase upstream/master</p></blockquote><p><img src="https://i.imgur.com/iKwaDpp.png" alt="Imgur"></p><p>다음 명령으로 submodule도 업데이트한다.</p><blockquote><p>git submodule update --init --recursive</p></blockquote><p><img src="https://i.imgur.com/HMxnI2o.png" alt="Imgur"></p><p>추적하지 않는 파일이라고 표시된 파일은 IDE(Clion)과 테스트 설정 파일로 무시하거나 <code>.gitignore</code>에 추가해서 버전관리 대상에서 제외하면 된다.</p><h3 id="Fork-리포지토리-Sync"><a href="#Fork-리포지토리-Sync" class="headerlink" title="Fork 리포지토리 Sync"></a>Fork 리포지토리 Sync</h3><p>원본 리포지토리와 Sync를 완료한 로컬 리포지토리에서 다음 명령으로 Fork 리포지토리로 강제 푸쉬를 날리면 된다.</p><blockquote><p>git push -f origin master</p></blockquote><h2 id="새-버전으로-다시-빌드"><a href="#새-버전으로-다시-빌드" class="headerlink" title="새 버전으로 다시 빌드"></a>새 버전으로 다시 빌드</h2><p>빌드 스크립트로 새 버전을 다시 빌드한다.</p><blockquote><p>./eosio_build.sh</p></blockquote><p>boost 등 의존 라이브러리 버전이 변경된 경우 재설치하므로 20분 가량 소요되며, boost 버전 관련 다음과 같은 에러가 발생한다(발생하지 않으면 boost 버전 변경 작업 불필요).</p><p><img src="https://i.imgur.com/e5ML3FO.png" alt="Imgur"></p><p><code>~/.bashrc</code>에 지정해둔 boost 관련 버전을 1.67로 변경해준다.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">BOOST_ROOT</span>=~/opt/boost_1_67_0</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">BOOST_INCLUDEDIR</span>=~/opt/boost_1_67_0/include</span><br></pre></td></tr></table></figure><p>이전 버전의 빌드 캐시가 남아있는 build 디렉터리를 삭제하고 다시 빌드 스크립트를 실행하면 약 15분 후 빌드가 성공적으로 마무리 된다.</p><blockquote><p>rm -rf build/</p><p>./eosio_build.sh</p></blockquote><p><img src="https://i.imgur.com/Lz3OG75.png" alt="Imgur"></p><p>빌드 후 테스트 및 설치는 앞에서 서술한 테스트 과정을 그대로 반복하면 된다.</p><p>이것으로 로컬 환경에서 EOSIO 소스를 빌드하는 작업을 마쳤다. 다음 <a href="https://homoefficio.github.io/2018/06/06/EOS-Single-Node-Testnet-실행/">EOS Single Node Testnet 실행</a>에서 빌드 결과물로 단일 노드 EOS 테스트넷을 실행해보자.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EOS-소스-구성-빌드-및-테스트&quot;&gt;&lt;a href=&quot;#EOS-소스-구성-빌드-및-테스트&quot; class=&quot;headerlink&quot; title=&quot;EOS 소스 구성, 빌드 및 테스트&quot;&gt;&lt;/a&gt;EOS 소스 구성, 빌드 및 테스트&lt;/h1&gt;&lt;p&gt;&lt;a h
      
    
    </summary>
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/tags/BlockChain/"/>
    
      <category term="EOS" scheme="http://homoefficio.github.io/tags/EOS/"/>
    
      <category term="블록체인" scheme="http://homoefficio.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="이오스" scheme="http://homoefficio.github.io/tags/%EC%9D%B4%EC%98%A4%EC%8A%A4/"/>
    
      <category term="development" scheme="http://homoefficio.github.io/tags/development/"/>
    
      <category term="개발" scheme="http://homoefficio.github.io/tags/%EA%B0%9C%EB%B0%9C/"/>
    
      <category term="dapp" scheme="http://homoefficio.github.io/tags/dapp/"/>
    
      <category term="디앱" scheme="http://homoefficio.github.io/tags/%EB%94%94%EC%95%B1/"/>
    
      <category term="개발 환경" scheme="http://homoefficio.github.io/tags/%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD/"/>
    
  </entry>
  
  <entry>
    <title>블록체인 한 번에 이해하기</title>
    <link href="http://homoefficio.github.io/2017/11/19/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%95%9C-%EB%B2%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2017/11/19/블록체인-한-번에-이해하기/</id>
    <published>2017-11-19T04:07:38.000Z</published>
    <updated>2018-10-13T15:49:56.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.imaso.co.kr/archives/248" target="_blank" rel="noopener">마이크로소프트웨어 2017년 10월호</a>에 기고한 ‘가볍게 읽어 보는 블록 체인 이야기’를 토대로 작성한 글입니다.</p></blockquote><blockquote><p>전편 <a href="http://homoefficio.github.io/2016/01/23/BlockChain-기초-개념/">http://homoefficio.github.io/2016/01/23/BlockChain-기초-개념/</a> 에서 예고했던 후속편이기도 합니다.</p></blockquote><blockquote><p>기부</p><ul><li>Bitcoin: 1QofbPJxE9b39SrhCLhCWGsBj8cv299qd</li><li>Ethereum: 0x4d8029ceace5ef7369843d2ee6c11ed39561bddc</li></ul></blockquote><h1 id="블록체인-한-번에-이해하기"><a href="#블록체인-한-번에-이해하기" class="headerlink" title="블록체인 한 번에 이해하기"></a>블록체인 한 번에 이해하기</h1><p>2017년도 벌써 3/4가 지나갔다. 올 한해를 정리해보기엔 좀 이른 시간이지만, 그래도 이 시점에서 중간 점검 차 한 번 짚어보자. 소프트웨어 업계에서 올해 1~9월 사이에 일어났던 많은 일 들 가운데 가장 큰 이슈로 무엇을 꼽을 수 있을까?</p><p>여러 이슈가 있겠지만, 필자의 짧은 생각으로는 비트코인에 대한 관심의 폭증과 그에 따른 암호화 화폐 시장의 급등락과 ICO(Initial Coin Offering)를 꼽고 싶다.</p><p><img src="https://i.imgur.com/PA4MRZ0.png" alt="Imgur"></p><p><img src="https://i.imgur.com/QitEtsa.png" alt="Imgur"></p><p><img src="http://i.imgur.com/uMx3ujw.png" alt="Imgur"></p><p>주변에서 몇 억을 벌었다는 이야기도 심심치 않게 들을 수 있고, 그에 못지 않게 많은 돈을 잃었다는 이야기도 들을 수 있다. 길게 볼 것 없이 올해 초 대비만 하더라도 변동성이 크긴 했지만 비트코인과 기타 암호화 화폐의 가격이 급등한 것은 사실이다. </p><p>그래서 거품이다, 17세기 유럽의 튤립 광풍과 다를게 없다 등의 이야기도 많이 들을 수 있다. 분명 가격으로만 보면 틀린 말이 아닐 수도 있다. 게다가 개발자가 아닌 일반인의 관점에서 보면 아무래도 기술적인 내용은 이해하기 어렵고, 가격 급등락에 의한 여러 에피소드는 이해하기 쉬울 테니, 가격에 대한 면이 부각되는 것은 어쩔 수 없는 일이기는 하다.</p><p>하지만 마이크로소프트웨어라는 이 잡지를 보고 있는 우리는 소프트웨어를 다루는 개발자들이다. 그리고 비트코인도 당연하지만 소프트웨어다. 그럼에도 불구하고, 우리나라에서는 개발자들마저 비트코인을 바라보는 관점이 일반인의 관점과 크게 다르지 않은 것 같다. </p><p>그래서 이번 기회에 개발자답게, 일반인들보다 조금 더 깊게 탐험해 보고, 어떤 의미를 가지고 있는지 알아보자.</p><h2 id="비트코인과-블록-체인"><a href="#비트코인과-블록-체인" class="headerlink" title="비트코인과 블록 체인"></a>비트코인과 블록 체인</h2><p>제목은 블록 체인 이야기라고 써놓고, 서두에서는 비트코인 얘기만 했다. 비트코인과 블록 체인이 무엇인지 구별하는 것이 좋겠다는 의도에서 일부러 그렇게 기술했는데, 다음과 같이 구별할 수 있다.</p><blockquote><p>블록 체인은 비트코인의 바탕이 되는 ‘체계’이며,</p><p>비트코인은 블록 체인을 ‘화폐’에 응용한 결과물이다.</p></blockquote><p><strong>블록 체인이 바탕</strong>이고, <strong>비트코인은 블록 체인 바탕위에서 구현된 하나의 서비스 또는 상품</strong>이라고 할 수 있다. 그래서 <strong>블록 체인은 비트코인 뿐아니라 다른 코인의 바탕이 될 수도 있고 실제로도 그렇다. 또한 블록 체인은 코인 뿐아니라 다른 서비스나 상품의 바탕이 될 수도 있다</strong>.</p><p>재미있는 것은 블록 체인이 비트코인의 바탕이 되는 체계이지만, 블록 체인이 만들어지고 비트코인이 만들어진 것이 아니라 비트코인을 만들기 위해 고민하던 중에 블록 체인이라는 기술이 탄생했다는 점이다.</p><p>이제부터 블록 체인이 어떻게 비트코인이라는 화폐의 바탕이 되는 체계가 될 수 있는지 알아보자. 먼저 화폐가 무엇인지 짧게 되새겨 보자.</p><h2 id="화폐는-믿음이다"><a href="#화폐는-믿음이다" class="headerlink" title="화폐는 믿음이다"></a>화폐는 믿음이다</h2><p>현대 사회에서 화폐란 무엇일까? 너무 모호한 것 같으니 질문을 바꿔보자. 현대 사회에서 화폐의 ‘실체’란 무엇일까? </p><p>과거에는 금이나 은 등 실제 실물이 화폐의 역할을 담당했지만, 점차 그 실물에 대한 교환 증서가 화폐의 역할을 담당하게 되었고, 1971년의 닉슨 쇼크 이후에는 사실상 그 실물(금)에 대한 교환도 보장해 주지 않는 불태환 화폐가 되었고, 2008년 금융 위기 이후에는 양적 완화라는 미명 하에 막대한 양의 화폐를 찍어내기도 했다. 그럼에도 불구하고 여전히 우리는 그 화폐를 가지고 큰 문제 없이 살아가고 있다. 어째서 이런 일이 가능할까?</p><blockquote><p>화폐는 ‘믿음’이다.</p></blockquote><p>그렇다. 사실 우리는 화폐를 믿고 있다. <strong>화폐의 실체는 바로 믿음</strong>이다. 금으로 교환해준다는 보장은 사라졌지만, 화폐로 여전히 치킨을 먹고 맥주를 마실 수 있다고 모두가 믿고 있다. 화폐는 모두의 ‘신뢰’를 받고 있는 것이다. 비트코인이 가상 화폐, 디지털 화폐 또는 암호화 화폐처럼 화폐라는 용어를 달고 있는 이유도 ‘신뢰’할 만한 대상이 될 수 있기 때문이다. 그 <strong>신뢰의 원천이 바로 블록 체인</strong>이다.</p><p>그럼 블록 체인이 어떻게 신뢰의 원천이 될 수 있는지 차례차례 알아보자.</p><h2 id="분산-공개-장부"><a href="#분산-공개-장부" class="headerlink" title="분산 공개 장부"></a>분산 공개 장부</h2><p>A가 B에게 만원을 보내는 상황을 생각해보자. A가 은행 사이트에 접속해서 로그인하고, 잔액을 확인하고, B의 계좌 정보를 입력한 후에, 공인인증서나 OTP 등의 비밀번호를 입력하고 확인 버튼을 누르면, A의 잔액에서 만원이 차감되고, B의 잔액에 만원이 더해진다. </p><p>개인의 재산이 오가는 이 송금 과정은 매우 중요하다. 그래서 송금 거래에 필요한 모든 확인 과정은 은행에서 수행되며, 그 기록도 은행에 저장되고 외부로는 공개되지 않는다. </p><p>그래서 송금에 대해 우리가 믿는 곳은 은행 하나다. 송금 과정에 있어서의 모든 것이 은행 하나에 집중되어 있다. 이는 바꿔 말하면 <strong>은행이 바로 단일 실패 지점</strong>(Single Point of Failure)이라는 말이다. 즉, 거래 은행의 서버가 정상적으로 동작하지 않거나, 은행의 기록이 사라지게 되면 우리는 재산을 잃게 된다.</p><p>컴퓨팅 분야에서 이런 단일 실패 지점 문제를 해결하는 보편적인 방법은 고가용성 처리, 쉽게 말해 다중화다. 2중, 3중으로 복제나 분산처리를 해서 단일 실패 지점을 없애는 전략을 취한다. 은행 시스템도 이런 다중화 처리가 되어 있으므로 앞에서 말한 어처구니 없는 불상사는 쉽게 일어나지 않는다. 소프트웨어 뿐 아니라 보안 담당 직원 배치, 보안 담당 장비 도입 등으로 더 한층 위험을 낮춘다. 하지만 이런 조치를 위해서는 많은 비용이 필요하다. </p><p>블록 체인은 이 문제를 완전히 다른 각도에서 바라본다(각주: 설명의 단순화를 위해 이후로 퍼블릭 블록 체인만을 대상으로 한다). 즉, 거래 정보를 감추지 않고 모두에게 공개하고, 누구나 거래 정보를 생성할 수 있으며, 거래 정보를 모두에게 복사해서 사본을 저장하고 그 사본끼리 동기화시킨다. 쉽게 말해 <strong>2중화, 3중화 정도가 아니라 수천중화, 수만중화 처리를 해서 기록이 사라지는 일을 원천적으로 막아버린다</strong>. 그래서 블록 체인을 거대한 분산 공개 장부라고 부르기도 한다.</p><blockquote><p>블록 체인은 거대한 분산 공개 장부다.</p></blockquote><p>이렇게 수천 수만의 분산 처리를 통해 기록의 멸실은 막을 수 있지만, 이것만으로는 멸실만큼이나 위험한 기록의 위/변조까지 막을 수는 없다. 블록 체인은 이 문제를 암호학의 도움을 받아서 해결한다.</p><h2 id="디지털-서명"><a href="#디지털-서명" class="headerlink" title="디지털 서명"></a>디지털 서명</h2><p>개발자라면 디지털 서명에 대해 희미하게라도 알고 있겠지만, 블록 체인을 얘기할 때 빼놓을 수 없는 중요한 부분이므로 다시 한 번 짚고 넘어가자.</p><p>디지털 서명은 비대칭키와 해쉬 함수를 이용해서 다음과 같은 방식으로 데이터의 진위 여부를 확인할 수 있게 해준다.</p><p><img src="http://i.imgur.com/tQT0d3D.png" alt="Imgur"></p><p><strong>블록 체인에 담겨 있는 모든 거래 정보에는 이렇게 디지털 서명이 포함</strong>되어 있어서 <strong>거래 정보가 진본임을 신뢰</strong>할 수 있다.</p><h2 id="블록이란"><a href="#블록이란" class="headerlink" title="블록이란?"></a>블록이란?</h2><p>자 이제부터 진짜 블록 체인의 내부로 들어가 볼 차례다. 블록 체인이라는 체인을 이루는 원소인 블록은 무엇일까? </p><blockquote><p>블록은 유효한 거래 정보의 묶음이다.</p></blockquote><p>“A가 B에게 100원을 송금한다.”와 같은 것이 하나의 거래이며, <strong>하나의 블록에는 여러 개의 거래가 포함</strong>된다. 블록에 대해 더 구체적으로 이해하려면 실제 구현체를 살펴보는 것이 효율적이다. 그래서 블록 체인의 최초 구현체인 비트코인을 기준으로 블록과 블록 체인에 대해 살펴볼 것이다. 구현체마다 세부적인 방식은 다를 수도 있지만 큰 줄기는 거의 같다.</p><p>비트코인의 블록 하나에는 평균 약 1,800개의 거래 정보가 포함될 수 있으며, 블록 하나의 물리적인 크기는 평균 0.98Mbyte이다(출처: <a href="https://blockchain.info/charts)" target="_blank" rel="noopener">https://blockchain.info/charts)</a>. 블록은 블록 헤더와 거래 정보, 기타 정보로 구성된다.</p><ul><li>블록 헤더는 <code>version</code>, <code>previousblockhash</code>, <code>merklehash</code>, <code>time</code>, <code>bits</code>, <code>nonce</code> 이렇게 6개의 정보로 구성된다.</li><li>거래 정보는 입출금과 관련한 여러가지 정보를 가지고 있다.</li><li>기타 정보는 블록 내에 있는 정보 중에서 블록 헤더와 거래 정보에 해당하지 않는 정보를 말하며, 블록 해쉬 계산에 사용되지 않는다.</li></ul><p>이 중에서 블록 체인의 메커니즘을 이해하는 데 중요한 열쇠가 되는 정보는 <strong>블록 헤더</strong>다.</p><h3 id="블록-헤더"><a href="#블록-헤더" class="headerlink" title="블록 헤더"></a>블록 헤더</h3><p>블록 헤더는 다음의 6가지 정보로 구성된다.</p><ol><li>version : 소프트웨어/프로토콜 버전</li><li>previousblockhash : 블록 체인에서 바로 앞에 위치하는 블록의 블록 해쉬</li><li>merklehash : 개별 거래 정보의 거래 해쉬를 2진 트리 형태로 구성할 때, 트리 루트에 위치하는 해쉬값</li><li>time : 블록이 생성된 시간</li><li>bits : 난이도 조절용 수치</li><li>nonce : 최초 0에서 시작하여 조건을 만족하는 해쉬값을 찾아낼때까지의 1씩 증가하는 계산 회수</li></ol><p>블록 헤더가 중요한 이유는 <strong>블록의 식별자 역할을 하는 블록 해쉬가 이 블록 헤더의 6가지 정보를 입력값으로 해서 구해지기 때문</strong>이다.</p><h3 id="블록-해쉬"><a href="#블록-해쉬" class="headerlink" title="블록 해쉬"></a>블록 해쉬</h3><p>블록의 식별자 역할을 하는 <strong>블록 해쉬는 6가지의 블록 헤더 정보를 입력값으로 하고, 여기에 SHA256 해쉬 함수를 적용해서 계산되는 값</strong>으로, 32바이트의 숫자값이다. <strong>이름은 블록 해쉬이지만 그 값은 블록 전체를 해쉬한 값이 아니라, 블록 헤더를 해쉬한 값</strong>이다.</p><p>지금까지의 내용을 바탕으로 블록 해쉬를 구하는 과정을 그림으로 나타내면 다음과 같다.</p><p><img src="http://i.imgur.com/KFtqafZ.png" alt="Imgur"></p><p>개별 거래 정보는 결국 머클 트리의 해쉬값인 <code>merklehash</code> 값으로 집약된다. 블록 헤더의 6가지 정보 중에서 <code>version</code>, <code>previousblockhash</code>, <code>merklehash</code>, <code>time</code>, <code>bits</code> 이렇게 5가지는 블록 해쉬를 만드는 시점에서 이미 확정되어 변하지 않는 값이다. 하지만 마지막 <code>nonce</code>는 확정되어 있지 않고 새로 구해야 하는 값이다. <strong>이 <code>nonce</code> 값을 구해서 최종적으로 블록 해쉬 값을 구하고, 이 블록 해쉬값을 식별자로 가지는 유효한 블록을 만들어내는 것이 바로 작업 증명(Proof of Work), 흔히 말하는 채굴</strong>이다.</p><p>작업 증명에 대해 알아보기 전에, 이제 블록이 무엇인지 기술적인 수준에서 알게 되었으니 블록이 이어져서 만들어지는 블록 체인도 기술적인 관점에서 정리해보자.</p><h2 id="블록-체인이란"><a href="#블록-체인이란" class="headerlink" title="블록 체인이란?"></a>블록 체인이란?</h2><p>블록 체인은 앞에서는 거대한 분산 공개 장부라고 했는데, 기술적으로는 <strong>블록이 이어져서 만들어진 블록의 집합체</strong>라고 말할 수 있다.</p><p>블록들은 어떻게 이어져 있는걸까? 앞에서 살펴본 블록 헤더의 6가지 정보 중의 하나인 <code>previousblockhash</code> 값은 현재 생성하고 있는 블록 바로 이전에 만들어진 블록의 블록 해쉬값이다. 블록은 바로 앞의 블록 해쉬 값을 포함하는 방식으로 앞의 블록과 이어지게 된다. </p><p><img src="http://i.imgur.com/IHS979r.png" alt="Imgur"></p><p>어디서 많이 본 자료 구조 아닌가? 그렇다. <strong>블록 체인은 사실 링크드 리스트</strong>다.</p><blockquote><p>블록 체인은 블록으로 이루어진 링크드 리스트다.</p></blockquote><p>블록 체인을 기술적인 측면에서도 살펴봤으니 이제 그 내부로 조금 더 깊게 들어가보자.</p><h2 id="블록-체인의-첫번째-핵심-작업-증명"><a href="#블록-체인의-첫번째-핵심-작업-증명" class="headerlink" title="블록 체인의 첫번째 핵심 - 작업 증명"></a>블록 체인의 첫번째 핵심 - 작업 증명</h2><p>자료 구조 관점에서는 링크드 리스트일 뿐인 블록 체인이 신뢰의 원천이 될 수 있는 첫번째 핵심 요소는 <strong>작업 증명(Proof of Work)</strong>이다.</p><p>앞에서 <code>nonce</code>값을 구해서 최종적으로 블록 해쉬값을 구하고, 이 블록 해쉬값을 식별자로 가지는 유효한 블록을 만들어내는 것이 작업 증명이라고 했다. 결국 <code>nonce</code> 값을 구하는 것이 작업 증명의 핵심이다. <code>nonce</code>값을 구하는 방법을 알아보기 전에 먼저 <code>nonce</code>값이란 어떤 값을 의미하는 지 알아야 한다.</p><blockquote><p><code>nonce</code>값은, 이 <code>nonce</code>값을 입력값 중의 하나로 해서 계산되는 블록 해쉬값이 특정 숫자보다 작아지게 하는 값을 말한다.</p></blockquote><p>그럼 이 <code>nonce</code>값은 어떻게 구할 수 있을까? 위의 설명에서 맨 마지막 부분을 떼어보면 <strong>해쉬값이 특정 숫자보다 작아지게 하는 값</strong>이라고 한다. 해쉬 함수의 특성상, 어떤 해쉬값(A라고 하면)을 결과로 나오게 하는 입력값을 찾으려면, A에서 역산을 하는 방식으로는 찾을 수 없고, 결과가 A가 될 때까지 무작위로 입력값을 계속 바꿔가면서 해쉬값을 계산해보면서 찾아낼 수 밖에 없다. </p><p>그렇다면 어떤 블록 해쉬값이 어떤 특정 숫자보다 작아지게 하려면, 블록 해쉬의 입력값을 계속 바꿔가면서 구한 해쉬값이 특정 숫자보다 낮은지 비교하는 작업을 계속 반복하는 수 밖에 없다. </p><p>블록 해쉬의 입력값은 블록 헤더고, 블록 헤더에는 6가지 정보가 담겨 있으며, 이 중에서 5가지는 값이 고정되어 변경할 수 없고, 오직 <code>nonce</code>만 값을 바꿀 수 있다. </p><p>즉, 이 <code>nonce</code>값을 계속 바꿔가면서 계산한 해쉬값이 어떤 특정 숫자보다 작다면, 그 때의 <code>nonce</code>값이 새로 만들어지는 블록의 <code>nonce</code>값으로 확정되고, 특정 숫자 보다 작게 나온 그 해쉬값이 새로 생성되는 블록의 블록 해쉬값으로 최종 확정되며 작업 증명이 끝나게 된다. </p><p>이 과정을 그림과 함께 살펴보자. 아래 그림은 블록해쉬가 <code>000000a84...</code>라는 특정값보다 작게 나오게 하는 <code>nonce</code>값을 구하는 과정을 나타내고 있다.</p><p><img src="http://i.imgur.com/caPbxeH.png" alt="Imgur"></p><p>앞에서 설명한 대로 <code>nonce</code> 외의 모든 항목의 값은 이미 정해져 있다.</p><p><code>nonce</code> 값이 0 일 때의 해쉬를 구해보니 <code>000000a84...</code>보다 큰 <code>fa8cbaeed...</code> 가 나와서 작업 증명에 실패 했다.</p><p>다시 <code>nonce</code>가 1 일 때의 해쉬를 구해보니 <code>932d16e2e...</code> 가 나와서 또 실패.. <code>nonce</code>가 2 일 때의 해쉬, 3 일 때의 해쉬.. 를 계속 반복해서 구하고 실패하다가, <code>nonce</code>가 82,764,351 일 때의 해쉬를 구해보니 드디어 <code>000000a84...</code> 보다 작은 <code>000000a83...</code>이 나와서 작업 증명에 성공했다.</p><p>그렇다면 작업 증명 성공 여부의 기준이 되는  <code>000000a84...</code>라는 값은 어떻게 정해지나? 그 값은 작업 난이도에 의해 결정되는데 이 부분은 핵심은 아니므로 그보다 더 중요한 보상에 대해 알아보자.</p><h3 id="보상"><a href="#보상" class="headerlink" title="보상"></a>보상</h3><p>이렇게 <code>nonce</code> 값을 구하는 채굴 작업에는 엄청나게 많은 횟수의 해쉬 계산이 필요하며 그런 계산을 수행하는 채굴기와 그 채굴기를 돌릴 수 있는 막대한 양의 전기라는 비용이 든다. 그래서 이런 비용에 대한 보상이 없다면 아무도 채굴을 하지 않을 것이다. </p><p>비트코인에서의 <strong>보상은 새로 발행되는 비트코인과 해당 블록에 포함되는 거래의 거래 수수료의 합</strong>이다. 비트코인의 새로운 발행은, 채굴자가 블록을 처음 구성할 때 채굴자의 지갑으로 일정량의 비트코인이 입금되는 거래를 그 블록의 첫 거래(generation transaction)로 추가하는 방식으로 이루어진다. </p><p><img src="http://i.imgur.com/djOnK4M.png" alt="Imgur"></p><p>새로 발행되는 비트코인은 최초에 50BTC에서 시작해서 블록 체인에 21만개의 블록이 추가될 때마다 절반으로 줄어들어 2017년 7월 현재는 블록 당 12.5BTC가 새로 발행되며, 보상의 일부로서 채굴자에게 주어진다.</p><p>거래 수수료는 각 거래 당사자끼리 자율적으로 정할 수 있고, 거래가 블록에 추가되는 우선 순위를 결정하는데 거래 수수료가 입력값으로 사용되기도 한다.</p><blockquote><p>보상은 <code>nonce</code> 값을 찾아내고, 그 결과 새로운 블록을 블록 체인에 추가해서, </p><p>해당 블록에 포함된 모든 거래를 유효한 거래로 확정시켜준 대가라고 할 수 있다.</p></blockquote><h2 id="블록-체인의-두번째-핵심-충돌-해소"><a href="#블록-체인의-두번째-핵심-충돌-해소" class="headerlink" title="블록 체인의 두번째 핵심 - 충돌 해소"></a>블록 체인의 두번째 핵심 - 충돌 해소</h2><p>블록 체인의 첫번째 핵심은 작업 증명이며, 이는 블록 단위에서 처리되는 일이다. 블록 체인의 두번째 핵심은 <strong>충돌 해소</strong>인데, 이는 블록 단위가 아니라 블록 체인 단위에서 처리되는 일이다. 어떤 충돌을 의미하는 것인지 또 왜 해소시켜야 하는지 알려면 블록 체인을 분산 환경에서 바라볼 필요가 있다.</p><h3 id="거래-정보의-전파"><a href="#거래-정보의-전파" class="headerlink" title="거래 정보의 전파"></a>거래 정보의 전파</h3><p>앞에서 블록 체인은 거대한 분산 공개 장부라고 했다. 이 <strong>분산 공개 장부는 여러 개의 노드에 복사</strong>되어 있으며, <strong>여러 개의 노드는 p2p로 연결되어 블록 체인 네트워크를 형성</strong>한다. 그리고 하나의 거래 정보가 발생하면 이 거래 정보는 블록 체인 네트워크에 분산되어 있는 수많은 노드에 전파되어야 한다.</p><p>다음 그림과 같이 사용자 F가 지갑 앱에서 C에게 수수료 0.001BTC와 함께 1.6BTC를 보내면, 지갑 앱은 블록 체인 네트워크 상의 노드 A에 거래 정보를 전송한다. </p><p><strong>거래 정보를 받은 노드 A는 먼저 해당 거래의 유효성을 검증한 후에 그 거래를 아직 블록 생성 작업이 시작되지 않은 후보 블록에 추가하고, 인접한 다른 노드에 그 거래 정보를 전파</strong>한다. </p><p>거래 정보를 전파받은 노드 B도 마찬가지 방식으로 블록 체인 네트워크 상의 다른 노드에게 거래 정보를 전파하며, 이 거래는 결국 블록 체인 네트워크 전체 노드에 전파된다.</p><p><img src="http://i.imgur.com/QPLJbWM.png" alt="Imgur"></p><h3 id="블록의-생성-및-전파"><a href="#블록의-생성-및-전파" class="headerlink" title="블록의 생성 및 전파"></a>블록의 생성 및 전파</h3><p>블록에 거래 정보가 채워지면 노드는 블록을 생성한다. 이때 캐나다에 있던 노드와 호주에 있던 노드는 상당히 멀리 떨어져 있으므로, 각 블록에 담겨 있는 거래의 내용과 순서는 아래와 같이 서로 다를 수 있다.</p><p><img src="http://i.imgur.com/AraOlPF.png" alt="Imgur"></p><p>새로 만들어질 블록은 다음 그림(출처: Mastering Bitcoin - <a href="http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks" target="_blank" rel="noopener">http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks</a>) 과 같이 현재 마지막 블록인 파랑블록(P블록)의 다음에 추가될 예정이다.</p><p><img src="https://i.imgur.com/Tfn6Gu7.png" alt="Imgur"></p><p>이 때 캐나다의 노드와 호주의 노드가 거의 동시에 <code>nonce</code> 값을 찾아서 블록을 성공적으로 생성했다. 캐나다의 노드가 생성한 블록을 빨강블록(A블록)이라 하고, 호주의 노드가 생성한 블록을 초록블록(B블록)이라하면, 생성 후 전파 과정은 다음 그림(출처: Mastering Bitcoin - <a href="http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks" target="_blank" rel="noopener">http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks</a>) 과 같다.</p><p><img src="https://i.imgur.com/6ceiHDs.png" alt="Imgur"></p><p>캐나다 노드의 <strong>인접 노드에서는 전달받은 빨강블록의 블록 해쉬를 다시 계산해서 그 값이 정말로 특정한 숫자보다 작은 올바른 값인지 검증한 후에, 자신이 가지고 있던 파랑블록에 빨강블록을 추가</strong>한다. </p><p>호주 노드에 인접한 노드에서도 마찬가지 방식으로 기존의 파랑노드에 초록노드가 추가된다. 이 방식이 계속되면서 빨강블록과 초록블록은 전 세계에 분산되어 있는 노드에 전파된다.</p><h3 id="블록-체인의-분기"><a href="#블록-체인의-분기" class="headerlink" title="블록 체인의 분기"></a>블록 체인의 분기</h3><p>포르투갈에 있는 노드에는 빨강블록이 먼저 전파된 후에 초록블록이 전파파되었다. 포르투갈 노드에서는 늦게 도착한 초록블록은 무시된다. </p><p>러시아에 있는 노드도 나름 열심히 <code>nonce</code> 값을 구하고 있었으나, 구하기 전에 아쉽게도 초록블록을 먼저 전달받아서 초록블록을 검증한 후 파랑블록 다음에 초록블록을 추가했다. 초록블록에 이을 새로운 블록의 <code>nonce</code>값을 구하기 시작하고, 잠시 후 빨강블록을 전달받았다. 늦게 도착한 빨강블록은 러시아 노드에서는 무시된다. </p><p>이번에는 러시아 노드가 가장 먼저 <code>nonce</code> 값을 구해서 새로 분홍블록(X블록)을 생성하고 초록블록 다음에 분홍블록을 추가한 후에 다음 그림(출처: Mastering Bitcoin - <a href="http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks" target="_blank" rel="noopener">http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks</a>) 과 같이 인접 노드에 전파했다. </p><p><img src="https://i.imgur.com/VCQiHbJ.png" alt="Imgur"></p><p>포르투갈에 있던 노드에는 파랑블록 다음에 빨강블록이 추가되어 있는 상태였는데, 파랑블록, 초록블록에 이어진 새로운 분홍블록을 전달받았다. 포르투갈에 있던 노드에는 다음과 같이 블록 체인의 분기가 발생한다.</p><p><img src="http://i.imgur.com/GOSBL5l.png" alt="Imgur"></p><p>빨강블록과 초록블록의 내용은 서로 다르다. 블록 체인은 신뢰의 원천이 되는 체계라고 했는데, 이렇게 정보가 갈라지는 체계를 믿을 수 있는걸까?</p><h3 id="어느-블록-체인을-믿을-것인가"><a href="#어느-블록-체인을-믿을-것인가" class="headerlink" title="어느 블록 체인을 믿을 것인가?"></a>어느 블록 체인을 믿을 것인가?</h3><p>블록 체인에서는 이렇게 분기가 발생해서 충돌이 일어날 때 어느 블록 체인을 믿을 것인가에 대한 기준이 마련되어 있다. 그렇지 않으면 분산되어 있는 장부 내용의 동기화가 깨지기 때문이다. 그 기준은 다음과 같다. </p><blockquote><p>블록 체인에 분기가 발생하여 충돌하게 될 때는 더 많은 작업 증명이 수행되어 길이가 더 긴 블록을 선택한다.</p></blockquote><p>그래서 포르투갈 노드에 더 긴 블록 체인을 가진 분홍블록이 전파되는 순간, 빨강블록은 파랑블록에서의 연결이 끊어지고 고아가 된다. </p><p><img src="https://i.imgur.com/7fF9iu6.jpg" alt="Imgur"></p><p><strong>블록 생성은 평균 10분이 소요될 정도로 연산량이 큰 작업이며, 따라서 앞에서 발생한 것처럼 A블록과 B블록이 거의 동시에 생성되어 분기가 발생할 가능성은 그리 높지 않다</strong>. 그리고 <strong>길이가 같은 블록 체인이 충돌하더라도 머지 않아 블록 체인의 길이가 달라져서 분기에 의한 충돌이 해소되는 순간이 금방 다가온다</strong>. </p><p>아래의 그림은 길이가 긴 블록 체인에 의해 고아가 되는 블록의 수를 나타내는데, 최근 1년간 대부분 2개 이하, 최대 3개 이내에서 블록 체인의 분기에 의한 충돌이 해소됨을 알 수 있다.</p><p><img src="http://i.imgur.com/9KGZ5oK.png" alt="Imgur"></p><p>하지만 일시적으로나마 이런 분기 상태가 발생할 수 있기 때문에, 실제 거래 상황에서는 보통 어떤 거래가 포함된 블록 이후로 3-5개의 블록이 더 추가된 후에야 그 거래를 최종적으로 유효한 것으로 확정한다. 일시적으로 분기가 발생하더라도 그 이후로 3-5개의 블록이 추가되는 과정에서 분기 상태가 해소되고 결국 하나의 블록 체인만 남기 때문이다.</p><h3 id="고아가-된-A블록에-있던-거래-중-유실되는-거래가-생기지-않을까"><a href="#고아가-된-A블록에-있던-거래-중-유실되는-거래가-생기지-않을까" class="headerlink" title="고아가 된 A블록에 있던 거래 중 유실되는 거래가 생기지 않을까?"></a>고아가 된 A블록에 있던 거래 중 유실되는 거래가 생기지 않을까?</h3><p>빨강블록에 있던 거래 중에서 초록블록에 포함되지 않았던 거래T가 있을 수 있다. 그럼 빨강블록이 고아가 되면 거래T는 결국 유실되는 것이 아닐까하는 의문이 들 수 있다. </p><p>하지만 <strong>유실은 발생하지 않는다</strong>. <strong>거래T는 초록블록에는 포함되지 않았더라도 분홍블록 또는 분홍블록 이후의 블록에 결국에는 포함되게 된다</strong>. 왜냐하면, 분홍블록은 초록블록을 부모로 해서 생성되는데 거래T가 초록블록에 포함되지 않았으므로, 초록블록에 이어 생성되는 분홍블록 또는 분홍블록 이후의 블록에서는 거래T를 아직 블록 체인에 포함되지 않은 다른 거래들과 마찬가지로 취급하며 블록에 추가하기 떄문이다.</p><h3 id="이중-지불-문제"><a href="#이중-지불-문제" class="headerlink" title="이중 지불 문제"></a>이중 지불 문제</h3><p>디지털은 복사가 가능하므로 이중 지불이라는 문제가 항상 따라다닌다. 블록 체인도 예외는 아니다. 예외는 아닌 정도가 아니라 수많은 노드에 복제되는 방식이므로 이중 지불 문제가 반드시 생길 것 같다.</p><p>일단 동일한 기기에 담긴 지갑에서는 이중 지불을 할 수 없다. 예를 들어 하나의 기기에 설치되어 있는 지갑의 잔액이 5만원일 때, 이 지갑에서 5만원을 지불하는 순간 잔액이 0이 되고, 다시 5만원을 지불할 수 없기 때문이다.</p><p>그래서 이중 지불은 보통 물리적으로 떨어진 두 개의 지점에서 생각해 볼 수 있는 문제다. 장부가 복제되어 있으므로 캐나다에서도 내 잔액은 5만원이고, 호주에서도 내 잔액은 5만원이다. 그럼 캐나다에서도 A에게 5만원을 보내고, 이 거래가 아직 도달하지 않은 호주에서도 B에게 5만원을 보내면 어떻게 될까?</p><p>시작할 때는 멀리 떨어진 두 곳에서 이중 지불이 실행 되었지만, 두 거래는 블록 체인 네트워크를 타고 전파되다가 어디에선가 반드시 만나게 되어있다. 그 만나는 지점에서는 두 거래 사이에 반드시 선후 관계가 생긴다. 그 지점에 먼저 도달한 거래는 유효한 거래로 인정되지만 늦게 도달한 거래는 이미 잔액이 0인 상태에서 5만원을 보내게 되므로 무효한 거래로 버려지게 된다.</p><p>따라서 이중 지불된 거래 중 하나는 결국에는 무효화되는 방식으로 이중 지불 문제가 해결된다.</p><h2 id="블록-체인의-세번째-핵심-완료된-거래-정보의-변경-불가"><a href="#블록-체인의-세번째-핵심-완료된-거래-정보의-변경-불가" class="headerlink" title="블록 체인의 세번째 핵심 - 완료된 거래 정보의 변경 불가"></a>블록 체인의 세번째 핵심 - 완료된 거래 정보의 변경 불가</h2><p>거래 정보의 해쉬값은 해당 거래가 포함된 블록의 <code>merklehash</code> 계산에 입력값으로 사용되고, <code>merklehash</code>는 블록 해쉬의 계산에 입력값으로 사용된다. 블록 해쉬는 다음 블록(M이라 하면)의 <code>previousblockhash</code> 값으로 저장되며, 이 <code>previousblockhash</code>은 M블록의 블록 헤더 정보로서, M블록의 블록 해쉬를 계산하는데 입력값으로 사용된다.</p><p><img src="https://i.imgur.com/Dtzjz6F.png" alt="Imgur"></p><p>따라서, 어떤 거래 정보가 변경되면 그 거래 정보가 포함된 머클트리의 <code>merklehash</code>가 변경되고, <code>merklehash</code>가 변경되면 블록 해쉬가 변경된다. </p><p>그러면 아래 그림에서 빨간색 밑줄로 표시한 변경된 블록 #1의 블록 해쉬와 그 다음 블록인 블록 #2의 블록 헤더에 <code>previousblockhash</code>로 저장된 값이 달라지게 된다. 따라서 체인을 유지하려면 블록 #2의 <code>previousblockhash</code> 값을 갱신한 후에 블록 #2의 <code>nonce</code> 값을 다시 구해서 블록 해쉬를 새로 구해야 하고, 연이어 블록 #3, #4의 블록 해쉬도 모두 새로 계산해야 한다. </p><p><img src="https://i.imgur.com/3SUjFxR.png" alt="Imgur"></p><p>그리고 블록 해쉬는 작업 증명의 해답(<code>nonce</code> 값)을 찾아내야 구할 수 있으므로, <strong>거래 정보를 변경한 블록부터 그 이후의 모든 블록을 순서대로 다시 채굴해야 한다</strong>.</p><p>블록 하나 채굴하는데 평균 10분이 소요되므로 어떤 악의적인 노드가 바로 앞의 블록의 거래 정보를 변경하고 채굴하는 그 10분 동안, 다른 선의의 노드들은 거래 정보가 변경되지 않은 원래의 블록체인에 계속 블록을 이어 나가게 된다. 그래서 그 <strong>10분 후에는 악의적인 노드의 블록 체인의 길이는 다른 선의의 노드들이 보유한 블록 체인의 길이보다 1개 더 짧아지게 되고, 두 블록 체인이 만나게 되는 순간 길이가 짧은 블록 체인은 버려지게 된다</strong>.</p><blockquote><p>완료된 거래 정보를 변경하려면,</p><p>변경하려는 거래 정보가 포함된 블록부터 그 이후의 모든 블록을 순서대로 다시 채굴해서 새로운 블록 체인(A)를 만들어야 하는데,</p><p>그동안에도 변경 되지 않은 원래의 블록 체인에는 다른 노드들에 의해 블록이 계속 추가되고 A보다 길이가 길어지게 되므로,</p><p>A는 폐기되며 완료된 거래 정보의 변경은 실패하게 된다.</p></blockquote><p>그런데 악의적인 노드가 다른 노드들보다 연산 능력이 훨씬 뛰어나다고 가정해보자. </p><p>그렇다면 악의적인 노드에 있는 블록 체인에 블록이 추가되는 속도가 다른 블록 체인에 블록이 추가되는 속도보다 더 빠를 것이고, 언젠가는 악의적인 노드의 블록 체인의 길이가 가장 길어지게 된다. 이렇게 되는 순간 악의적인 노드에 의해 변경된 거래 정보가 유효한 거래 정보로서 전체 블록 체인 네트워크에 퍼지게 되며 과거 거래 정보의 변경이 성공하게 된다. 이를 <strong>51% 공격</strong>이라고 한다.</p><p>하지만 경제적인 관점에서 생각해보면 이런 일이 발생할 가능성은 사실상 없다. 일단, 거래 정보가 변경될 수 있다는 사실이 알려지는 순간 블록 체인의 신뢰는 깨지게 된다. </p><p><strong>만약 악의적인 노드가 오랫동안 가장 큰 연산 능력을 가지고 있었다면, 악의적인 노드가 생성한 블록이 많을 것이고 그에 따른 보상액도 많이 보유하고 있을 것이다. 이런 상황에서 블록 체인의 신뢰가 붕괴되면 큰 피해를 보는 쪽은 악의적인 노드 자신</strong>이기 떄문에 거래 정보를 변경할 경제적 동기가 없다. </p><p><strong>악의적인 노드가 갑자기 많은 연산 능력을 가지게 되었다고 해도, 블록 체인의 신뢰 붕괴로 가치가 사라진 블록을 채굴해봤자 앞으로 가져갈 수 있는 경제적 이익은 없다</strong>. 따라서, <strong>경제적으로 이익을 볼 수 없는 거래 정보의 변경은 사실상 발생하지 않게 된다</strong>.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>지금까지 블록 체인이 어떻게 비트 코인이라는 암호화 화폐의 신뢰의 원천이 될 수 있는가라는 물음에 대한 답을 찾아봤다. 정리해보면 다음과 같다.</p><blockquote><p>블록 체인은 </p><ul><li>거대한 분산 공개 장부이며, 그 장부 안에 포함된 개별 거래는 모두 디지털 서명이 붙어 있어서 은행이나 다른 제3자의 개입이 없어도 진본임을 보증할 수 있다.</li><li>수천, 수만노드에 분산 되어 있어서 어느 한 지점에 장애나 공격이 발생하더라도 블록 체인이라는 네트워크 전체는 문제 없이 계속 돌아갈 수 있다.</li><li>작업 증명이라는 수학적 계산 작업과 경제 관점에서의 논리를 통해 위/변조가 사실상 불가능한 구조를 갖게 되어, 그 안에 기록된 거래들은 은행같은 중앙의 보증 기관이 없이도 신뢰할 수 있는 거래로서 확정될 수 있다.</li><li>분산 환경에 전파되는 과정에서 분기가 발생할 수 있으나, 가장 길이가 긴 블록 체인을 유효한 블록 체인으로 선택한다. </li></ul></blockquote><p>블록 체인에도 여러 가지 도전적인 과제들이 있고, 그중에서 가장 중요한 것은 블록 체인의 확장성 문제다. 여기에서 그런 내용을 모두 다룰 수는 없겠지만, 지금까지 펼쳐놓은 이야기가 앞으로 블록 체인에 대한 자료를 접할 때 이해의 폭을 넓혀줄 수 있는 발판이 되어줄 수 있기를 바란다.</p><p>블록 체인은 거래 당사자간의 신뢰 확보를 위해 중앙 기관을 필요로 하지 않는 탈중앙화(Decentralization)를 달성한 최초의 소프트웨어 기술이다. </p><p>비트코인은 화폐에 한정되어 있지만 이더리움이나 최근 개발되고 있는 EOS나 IOTA, 국내에서 개발되는 BlockchainOS 등은 단순한 화폐를 넘어서 블록 체인 위에서 당사자간의 계약을 프로그램으로 실행시킬 수 있는 탈중앙화 플랫폼을 지향하고 있다. </p><p><strong>블록 체인이 세상을 바꿀 수 있는 기술이라고 평가받는 이유도 이처럼 탈중앙화 플랫폼의 바탕이 되기 때문</strong>이다. </p><p>좀더 나은 세상을 만드는데 기여할 수 있는 기회의 문이 천천히 하지만 분명히 열리고 있다.</p><h2 id="FAQ로-정리해보는-블록-체인"><a href="#FAQ로-정리해보는-블록-체인" class="headerlink" title="FAQ로 정리해보는 블록 체인"></a>FAQ로 정리해보는 블록 체인</h2><h3 id="블록을-생성하는데-성공한-단-한-명의-채굴자만-보상을-받는건가"><a href="#블록을-생성하는데-성공한-단-한-명의-채굴자만-보상을-받는건가" class="headerlink" title="블록을 생성하는데 성공한 단 한 명의 채굴자만 보상을 받는건가?"></a>블록을 생성하는데 성공한 단 한 명의 채굴자만 보상을 받는건가?</h3><p>그렇다. 그래서 이론적으로는 평생 채굴기를 돌려도 단 하나의 블록도 생성하지 못할 수도 있다. 그래서 실제로는 채굴 풀(pool)을 형성해서 <code>nonce</code> 값을 찾는 계산 작업을 분담하고, 해당 풀에서 블록이 생성되면 풀에 참가한 채굴자들끼리 각자의 배분 기준에 의해 보상액을 배분 받는 방식으로 채굴 시장이 운영된다.</p><h3 id="작업-난이도는-무엇인가"><a href="#작업-난이도는-무엇인가" class="headerlink" title="작업 난이도는 무엇인가?"></a>작업 난이도는 무엇인가?</h3><p>블록 해쉬가 특정 숫자보다 낮게 나올 때의 <code>nonce</code> 값을 찾아내는 것이 작업 증명이라고 했다. <strong>작업 난이도는 <code>nonce</code> 값 계산의 어려운 정도</strong>를 나타낸다. 작업 난이도는 블록 헤더 정보에서 <code>bits</code>라는 값으로 조절된다.</p><p>앞에서 블록 해쉬는 32바이트의 숫자라고 했는데, 이해를 쉽게 하기 위해 블록 해쉬를 부호 없는 1바이트의 숫자라고 해보자. 그럼 1바이트의 숫자값을 블록 해쉬값으로 산출하는 해쉬 함수는 0 ~ 255 사이의 값을 결과로 산출한다.</p><p>블록 해쉬가 128보다 작아야 한다고 하면, 0 ~ 255 사이의 값을 산출하는 해쉬 함수를 적용해서 128보다 작은 블록 해쉬값이 나올 확률은 <code>128보다 작은 수(0~127)의 개수 = 128</code>/<code>해쉬 함수가 산출할 수 있는 모든 값(0~255)의 개수 = 256</code>, 즉, <code>128/256</code>이므로, 50%의 확률이다.</p><p>블록 해쉬가 64보다 작아야 한다면 64/256, 즉 25%의 확률로 <code>nonce</code> 값을 구할 수 있다. 블록 해쉬가 32보다 작아야 한다면 확률은 12.5%로 줄어든다. 여기서 128, 64, 32라는 특정 숫자가 바로 블록 헤더 정보의 <code>bits</code>이다.</p><p>실제로 <code>bits</code>의 값이 128, 256 이런 식으로 저장되지는 않고, 지수와 계수를 사용하는 별도의 표현 방식이 있다.</p><p>난이도는 2,160개의 블록이 생성되는데 소요되는 시간이 평균 시간인 21,600분(10분/블록 * 2,160블록)보다 오래 걸리면 낮아지고, 적게 걸리면 높아지는 방식으로, 대략 21,600분을 주기로 전체적으로 평균 10분이 소요되는 하나의 난이도가 전체에 적용된다. 따라서 채굴자가 늘어나서 블록을 생성하는데 소요되는 시간이 줄어들게 되면, 정해진 주기에 따라 난이도가 높아져서 결국에는 평균적으로 10분이 소요되게 된다.</p><blockquote><p>블록 헤더의 <code>bits</code>는 <code>nonce</code> 값을 계산하는데 기준이 되는 특정 숫자를 나타내며,</p><p>블록체인 전체에 걸쳐 일률적으로 적용되는 숫자다.</p></blockquote><h3 id="비트코인-지갑에도-블록-체인의-모든-거래-정보가-저장되나"><a href="#비트코인-지갑에도-블록-체인의-모든-거래-정보가-저장되나" class="headerlink" title="비트코인 지갑에도 블록 체인의 모든 거래 정보가 저장되나?"></a>비트코인 지갑에도 블록 체인의 모든 거래 정보가 저장되나?</h3><p>비트코인 지갑은 송수금 거래를 가능하게 해주는 클라이언트 소프트웨어이며, 거래 정보를 블록 체인 네트워크에 전파해야 하므로 블록 체인 네트워크의 노드이기도 하다. 하지만, 지갑은 작업 증명 계산을 하지 않기 때문에 블록 체인의 모든 거래 정보를 저장할 필요가 없고, 저장하지도 않는다. 블록 체인 네트워크에 참여하는 노드는 여러 종류가 있으며, 지갑에는 블록 체인의 전체 거래 정보가 저장되지는 않는다.</p><h3 id="채굴-보상이-줄어든다면-채굴에-의해-유지되는-블록-체인이-지속될-수-있나"><a href="#채굴-보상이-줄어든다면-채굴에-의해-유지되는-블록-체인이-지속될-수-있나" class="headerlink" title="채굴 보상이 줄어든다면 채굴에 의해 유지되는 블록 체인이 지속될 수 있나?"></a>채굴 보상이 줄어든다면 채굴에 의해 유지되는 블록 체인이 지속될 수 있나?</h3><p>비트코인을 예로 들면 채굴 보상은 비트코인으로 지급되며, 지급되는 양은 비트코인 기준으로는 줄어들지만 비트코인 자체의 가치가 늘어난다면 보상 자체가 줄어드는 것은 아니다. 몇 년전에 채굴 보상이 50BTC 이고 현재 보상이 12.5BTC로 1/4로 줄었다고 하더라도, 비트코인 자체의 가치는 4배가 훨씬 넘게 증가했기 때문에 실질 보상액은 오히려 늘어났다고 볼 수 있다. </p><p>이처럼 디플레이션 화폐라는 비트코인의 특징은 비트코인의 가격을 높이는 중요한 요인이기도 하다. 하지만 신규 발행 비트코인이 0이 되는 시점(약 2100년 이후)에는 어떤 모습일까? 결국 남는 보상은 수수료뿐이므로 수수료를 극대화 하거나 소요 비용을 낮추는 쪽으로 흘러갈 것이다.</p><p>결국 블록 사이즈를 키워서 블록 안에 더 많은 거래를 담아서 수수료 수입을 높이거나, 난이도를 낮춰서 채굴 비용을 낮추는 방식 또는 둘의 조합으로 전개될 가능성이 높다.</p><hr><blockquote><p>기부</p><ul><li>Bitcoin: 1QofbPJxE9b39SrhCLhCWGsBj8cv299qd</li><li>Ethereum: 0x4d8029ceace5ef7369843d2ee6c11ed39561bddc</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.imaso.co.kr/archives/248&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;마이크로소프트웨어 2017년 10월호&lt;/a&gt;에 기고한 ‘가볍게 읽어 보는 블록 체인 
      
    
    </summary>
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/tags/BlockChain/"/>
    
      <category term="블록체인" scheme="http://homoefficio.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="비트코인" scheme="http://homoefficio.github.io/tags/%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8/"/>
    
      <category term="FinTech" scheme="http://homoefficio.github.io/tags/FinTech/"/>
    
      <category term="핀테크" scheme="http://homoefficio.github.io/tags/%ED%95%80%ED%85%8C%ED%81%AC/"/>
    
      <category term="Cryptocurrency" scheme="http://homoefficio.github.io/tags/Cryptocurrency/"/>
    
      <category term="Consensus" scheme="http://homoefficio.github.io/tags/Consensus/"/>
    
      <category term="암호화폐" scheme="http://homoefficio.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90/"/>
    
      <category term="Bitcoin" scheme="http://homoefficio.github.io/tags/Bitcoin/"/>
    
      <category term="합의 알고리듬" scheme="http://homoefficio.github.io/tags/%ED%95%A9%EC%9D%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EB%93%AC/"/>
    
  </entry>
  
  <entry>
    <title>(번역) IOTA-Transaction-Confirmation-Consensus</title>
    <link href="http://homoefficio.github.io/2017/11/19/IOTA-Transaction-Confirmation-Consensus/"/>
    <id>http://homoefficio.github.io/2017/11/19/IOTA-Transaction-Confirmation-Consensus/</id>
    <published>2017-11-19T03:52:18.000Z</published>
    <updated>2018-10-13T15:49:56.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IOTA Donations: QPLGOG9PMIMUAW9UDMUNZQHPXZPXDNGLBEIHILXHWHIOFHLIHPDDERXAJQKUQDEORMHSUWVZQE9JYSHIWADIIPAOJD</p></blockquote><blockquote><p>IOTA Donations for Korean version: RLNVZQOKBZRUNZUHDLNMW9XVRVTOBMNLZKXBW9PYMBCOGPCVAEMNUESFD9OGCZVILOACELXGXHIWSXWYCDMXXHNIUX</p></blockquote><h1 id="IOTA-트랜잭션-확정-및-합의"><a href="#IOTA-트랜잭션-확정-및-합의" class="headerlink" title="IOTA 트랜잭션, 확정 및 합의"></a>IOTA 트랜잭션, 확정 및 합의</h1><p>이 글은 <a href="https://github.com/noneymous/iota-consensus-presentation/blob/master/README.md" target="_blank" rel="noopener">https://github.com/noneymous/iota-consensus-presentation/blob/master/README.md</a> 를 원저자의 허락을 받고 번역한 글입니다.</p><h2 id="탱글-초기-상태"><a href="#탱글-초기-상태" class="headerlink" title="탱글 초기 상태"></a>탱글 초기 상태</h2><p><img src="https://i.imgur.com/xCzNwSB.png" alt="Imgur"></p><p>블록 체인 기술에서는 하나의 정적 블록이 여러 개의 트랜잭션을 담고 있고, 그런 정적 블록을 시간 순으로 정렬된 시퀀스로 구성합니다. IOTA는 블록 체인과 다르게 시간 순서로 된 정적 블록의 시퀀스를 만들지 않습니다. 대신에 하나의 트랜잭션이 다른 트랜잭션에 병렬적으로 추가될 수 있습니다. 이제부터 그림과 설명을 통해 IOTA에서 트랜잭션을 어떻게 추가하고 검증하며 합의를 이루는지 알아보겠습니다.</p><p>위의 그림에는 탱글(Tangle) 네트워크가 나와있습니다. 앞으로 나올 여러 시나리오는 이 그림을 바탕으로 진행됩니다. </p><p>초록색 네모는 네트워크에서 높은 신뢰도를 가진 확정된 트랜잭션을 나타내고, 파란색 네모는 부분적으로 확정된, 즉 낮은 신뢰도로 확정된 트랜잭션을 나타냅니다. 회색 네모는 아직 아무 검증도 받지 못한 트랜잭션을 나타냅니다. 노란색 네모는 방금 새로 생긴 트랜잭션을 나타냅니다. 나중에 나올 빨간색 네모는 충돌이 있거나 유효하지 않은 트랜잭션을 나타냅니다. 회색 네모나 노란색 네모처럼 아직 검증 받지 않은 트랜잭션을 팁이라고 합니다.</p><p>위의 그림에서 <code>α</code>는 비정상적인 트랜잭션 입니다. <code>α</code>는 <code>h</code>와 <code>l</code>를 참조하고 있는데, <code>α</code>는 자기가 추가될 때 팁이었던 <code>l</code>과 함께, 이미 <code>l</code>에 의해 참조되고 있으므로 명백하게 팁이 아닌 상태인 <code>h</code>를 참조하기 때문입니다. 비정상적이긴 하지만 문제가 되지는 않으며 현재 시점에서는 네트워크에서 그냥 용인됩니다.</p><h2 id="새-트랜잭션-추가"><a href="#새-트랜잭션-추가" class="headerlink" title="새 트랜잭션 추가"></a>새 트랜잭션 추가</h2><p><img src="https://i.imgur.com/VEhr0LW.png" alt="Imgur"></p><p>탱글 사용자가 새 트랜잭션 <code>1</code>을 추가하려면 <code>w</code>과 <code>x</code> 두 개의 팁을 무작위로 선택하고, 그 <code>w</code>과 <code>x</code>를 검증해야 합니다. 검증이란 팁의 시그너처, 작업 증명(스팸 방지를 위한 낮은 난이도의 작업 증명)을 검사하고, 팁이 직간접적으로 참조하는 과거의 트랜잭션과 충돌이 없는지 확인하는 것을 말합니다. 선택한 팁에 문제가 없다면 사용자는 그 두 개의 팁 <code>w</code>와 <code>x</code>를 참조하는 새 트랜잭션 <code>1</code>을 탱글에 추가합니다.</p><p>선택된 두 개의 팁 <code>w</code>와 <code>x</code>에 의해 직간접적으로 참조되지 않는 트랜잭션(회색 경계 밖에 있는 <code>l</code>, <code>o</code>, <code>r</code>, <code>t</code>, <code>v</code>, <code>y</code>, <code>z</code>)은 <code>1</code>이 탱글에 추가되는 과정에서는 검증되지 않습니다. 이 트랜잭션들은 나중에 다른 트랜잭션이 추가될 때 검증됩니다. </p><h2 id="다른-트랜잭션의-추가"><a href="#다른-트랜잭션의-추가" class="headerlink" title="다른 트랜잭션의 추가"></a>다른 트랜잭션의 추가</h2><p><img src="https://i.imgur.com/y9vIdMj.png" alt="Imgur"></p><p><code>1</code>이 추가됨과 거의 동시(직전이든 직후든 상관없음)에 다른 사용자가 새로운 트랜잭션 <code>2</code>를 <code>1</code>과는 다른 위치에 추가하려고 합니다. <code>2</code>는 두 개의 팁 <code>y</code>와 <code>z</code>를 선택해서 앞에서 설명한 것처럼 검증합니다. <code>1</code>에 의해 검증되었던 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>, <code>g</code>, <code>h</code>, <code>i</code>, <code>j</code>, <code>k</code>, <code>m</code>, <code>n</code>은 <code>2</code>에 의해서도 또 한 번 검증되고, <code>l</code>, <code>o</code>, <code>r</code>, <code>t</code>, <code>v</code>, <code>y</code>, <code>z</code>는 <code>2</code>에 의해 검증됩니다. </p><h2 id="탱글-상태의-변화"><a href="#탱글-상태의-변화" class="headerlink" title="탱글 상태의 변화"></a>탱글 상태의 변화</h2><p><img src="https://i.imgur.com/Byjez9N.png" alt="Imgur"></p><p><code>1</code>과 <code>2</code>에 의한 검증 경로를 겹쳐보면 위의 그림과 같습니다. 어떤 트랜잭션은 <code>1</code>이나 <code>2</code>중 한 쪽에 의해서만 확정되고, 어떤 트랜잭션은 <code>1</code>, <code>2</code> 모두에 의해 확정됩니다. 현재 시점에 존재하는 팁 모두에 의해 검증되고 확정된 트랜잭션들은 ‘완전 확정’되었다고 합니다. 그래서 <code>n</code>은 새롭게 전체 확정되어 탱글에서 더 깊숙히 들어가고 초록색 네모로 바뀝니다. <code>1</code> 또는 <code>2</code>에 추가되는 자손 트랜잭션들은 <code>n</code>을 계속해서 재검증하게 될 것입니다. </p><p>여기서 알 수 있는 것은?</p><ul><li><p>어떤 사용자도 모든 트랜잭션을 확인하고 검증할 필요는 없습니다. 모든 사용자는 2개의 트랜잭션과 그의 조상 트랜잭션을 선택하고 검증하면 됩니다. 이를 통해 탱글의 일부분을 검증하게 되겠죠. 다른 사용자들은 다른 팁과 조상 트랜잭션을 선택하고 검증할테고, 이 모두의 총합은 결국 탱글 전체를 검증하게 됩니다.</p></li><li><p>시간이 지나서 한 트랜잭션이 충분히 많은 검증을 받으면, 이 트랜잭션은 탱글에 새로 추가되는 모든 트랜잭션의 검증 경로에 직간접적으로 포함됩니다. 이런 트랜잭션은 완전히 검증되었다고 볼 수 있으며 새 트랜잭션이 추가될 때마다 계속 검증되고 확정될 것입니다. 그럼 이 트랜잭션은 모든 사용자(또는 기계)로부터 확정되었다고 가정할 수 있으며, 높은 확실성을 가지고 있다고 가정할 수 있습니다.</p></li><li><p>확정 여부를 검사하려면 송금자로부터 IOTA를 받는 수금자는 자신에게 지불하는 정보를 담고 있는 트랜잭션이 탱글에 존재하는 모든 팁으로부터(또는 좀더 낮은, 예를 들어 80%의 확실성만으로도 괜찮다면 80%의 팁으로부터) 직간접적으로 참조되고 있는지만 검사하면 됩니다. 해당 트랜잭션을 별도로 다시 검증하거나 비슷한 절차를 거칠 필요가 없습니다. 주의: 수천 개의 팁이 존재할 수 있으므로 모든 팁의 부모를 검사하는 대신에 무작위 샘플을 선정해서 통계적인 평가를 하는 것도 가능합니다.</p></li></ul><p>팁의 갯수가 너무 작으므로 <code>n</code>은 아직 확정되었다고 볼 수는 없습니다. 더 많은 팁을 포함하고 있는 다음 그림에서 설명을 이어갑니다.</p><h2 id="확정도"><a href="#확정도" class="headerlink" title="확정도"></a>확정도</h2><p><img src="https://i.imgur.com/6Ct1D5Y.png" alt="Imgur"></p><p>이번에는 팁의 갯수가 더 많은 확장된 그림으로 살펴봅시다. 새 팁은 각자의 검증 경로가 있고, 그림에서 옅은색 영역으로 표시되어 있습니다. 영역이 겹칠 수록 색이 짙어지는 것을 유심히 보면 어떤 트랜잭션이 얼마나 많은 팁에 의해 검증되는지와 그에 따른 확정도가 어느 정도인지 알 수 있습니다.</p><p>IOTA를 받는 수금자는 허용 확정도를 스스로 정할 수 있습니다. 트랜잭션 속도가 거래 금액보다 더 중요하다면(즉, 액수가 매우 작은 마이크로 트랜잭션 또는 0원 짜리 트랜잭션), 또는 송금자가 믿을 만한 친구라면 75%의 확정도면 충분할 겁니다. 허용 확정도가 75%라면, 다시 말해 4개 팁 중에서 3개의 팁으로부터 검증을 받으면 되는 수준이라면, 그림에 표시된 4개의 팁 중 <code>2</code>, <code>3</code>, <code>4</code> 세 개의 팁으로부터 검증 받은 <code>l</code>, <code>o</code>, <code>t</code>는 확정되었다고 볼 수 있습니다.</p><h2 id="전파-지연"><a href="#전파-지연" class="headerlink" title="전파 지연"></a>전파 지연</h2><p><img src="https://i.imgur.com/Pyuvqxc.png" alt="Imgur"></p><p>작업증명이 오래 걸릴 수도 있고, 트랜잭션의 전파가 지연될 수 있으므로 이론적으로는 <code>5</code> 같은 느린 트랜잭션이 뒤늦게 탱글에 추가될 수 있습니다. <code>5</code>가 추가되기 전에는 <code>n</code>이 모든 팁으로부터 검증을 받은 상태였지만, <code>5</code>의 검증 경로에는 <code>n</code>이 포함되지 않으므로 <code>5</code>가 추가되면 <code>n</code>은 더이상 모든 팁으로부터 검증 받은 트랜잭션이 아닌 상태로 바뀝니다. 하지만 확정도는 80%로 여전히 매우 높습니다(그림에서는 5개의 팁만 있지만 실제로는 수천 개의 팁이 있을 것입니다).</p><p><code>5</code>가 추가된다고 해서 <code>n</code>의 상태가 확정에서 미확정으로 바뀌지는 않습니다. 단지 수학적으로 정확한 확정도 값이 변할 뿐입니다(예를 들어 99개의 팁 모두로부터 검증을 받은 상태였다가 새로 추가된 1개의 팁으로부터 검증을 받지 못하게 되었다면 확정도는 100%에서 99%로 변합니다). <code>5</code>가 추가된 후에 새로 추가된 팁이 <code>1</code>과 <code>5</code>를 참조한다면 <code>n</code>의 확정도는 다시 100%로 변합니다. 더 많은 트랜잭션이 탱글에 추가된다면 미미하나마 이런 확정도 변동이 생길 가능성도 작아집니다.</p><p>어쨌든 100%의 확정도는 획득하는 것은 어려운 일이라는 점을 알아둘 필요가 있습니다. 왜냐하면 비정상적인 트랜잭션을 참조하거나 정해진 프로토콜을 따르지 않는 악의적인 팁이 존재할 수 있기 때문입니다.</p><h2 id="이중-지불"><a href="#이중-지불" class="headerlink" title="이중 지불"></a>이중 지불</h2><p><img src="https://i.imgur.com/ikL18Ic.png" alt="Imgur"></p><p>사용자가 두 개의 충돌되는 트랜잭션 <code>w</code>와 <code>y</code>를 탱글의 서로 다른 영역에서 발생시켰다고 가정해봅시다. 그 이후에 추가되는 트랜잭션은 팁 선정이나 전파 지연 때문에, 충돌되는 트랜잭션인 <code>w</code>와 <code>y</code> 중 하나의 트랜잭션만 검증 경로에 포함할 가능성이 있습니다. </p><p>예를 들어 <code>1</code>을 탱글에 추가하는 사용자와 <code>2</code>를 탱글에 추가하는 사용자는 <code>w</code>와 <code>y</code>가 충돌된다는 사실을 알 수 없으며, 결과적으로 <code>w</code>와 <code>y</code>를 충돌 없는 유효한 트랜잭션으로 판별하게 됩니다. </p><p>하지만 그 충돌은 머지 않아 발견됩니다. 예를 들어 <code>1</code>과 <code>2</code>를 참조하는 <code>5</code>가 추가되면 <code>5</code>의 검증 경로에는 <code>w</code>와 <code>y</code>가 모두 포함되므로 <code>5</code>는 충돌을 발견할 수 있습니다. 그래서 <code>5</code>는 <code>1</code>과 <code>2</code>를 선택하지 않고 충돌이 없는 다른 두 개의 팁을 다시 선택할 겁니다. 그래야 <code>5</code> 자신이 나중에 추가되는 트랜잭션에 의해 유효한 트랜잭션으로서 검증 받을 수 있기 때문입니다.  </p><p>팁 선정 알고리듬과 탱글 프로세스에 따르면 충돌이 명백하게 발견되기 전에 <code>w</code>와 <code>y</code> 중 하나만 검증 경로에 포함한 많은 사용자는 <code>w</code>와 <code>y</code>의 충돌을 발견할 수 없으므로, <code>w</code>와 <code>y</code>를 유효한 트랜잭션으로 인정할 가능성이 있습니다. </p><p>하지만 결국에는 사용자들이 새로운 트랜잭션을 <code>w</code>를 검증 경로에 포함하는 팁과 <code>y</code>를 검증 경로에 포함하는 팁 중 어느 쪽에 더 많이 추가했느냐에 따라 <code>w</code>와 <code>y</code> 둘 중 하나만 확정되고 나머지 하나는 버려집니다. </p><p>버려진 쪽에 추가된 트랜잭션들은 충돌이 있었는지 몰랐지만 억울하게도 함께 버려집니다. 하지만 충돌을 모른채 버려진 트랜잭션들이 탱글에서 아예 사라지는 것은 아니고 다른 사용자(IOTA를 받는 수금자일 가능성이 높습니다)에 의해 선택되서 탱글에 다시 추가되고 검증 받을 수 있는 기회를 얻게 됩니다. </p><p>검증을 받으려면 작업 증명이 다시 실행되겠지만 송금자로부터 거래 승인 정보를 다시 받아와야 할 필요는 없습니다.</p><h2 id="이중-지불-문제-해결"><a href="#이중-지불-문제-해결" class="headerlink" title="이중 지불 문제 해결"></a>이중 지불 문제 해결</h2><p><img src="https://i.imgur.com/PvYUUpM.png" alt="Imgur"></p><p>앞의 이중 지불 그림에서 사용자는 <code>5</code>를 <code>1</code>과 <code>2</code>에 추가하려고 했지만, <code>w</code>와 <code>y</code>가 충돌된다는 걸 발견하고는 팁을 다시 선택해서 <code>1</code>과 <code>4</code>를 선택했고, <code>1</code>과 <code>4</code>에서는 충돌이 발견되지 않았으므로 <code>5</code>는 <code>1</code>과 <code>4</code>에 추가 되었습니다. 다른 사용자는(반드시 다른 사용자일 필요는 없습니다) <code>7</code>을 <code>2</code>와 <code>3</code>에 추가 했습니다.</p><p>이렇게 되면 <code>w</code>를 포함하는 경로와 <code>y</code>를 포함하는 두 가지 경로로 일종의 분기가 발생하지만, 앞의 이중 지불 단원에서 설명한대로 둘 중 하나는 버려지고 하나만 살아남게 됩니다. 트랜잭션의 누적 가중치를 감안한 무작위 팁 선택 로직에 의해, 분기된 두 경로 중 한 쪽 경로에 더 많은 자손 트랜잭션이 추가될 것 입니다.</p><p>그리고 시간이 지나면 누적 가중치를 감안한 팁 선택 알고리듬에 의해 한 쪽 경로에는 정상적인 방법으로 트랜잭션을 추가하는 것이 불가능해집니다. 앞의 그림에서 <code>5</code>, <code>6</code>, <code>8</code> 다음에는 새로운 트랜잭션이 계속 추가될 수 있지만, <code>7</code> 다음에는 트랜잭션을 추가할 수 없게 됩니다. 그래서 <code>y</code>, <code>2</code>, <code>3</code>, <code>7</code>은 더 이상 검증을 받지 못하게 되고 완전 확정 상태가 될 수 없습니다.</p><p>이중 지불 단원에서 설명한 것처럼 버려지는 경로에 있던 <code>y</code>, <code>2</code>, <code>3</code>, <code>7</code>은 일단 탱글에서 떨어져나간 후에 다른 새로운 트랜잭션들에 의해 검증되면 다시 탱글에 추가될 수 있습니다. <code>y</code>, <code>2</code>, <code>3</code>, <code>7</code> 각각이 유효한 트랜잭션이라면 다른 정상적인 트랜잭션과 마찬가지로 결국에는 확정될 수 있습니다. 그래서 <code>2</code>, <code>3</code>, <code>7</code>은 확정될 수 있지만 충돌 내용이 포함된 <code>y</code>는 끝내 확정될 수 없습니다.</p><h2 id="오프라인-탱글"><a href="#오프라인-탱글" class="headerlink" title="오프라인 탱글"></a>오프라인 탱글</h2><p><img src="https://i.imgur.com/60kh0yc.png" alt="Imgur"></p><p>탱글 사용자는 탱글 네트워크에 연결되어 있지 않은 오프라인 네트워크에서도 트랜잭션을 계속 붙여나갈 수 있습니다. 그러기 위해서는 트랜잭션이 프로토콜로 정해진 규약에 따라 생성되고 연결되어야 합니다. </p><p>오프라인 네트워크는 외부 인터넷 연결이 끊어져서 메인 탱글 네트워크에 연결할 수는 없지만, 인트라넷처럼 내부의 연결은 가능한 상태의 네트워크를 말합니다. </p><p>위의 예제 그림에서 <code>1</code>과 <code>2</code>는 처음으로 온라인 탱글 네트워크와 연결이 끊어져서 오프라인 상태가 된 트랜잭션 입니다. 그 둘은 온라인 탱글의 가장 끝에 있던 팁인 <code>r</code>과 <code>t</code>에 연결되어 있습니다. </p><p>노란색 영역으로 표시된 오프라인 네트워크에서 <code>1</code>과 <code>2</code> 이후에 발생하는 트랜잭션은 온라인 네트워크일 때와 마찬가지 방식으로 <code>1</code>과 <code>2</code>를 조상으로 해서 계속해서 추가됩니다.</p><p>다시 인터넷과 연결되어 오프라인 네트워크의 트랜잭션들을 다시 메인 탱글 네트워크에 연결할 수 있게 되면, 메인 탱글 네트워크와 방금 다시 온라인 네트워크가 된 노란색 영역 모두를 볼 수 있는 <code>8</code>이 메인 탱글 네트워크에 있는 <code>y</code>와 오프라인 네트워크에 있던 <code>7</code>을 선택해서 검증하면서 오프라인 네트워크와 메인 탱글 네트워크를 병합합니다. 나중에 <code>8</code>에 트랜잭션이 추가되면 오프라인 네트워크에 있던 <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>이 검증 경로에 포함되어 함께 검증됩니다.</p><p>오프라인 네트워크에 있던 트랜잭션이 완전 확정 상태가 되려면, 메인 탱글 네트워크에 있는 트랜잭션과 마찬가지로 충돌이 없어야 합니다. 만약 <code>1</code>~<code>7</code> 중에서 하나라도 메인 탱글 네트워크에 있는 트랜잭션과 충돌이 있다면, <code>1</code>~<code>8</code> 모두 확정되지 못합니다. 이중 지불 단원에서 설명한 것처럼 충돌이 메인 탱글에 있는 모든(또는 대다수의) 팁에 의해 발견되려면 어느 정도 후속 트랜잭션이 탱글 네트워크에 추가되어야 합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;IOTA Donations: QPLGOG9PMIMUAW9UDMUNZQHPXZPXDNGLBEIHILXHWHIOFHLIHPDDERXAJQKUQDEORMHSUWVZQE9JYSHIWADIIPAOJD&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/tags/BlockChain/"/>
    
      <category term="블록체인" scheme="http://homoefficio.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="FinTech" scheme="http://homoefficio.github.io/tags/FinTech/"/>
    
      <category term="핀테크" scheme="http://homoefficio.github.io/tags/%ED%95%80%ED%85%8C%ED%81%AC/"/>
    
      <category term="Cryptocurrency" scheme="http://homoefficio.github.io/tags/Cryptocurrency/"/>
    
      <category term="IOTA" scheme="http://homoefficio.github.io/tags/IOTA/"/>
    
      <category term="아이오타" scheme="http://homoefficio.github.io/tags/%EC%95%84%EC%9D%B4%EC%98%A4%ED%83%80/"/>
    
      <category term="Tangle" scheme="http://homoefficio.github.io/tags/Tangle/"/>
    
      <category term="DAG" scheme="http://homoefficio.github.io/tags/DAG/"/>
    
      <category term="Directed Acyclic Graph" scheme="http://homoefficio.github.io/tags/Directed-Acyclic-Graph/"/>
    
      <category term="Consensus" scheme="http://homoefficio.github.io/tags/Consensus/"/>
    
      <category term="암호화폐" scheme="http://homoefficio.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90/"/>
    
  </entry>
  
  <entry>
    <title>(번역) Ever wonder how Bitcoin (and other cryptocurrencies) actually work?</title>
    <link href="http://homoefficio.github.io/2017/07/18/Ever-wonder-how-Bitcoin-and-other-cryptocurrencies-actually-work/"/>
    <id>http://homoefficio.github.io/2017/07/18/Ever-wonder-how-Bitcoin-and-other-cryptocurrencies-actually-work/</id>
    <published>2017-07-18T12:32:22.000Z</published>
    <updated>2018-10-13T15:49:56.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="번역-Ever-wonder-how-Bitcoin-and-other-cryptocurrencies-actually-work"><a href="#번역-Ever-wonder-how-Bitcoin-and-other-cryptocurrencies-actually-work" class="headerlink" title="(번역) Ever wonder how Bitcoin (and other cryptocurrencies) actually work?"></a>(번역) Ever wonder how Bitcoin (and other cryptocurrencies) actually work?</h1><p>무쟈게 좋아라 하는 <a href="http://www.3blue1brown.com/" target="_blank" rel="noopener">3Blue1Brown</a>의 비디오 하나 번역했다.</p><p>화면 전개에 보조를 맞춰야 되고, 아무리 어순이 다른 영어라지만 내레이션과 너무 동떨어지면 귀에 거슬리고, 화면 내용을 가리지 않도록 양도 조절해야 되는 등, 그냥 책 번역에 비해 공들일 일이 더 많다.</p><p><a href="http://www.3blue1brown.com/" target="_blank" rel="noopener">3Blue1Brown</a> 정도의 초울트라 고퀄 컨텐츠를 받쳐주는 자막이라면 줄바꿈 하나하나까지 심혈을 기울여야.. ㅋ</p><p>처음 보면 쉽지 않게 느껴질 수도 있지만, 사실 비대칭 키, 디지털 서명, 해쉬 함수 정도만 알면 <strong>3Blue1Brown</strong> 특유의 깔끔한 시각화와 함께 어렵지 않게 이해할 수 있을 것이다.</p><p>한 번 보고, 두 번 보자! 원한다면 한국어 자막을 켜시고!</p><div class="video-container"><iframe src="//www.youtube.com/embed/bBC-nXj3Ng4" frameborder="0" allowfullscreen></iframe></div><p>자매품: <a href="http://homoefficio.github.io/2016/01/23/BlockChain-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90/">BlockChain 기초 개념</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;번역-Ever-wonder-how-Bitcoin-and-other-cryptocurrencies-actually-work&quot;&gt;&lt;a href=&quot;#번역-Ever-wonder-how-Bitcoin-and-other-cryptocurrencies
      
    
    </summary>
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="http://homoefficio.github.io/tags/BlockChain/"/>
    
      <category term="블록체인" scheme="http://homoefficio.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="BitCoin" scheme="http://homoefficio.github.io/tags/BitCoin/"/>
    
      <category term="비트코인" scheme="http://homoefficio.github.io/tags/%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8/"/>
    
      <category term="FinTech" scheme="http://homoefficio.github.io/tags/FinTech/"/>
    
      <category term="핀테크" scheme="http://homoefficio.github.io/tags/%ED%95%80%ED%85%8C%ED%81%AC/"/>
    
      <category term="Proof of Work" scheme="http://homoefficio.github.io/tags/Proof-of-Work/"/>
    
      <category term="작업증명" scheme="http://homoefficio.github.io/tags/%EC%9E%91%EC%97%85%EC%A6%9D%EB%AA%85/"/>
    
      <category term="3Blue1Brown" scheme="http://homoefficio.github.io/tags/3Blue1Brown/"/>
    
      <category term="Digital Signature" scheme="http://homoefficio.github.io/tags/Digital-Signature/"/>
    
      <category term="디지털 서명" scheme="http://homoefficio.github.io/tags/%EB%94%94%EC%A7%80%ED%84%B8-%EC%84%9C%EB%AA%85/"/>
    
      <category term="Cryptocurrency" scheme="http://homoefficio.github.io/tags/Cryptocurrency/"/>
    
      <category term="암호화 화폐" scheme="http://homoefficio.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94-%ED%99%94%ED%8F%90/"/>
    
      <category term="SHA256" scheme="http://homoefficio.github.io/tags/SHA256/"/>
    
      <category term="Hash Function" scheme="http://homoefficio.github.io/tags/Hash-Function/"/>
    
      <category term="해쉬 함수" scheme="http://homoefficio.github.io/tags/%ED%95%B4%EC%89%AC-%ED%95%A8%EC%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring - [ ]가 포함된 URL 파라미터 바인딩 하기</title>
    <link href="http://homoefficio.github.io/2017/04/25/Spring-%EA%B0%80-%ED%8F%AC%ED%95%A8%EB%90%9C-URL-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EB%B0%94%EC%9D%B8%EB%94%A9-%ED%95%98%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2017/04/25/Spring-가-포함된-URL-파라미터-바인딩-하기/</id>
    <published>2017-04-25T14:42:02.000Z</published>
    <updated>2018-10-13T15:49:56.255Z</updated>
    
    <content type="html"><![CDATA[<p>스프링에서 Servlet Request에 포함된 parameter들의 모델 객체(또는 DTO 객체)로의 바인딩은 <code>ServletRequestDataBinder</code>에서 담당한다.</p><p>큰 흐름을 살펴보면 다음과 같다.</p><ol><li>parameterName을 key로, parameterValue를 value로 해서 request 내의 모든 parameter를 <code>MutablePropertyValues</code>에 넣은 후, </li><li><code>MutablePropertyValues</code>에 저장된 값을 <code>DataBinder</code>를 통해 모델 객체(또는 DTO 객체)로 바인딩힌다.</li></ol><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>parameterName이 특별한 점 없이 그냥 일반적이라면 모든 과정이 행복하게 끝나는데, parameterName이 아래와 같이 </p><blockquote><p>items[0][count]</p></blockquote><p>같은 형식으로 들어오면 다음과 같은 에러를 만나게 되는데, 더 안타까운 것은 이 에러는 <code>BindingResult</code>로는 잡히지도 않는다는 점이다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.InvalidPropertyException: </span><br><span class="line">  Invalid property 'items[<span class="string">0</span>][<span class="symbol">count</span>]' of bean class [어쩌구DTO]: </span><br><span class="line"><span class="code">    Property referenced in indexed property path 'items[0][count]' is neither an array nor a List nor a Map</span></span><br><span class="line"></span><br><span class="line"><span class="code">`items[0][count]`</span>가 가리키는 값이 배열도, 리스트도, 맵도 아니라서 예외 발생</span><br></pre></td></tr></table></figure><p>참고로 위 예외가 발생하는 정확한 위치는 스프링의 <code>AbstractNestablePropertyAccessor</code> 클래스의 <code>setPropertyValue</code> 메서드다.</p><p>암튼, 저런 형식의 데이터가 들어올까?</p><p>들어온다. 브라우저에서 jQuery로 다음과 같이 데이터를 서버에 보내면,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'어쩌구-서버-API'</span>,</span><br><span class="line">    contentType: <span class="string">'application/json'</span>,</span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">    crossDomain: <span class="literal">true</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        id: <span class="string">"321"</span>,</span><br><span class="line">        items: [</span><br><span class="line">            &#123;</span><br><span class="line">                id: <span class="string">"abc987"</span>,</span><br><span class="line">                count: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        emails: [<span class="string">'abc@abc.com'</span>, <span class="string">'sdf@sdf.com'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 성공 시 처리 </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>다음과 같은 URL로 서버에 요청이 전달된다.</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /어쩌구-서버-API?id=<span class="number">321</span>&amp;items%<span class="number">5B0</span>%5D%5Bid%5D=abc987&amp;items%<span class="number">5B0</span>%5D%5Bcount%5D=<span class="number">3</span>&amp;emails%5B%5D=abc%40abc.com&amp;emails%5B%5D=sdf%40sdf.com</span><br></pre></td></tr></table></figure><p>눈으로 읽을 수 있도록 URL Decoding하면 다음과 같다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /어쩌구-서버-API?id=321&amp;items[<span class="string">0</span>][<span class="symbol">id</span>]=abc987&amp;items[<span class="string">0</span>][<span class="symbol">count</span>]=3&amp;emails[]=abc@abc.com&amp;emails[]=sdf@sdf.com</span><br></pre></td></tr></table></figure><p>물론 이런 경우라면 원론적으로는 GET 보다는 POST로 보내는 게 적절하다. </p><p>POST로 보냈다면(클라이언트에서도 <code>JSON.stringify()</code>를 이미 했을테고), <code>@RequestBody</code>로 읽어서 모델 객체에 문제 없이 바인딩 할 수 있다.</p><p>하지만 이미 클라이언트가 모두 GET 방식으로 보내고 있고, 클라이언트가 한 군데가 아니라 꽤 많다면, 현실적으로는 그냥 서버 쪽에서 해결하는 것이 좋다.</p><p>하지만 서버 쪽의 스프링은, 앞에서 얘기한 것처럼 이런 형식의 URL 파라미터를 자연스럽게 모델 객체로 바인딩 해 주지 못한다는..</p><h2 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h2><p>그래서 이를 보완할 수 있는 유틸 메서드를 만들어봤다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameterMap  request.getParameterMap()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dto           바인딩 할 DTO의 클래스 리터럴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;           바인딩 할 DTO의 타입</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getDTOFromParamMap</span><span class="params">(Map&lt;String, String[]&gt; parameterMap, Class&lt;T&gt; dto)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MutablePropertyValues sourceProps = getPropsFrom(parameterMap);</span><br><span class="line"></span><br><span class="line">    T targetDTO = dto.newInstance();</span><br><span class="line">    DataBinder binder = <span class="keyword">new</span> DataBinder(targetDTO);</span><br><span class="line">    binder.bind(sourceProps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> targetDTO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MutablePropertyValues <span class="title">getPropsFrom</span><span class="params">(Map&lt;String, String[]&gt; parameterMap)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> MutablePropertyValues mpvs = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line"></span><br><span class="line">    parameterMap.forEach(</span><br><span class="line">            (k, v) -&gt; &#123;</span><br><span class="line">                String dotKey =</span><br><span class="line">                        k.replaceAll(<span class="string">"\\[]"</span>, <span class="string">""</span>)</span><br><span class="line">                         .replaceAll(<span class="string">"\\[(\\D+)"</span>, <span class="string">".$1"</span>)</span><br><span class="line">                         .replaceAll(<span class="string">"]\\[(\\D)"</span>, <span class="string">".$1"</span>)</span><br><span class="line">                         .replaceAll(<span class="string">"(\\.\\w+)]"</span>, <span class="string">"$1"</span>);</span><br><span class="line">                mpvs.addPropertyValue(dotKey, v);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mpvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>핵심 로직은 private 메서드의 람다식 안의 정규표현식에 담겨 있는데, 테스트 코드를 보면 금방 이해할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> object인덱스형_key를_dot형으로_변환() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    String k = <span class="string">"items[0][options][1][a][12][b][abc][c][1234][c1][33][_1][___][99][a33][b3][aa3]"</span>;</span><br><span class="line"></span><br><span class="line">    String result =</span><br><span class="line">            k.replaceAll(<span class="string">"\\[]"</span>, <span class="string">""</span>)</span><br><span class="line">             .replaceAll(<span class="string">"\\[(\\D+)"</span>, <span class="string">".$1"</span>)</span><br><span class="line">             .replaceAll(<span class="string">"]\\[(\\D)"</span>, <span class="string">".$1"</span>)</span><br><span class="line">             .replaceAll(<span class="string">"(\\.\\w+)]"</span>, <span class="string">"$1"</span>);</span><br><span class="line"></span><br><span class="line">    assertThat(result, is(<span class="string">"items[0].options[1].a[12].b.abc.c[1234].c1[33]._1.___[99].a33.b3.aa3"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>쉽게 말해 <code>[ ]</code>로 구성된 parameterName을 스프링이 이해할 수 있는 <code>.</code> 형식으로 적절하게 변환해서 <code>MutablePropertyValues</code>에 에러 없이 집어넣을 수 있게 하고, <code>DataBinder</code>를 통해 모델 객체로 바인딩 하게 해준다.</p><p>단, 한 가지 제약 조건이 있는데 <strong>[ ] 안에 들어가는 parameterName이 숫자로 시작하면 안된다</strong>는 점이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;스프링에서 Servlet Request에 포함된 parameter들의 모델 객체(또는 DTO 객체)로의 바인딩은 &lt;code&gt;ServletRequestDataBinder&lt;/code&gt;에서 담당한다.&lt;/p&gt;
&lt;p&gt;큰 흐름을 살펴보면 다음과 같다.&lt;/p
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Spring" scheme="http://homoefficio.github.io/tags/Spring/"/>
    
      <category term="Data Binding" scheme="http://homoefficio.github.io/tags/Data-Binding/"/>
    
      <category term="URL" scheme="http://homoefficio.github.io/tags/URL/"/>
    
      <category term="스프링" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81/"/>
    
      <category term="데이터 바인딩" scheme="http://homoefficio.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B0%94%EC%9D%B8%EB%94%A9/"/>
    
  </entry>
  
  <entry>
    <title>Git 과거의 특정 커밋 수정하기</title>
    <link href="http://homoefficio.github.io/2017/04/16/Git-%EA%B3%BC%EA%B1%B0%EC%9D%98-%ED%8A%B9%EC%A0%95-%EC%BB%A4%EB%B0%8B-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2017/04/16/Git-과거의-특정-커밋-수정하기/</id>
    <published>2017-04-16T06:34:48.000Z</published>
    <updated>2018-10-13T15:49:56.207Z</updated>
    
    <content type="html"><![CDATA[<p>과거의 특정 커밋에 포함된 내용을 수정해야할 때가 있다.</p><p><code>git rebase</code>를 사용하면 가능하기는 한데, 수정 후 remote에 올릴 때 결국 <code>git push --force</code>(또는 조금이라도 안전하게 하려면 <code>git push --force-with-lease</code>)를 써서 기존의 내용을 덮어써야 하므로, 기존의 내용을 공유하고 있던 공동 작업자가 있는 환경에서는 뒷처리가 복잡하다.</p><p>따라서 가급적 과거의 이력을 바꾸기보다 그냥 현재 상태에 수정 사항을 적용하는 것이 바람직하지만, 그래도 꼭 해야겠다면 뭐.. 해야지.</p><h2 id="큰-흐름"><a href="#큰-흐름" class="headerlink" title="큰 흐름"></a>큰 흐름</h2><p>작업의 큰 흐름은 다음과 같다.</p><ul><li>수정하려는 커밋의 바로 이전 커밋을 base로 다시(re) 설정, 즉 rebase 한다.</li><li>내용을 수정하고 <code>git add</code>, <code>commit --amend</code>로 커밋도 수정한다.</li><li>git rebase –continue로 마무리.</li><li>rebase 완료 후에는 수정한 커밋 이후의 커밋들도 새로운 커밋번호가 할당되어, 수정 커밋 및 그 이후의 커밋들은 사실 상 새로운 커밋이 된다.</li></ul><p>이 정도를 알아두고 실제 화면을 보며 이해해보자.</p><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>수정할 커밋을 확인하고, 바꾸려는 커밋의 바로 이전 커밋을 <code>git rebase --interactive</code>의 target으로 지정한다.</p><p><img src="http://i.imgur.com/i5vxEeR.png" alt="Imgur"></p><h2 id="git-rebase-–interactive"><a href="#git-rebase-–interactive" class="headerlink" title="git rebase –interactive"></a>git rebase –interactive</h2><p><code>git rebase --interactive</code>를 실행하면 다음과 같은 화면이 표시된다.</p><p><img src="http://i.imgur.com/gM3SKOb.png" alt="Imgur"></p><p>아래와 같이 수정할 커밋에 <code>pick</code>라고 표시된 것을 <code>edit</code>로 수정한다.</p><p><img src="http://i.imgur.com/keN0obw.png" alt="Imgur"></p><p>저장하면 다음과 같이 수정 후 <code>commit --amend</code>, <code>rebase --continue</code>를 실행하라는 간단한 안내가 표시된다.</p><p><img src="http://i.imgur.com/1skcCKh.png" alt="Imgur"></p><h2 id="원하는-커밋의-내용-수정"><a href="#원하는-커밋의-내용-수정" class="headerlink" title="원하는 커밋의 내용 수정"></a>원하는 커밋의 내용 수정</h2><p>다음과 같이 수정하기를 원했던 파일을 열어서 수정한다.</p><p><img src="http://i.imgur.com/5pdes49.png" alt="Imgur"></p><h2 id="git-add-amp-git-commit-–amend"><a href="#git-add-amp-git-commit-–amend" class="headerlink" title="git add . &amp; git commit –amend"></a>git add . &amp; git commit –amend</h2><p>수정 후 <code>git status</code>로 확인하면 다음과 같이 표시된다. 수정한 파일을 add 하고,</p><p><img src="http://i.imgur.com/PgCqApP.png" alt="Imgur"></p><p><code>git commit --amend</code>로 수정 내용을 커밋한다.</p><p><img src="http://i.imgur.com/wlJ1vF5.png" alt="Imgur"></p><p>커밋하면 다음과 같이 커밋 내용에 대한 화면이 표시된다.</p><p><img src="http://i.imgur.com/SeRegph.png" alt="Imgur"></p><h2 id="git-rebase-–continue"><a href="#git-rebase-–continue" class="headerlink" title="git rebase –continue"></a>git rebase –continue</h2><p><code>:q!</code>를 입력해서 빠져 나온 후, <code>git rebase --continue</code>를 실행한다.</p><p><img src="http://i.imgur.com/YjvA2DA.png" alt="Imgur"></p><p>다음과 같이 성공 메시지가 표시된다.</p><p><img src="http://i.imgur.com/f6M9egA.png" alt="Imgur"></p><h2 id="히스토리-확인"><a href="#히스토리-확인" class="headerlink" title="히스토리 확인"></a>히스토리 확인</h2><p>히스토리를 확인해보면, 다음과 같이 내용은 동일하지만 rebase의 target으로 지정했던 ‘수정한 커밋 바로 이전 커밋’에서 분기되어 새로운 커밋들이 master 브랜치에 생겨난 것을 확인할 수 있다.</p><p><img src="http://i.imgur.com/8tuDiq6.png" alt="Imgur"></p><p>git log로 확인해보면 수정한 커밋 바로 이전 커밋의 번호는 그대로지만, 수정한 커밋부터 그 이후의 커밋은 모두 커밋 번호가 달라져있음을 확인할 수 있다. 하지만 커밋 메시지나 커밋 시간은 바꾸지 않았으므로 예전과 동일하다.</p><p><img src="http://i.imgur.com/339qZF6.png" alt="Imgur"></p><p>git status로 확인해봐도 수정한 커밋을 포함하여 그 이후 5개의 커밋이 origin/master와 달라져있다는, 위의 히스토리 및 로그와 동일한 내용을 확인할 수 있다.</p><p><img src="http://i.imgur.com/qckdlTs.png" alt="Imgur"></p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>이 상태에서 <code>git push</code>를 실행하면 거절된다.</p><p><img src="http://i.imgur.com/nXKC1wl.png" alt="Imgur"></p><p>그렇다고 <code>git fetch</code> 후 <code>git rebase</code> 또는 <code>git merge</code>를 하면, 원래의 목적인 ‘특정 커밋만 수정하기’는 수포로 돌아간다.</p><p>방법은 <code>git push --force</code>로 특정 커밋만 수정한 내 로컬 버전을 원격에 강제로 덮어쓰는 방법 밖에는 없다. 조금이라도 더 안전하게 작업하려면, 덮어쓰기 전에 로컬의 <code>remotes/브랜치A</code>가 참조하고 있는 것과 현재 원격의 <code>브랜치A</code>가 참조하고 있는 내용이 동일할 경우에만, 즉, 다른 누군가가 원격의 <code>브랜치A</code>에 push를 하지 않은 상태에서만 <code>git push --force</code>를 실행하는 <code>git push --force-with-lease</code>를 실행할 수도 있다. </p><p>하지만 새로운 내용으로 기존 내용을 덮어쓴다는 것 자체는 동일하며, 이 경우 처음에 얘기한 것처럼 공동 작업자에게는 불필요한 일거리를 넘겨주게 된다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><blockquote><ul><li><p>특정 커밋만을 수정해야 한다면, <code>git rebase --interactive</code>로 하면된다.</p></li><li><p>다만 공동작업자가 있다면 미리 해당 내용을 공유하고 뒤처리를 최소화 할 수 있는  계획을 수립한 후에 진행한다.</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;과거의 특정 커밋에 포함된 내용을 수정해야할 때가 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt;를 사용하면 가능하기는 한데, 수정 후 remote에 올릴 때 결국 &lt;code&gt;git push --force&lt;/code&gt;(또는 조금이라
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Git" scheme="http://homoefficio.github.io/tags/Git/"/>
    
      <category term="rebase" scheme="http://homoefficio.github.io/tags/rebase/"/>
    
  </entry>
  
  <entry>
    <title>Java8 람다 관련 스펙 정리</title>
    <link href="http://homoefficio.github.io/2017/02/19/Java8-%EB%9E%8C%EB%8B%A4-%EA%B4%80%EB%A0%A8-%EC%8A%A4%ED%8E%99-%EC%A0%95%EB%A6%AC/"/>
    <id>http://homoefficio.github.io/2017/02/19/Java8-람다-관련-스펙-정리/</id>
    <published>2017-02-19T12:23:05.000Z</published>
    <updated>2018-10-13T15:49:56.236Z</updated>
    
    <content type="html"><![CDATA[<p>자바는 아직 함수가 독립적으로 어떤 값에 할당되거나, 어떤 함수의 인자로 사용되거나, 반환값으로 사용될 수 없다. </p><p>대신에 Java8에서부터는 추상 메서드를 한 개만 가지고 있는 함수형 인터페이스라는 것을 언어의 기능으로 추가해서 할당, 인자 또는 반환에 사용하고, 함수형 인터페이스의 자리에 람다식이나 메서드 레퍼런스를 사용할 수 있게 해서, 간접적이지만 실질적으로 람다식이나 메서드 레퍼런스를 할당, 인자, 반환에 사용될 수 있게 했다.</p><p>어떤 A가 사용되는 곳에 A와는 다른 어떤 B가 사용되려면, B는 A에 대해 어떤 형태로든 호환성이 있어야 한다. 같은 맥락으로 람다나 메서드 레퍼런스가 함수형 인터페이스가 들어갈 자리에 들어가서 대신 사용되려면, 일종의 타입 비교 같은 호환성 체크가 필요하다. </p><p>그렇다면 무엇을 기준으로 타입을 정해서 비교할 수 있을까?</p><p>자바 가상머신 스펙(JVMS)에는 <code>메서드 시그너처</code>라는 용어가 있고, 자바 언어 스펙(JLS)에는 <code>메서드 시그너처(signature)</code>, <code>메서드 디스크립터(descriptor)</code>, <code>메서드 타입</code>, <code>함수 타입</code>이라는, 뭔가 타입을 정할 목적으로 사용되는 것 같은 용어가 여러가지 등장하는데, 일단 결론적으로 <strong>호환성 검사를 하는데 필요한 기본 정보는 메서드 타입과 함수 타입이다</strong>.</p><p>메서드 시그너처나 메서드 디스크립터는 나중에 <a href="https://github.com/HomoEfficio/dev-tips/blob/master/%EC%9A%95%20%EB%82%98%EC%98%A4%EB%8A%94%20%EC%9E%90%EB%B0%94%20%EC%8A%A4%ED%8E%99%20-%20%EB%A9%94%EC%84%9C%EB%93%9C%20%EC%8B%9C%EA%B7%B8%EB%84%88%EC%B2%98.md" target="_blank" rel="noopener">여기</a>를 참고하는 걸로 하고 지금은 일단 넘어가자. 먼저 람다와 메서드 레퍼런스의 타입 기준이 되는 <code>메서드 타입</code>부터 알아보자. </p><h2 id="메서드-타입"><a href="#메서드-타입" class="headerlink" title="메서드 타입"></a>메서드 타입</h2><p><code>메서드 타입</code>, 즉, 메서드의 타입은 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.2" target="_blank" rel="noopener">JLS 8.2</a>에 기술되어 있다.</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.2" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.2</a></p><p>For a method, an ordered 4-tuple consisting of:</p><ul><li><p><strong>type parameters</strong>: the declarations of any type parameters of the method member.</p></li><li><p><strong>argument types</strong>: a list of the types of the arguments to the method member.</p></li><li><p><strong>return type</strong>: the return type of the method member.</p></li><li><p><strong>throws clause</strong>: exception types declared in the throws clause of the method member.</p></li></ul><p>(대략) 메서드의 타입은 <strong>타입 파라미터</strong>, <strong>인자 타입</strong>, <strong>반환 타입</strong>, <strong>예외 타입</strong>으로 구성된다.</p></blockquote><p>일단 쉽게 생각해서 <strong>‘타입 파라미터, 인자 타입, 반환 타입, 예외 타입, 이렇게 4가지의 정보가 메서드의 타입을 결정한다.’</strong>라고 이해하자.</p><h2 id="함수-타입"><a href="#함수-타입" class="headerlink" title="함수 타입"></a>함수 타입</h2><p>메서드의 타입을 <code>메서드 타입</code>으로 규정할 수 있다면, 함수형 인터페이스의 어떤 타입과 비교할 수 있을 것이다. 그 어떤 타입이 무엇일까? 이에 대한 답이 바로 <code>함수 타입(Function type)</code>, 구체적으로는 함수형 인터페이스의 함수 타입(Function type of a functional interface)이다.</p><p><code>함수 타입</code>은 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.9" target="_blank" rel="noopener">JLS 9.9</a>에 기술되어 있다.</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.9" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.9</a></p><p>The function type of a functional interface I is a method type (§8.2) that can be used to override (§8.4.8) the abstract method(s) of I.</p><p>(대략) 함수형 인터페이스 I의 함수 타입은 I의 추상 메서드를 override 하는데 사용되는 메서드 타입을 의미한다.</p><p>The function type of I consists of the following:</p><ul><li><p>Type parameters, formal parameters, and return type:</p><p> (중략)</p></li><li><p>throws clause:</p><p> (중략)</p></li></ul></blockquote><p>뭔가 구구절절 설명이 더 있는데, 쉽게 요약하면 <code>함수 타입</code>의 구성 요소도 <code>메서드 타입</code>의 구성 요소와 같이 다음의 4가지다.</p><ul><li>타입 파라미터</li><li>인자 타입</li><li>반환 타입</li><li>예외 타입</li></ul><p>함수 타입의 기준까지는 비교적 간단한데, 실제 함수 타입을 구하는 과정은 여러 케이스에 대해 구체적이고 복잡하고 방대한 내용이 펼쳐진다. 여기서 더 나아가면 추론(Inference) 및 제네릭(Generic)에 대한 전반적인 지식이 필요하므로 자세한 설명은.. 여러가지 이유로.. 생략하기로..(하아.. 이렇게 맘이 편할 수가..)</p><p>함수 타입을 구하는 자세한 절차와 방법이 궁금하다면 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.9" target="_blank" rel="noopener">여기</a>를 참고하고, 여기에서는 스펙에 나와있는 <code>함수 타입</code> 예제 하나만 구경해보고 넘어가자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">G1</span> </span>&#123;</span><br><span class="line">    &lt;E extends Exception&gt; <span class="function">Object <span class="title">m</span><span class="params">()</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">G2</span> </span>&#123;</span><br><span class="line">    &lt;F extends Exception&gt; <span class="function">String <span class="title">m</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">G</span> <span class="keyword">extends</span> <span class="title">G1</span>, <span class="title">G2</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>일 때, <code>G</code>의 함수 타입은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;F extends Exception&gt; ()-&gt;String <span class="keyword">throws</span> F</span><br></pre></td></tr></table></figure><p>이처럼 함수 타입은 실제로 스펙에도 <code>&lt;F extends Exception&gt; ()-&gt;String throws F</code>와 같은 형식으로 기술하고 있는데, </p><p><code>&lt;타입 파라미터&gt;</code>, <code>(인자 타입)</code>, <code>-&gt; 반환 타입</code>, <code>throws 예외 타입</code>, 이렇게 생김새만 봐도 4가지 구성 요소로 이루어져있다는 걸 알 수 있다.</p><h2 id="람다식-타입"><a href="#람다식-타입" class="headerlink" title="람다식 타입"></a>람다식 타입</h2><p>람다식의 타입(Type of a lambda expression)은 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3" target="_blank" rel="noopener">JLS 15.27.3</a>에 기술되어 있다.</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3</a></p><p>A lambda expression is compatible in an assignment context, invocation context, or casting context with a target type T if T is a functional interface type (§9.8) and the expression is congruent with the function type of the ground target type derived from T.</p><p>(대략) 어떤 람다식이, 함수형 인터페이스 T에서 유도된 ground target type의 함수 타입과 합동(congruent)이면, 그 람다식은 할당, 호출, 캐스팅에 대해 함수형 인터페이스 T와 호환된다.</p></blockquote><p>대략 써도 알아먹기 쉽지 않은데, 일단 욕 해주고 싶은 부분은 람다식의 타입에 대한 정의나 람다식의 타입은 어떤 요소로 구성되는 설명도 없이, 합동이면 콜~ 이라고 얘기하고는 합동 조건에 대해 설명을 이어간다는 점이다.</p><p>암튼 완전히 정확하지는 않더라도 쉬운 이해를 위해 단순화하면, <strong>람다식은 언어적으로 타입 파라미터를 사용할 수 없으므로, 결국 인자 타입과 반환 타입, 예외 타입으로 함수형 인터페이스와의 호환성을 검사</strong>할 수 있다.</p><h2 id="메서드-레퍼런스-타입"><a href="#메서드-레퍼런스-타입" class="headerlink" title="메서드 레퍼런스 타입"></a>메서드 레퍼런스 타입</h2><p>메서드 레퍼런스의 타입(Type of a method reference expression)은 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.13.2" target="_blank" rel="noopener">JLS 15.13.2</a>에 기술되어 있다.</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.13.2" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.13.2</a></p><p>A method reference expression is compatible in an assignment context, invocation context, or casting context with a target type T if T is a functional interface type (§9.8) and the expression is congruent with the function type of the ground target type derived from T.</p><p>(대략) 어떤 메서드 레퍼런스식이, 함수형 인터페이스 T에 유도된 ground target type의 함수 타입과 합동이면, 그 메서드 레퍼런스식은 할당, 호출, 캐스팅에 대해 함수형 인터페이스 T와 호환된다.</p></blockquote><p>람다식의 타입과 거의 비슷한 설명이다. 메서드 레퍼런스의 정의나 구성 요소에 대한 내용은 역시나 없다. 메서드 레퍼런스가 결국은 메서드를 지칭하는 것이므로, 메서드 레퍼런스의 타입은 결국 <code>메서드 타입</code>과 같다고 봐도 무방할 것 같다. 따라서 <strong>메서드 레퍼런스식은 타입 파라미터, 인자 타입, 반환 타입, 예외 타입으로 구성</strong>된다고 할 수 있겠다.</p><h2 id="호환성-비교"><a href="#호환성-비교" class="headerlink" title="호환성 비교"></a>호환성 비교</h2><p>자 이제 람다와 메서드 레퍼런스의 <code>메서드 타입</code>과 함수형 인터페이스의 <code>함수 타입</code>이 호환성 비교의 기준이라는 건 알게 되었다. 이제 실질적인 호환성 비교, 그러니까 합동(congruent) 여부를 검사하는 과정을 알아보자. congruent와 함께 ground target type이라는 용어도 나왔는데, 이것부터 먼저 알아보자.</p><h3 id="ground-target-type-derived-from-functional-interface"><a href="#ground-target-type-derived-from-functional-interface" class="headerlink" title="ground target type derived from functional interface"></a>ground target type derived from functional interface</h3><p>람다 또는 메서드 레퍼런스와 함수형 인터페이스가 합동적(congruent)인지, 즉 람다나 메서드 레퍼런스가 어떤 함수형 인터페이스의 자리에 들어가서 사용될 수 있는지 판별하는데 기준이 되는 인터페이스의 타입을 말한다.</p><p>좀 쉽게 얘기하면, </p><ul><li><code>interface I</code>나 <code>interface I&lt;Integer&gt;</code>와 같이 와일드카드 파라미터를 사용하지 않는 함수형 인터페이스의 ground target type은 <code>I</code>이고, </li><li><code>I&lt;? extends P&gt;</code>와 같이 와일드카드를 사용하는 파라미터화 된 함수형 인터페이스의 ground target type은, 스펙에 정해진 방법으로 <code>?</code>를 예를 들어 <code>S</code>로 구체화 했을 때 <code>I&lt;S&gt;</code>가 된다.</li><li>람다나 메서드 레퍼런스의 사용을 위한 실질적인 타입 비교는, 이 <code>I</code>나 <code>I&lt;S&gt;</code>의 함수 타입이 사용된다.</li></ul><p>간단한 설명을 위해 일단 이제부터는 함수형 인터페이스에서 유도된 ground target type은 그냥 함수형 인터페이스의 타입과 같다고 간주하고, ‘ground target type의 함수 타입’을 그냥 ‘함수 타입’이라고 칭하기로 하자(이렇게해도 틀리는 것은 아니다. 두 가지 중 간단한 것 하나만 취하고 나머지는 간단한 설명을 위해 배제했을 뿐이다).</p><p>이제 람다식과 메서드 레퍼런스와 함수 타입(정확하게는 ground target type의 함수 타입이지만)의 합동(즉, 호환됨)에 대해 차례대로 살펴보자.</p><h3 id="람다식-타입과-함수-타입의-합동"><a href="#람다식-타입과-함수-타입의-합동" class="headerlink" title="람다식 타입과 함수 타입의 합동"></a>람다식 타입과 함수 타입의 합동</h3><p>람다식 타입과 함수 타입의 합동은 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3" target="_blank" rel="noopener">JLS 15.27.3</a>에 설명되어 있다. 분량 상 원문 생략하고 간단하게 합동 조건을 요약하면,</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3</a></p><p>람다식 타입과 함수 타입이 합동이려면 다음의 모든 조건을 만족해야 한다.</p><ul><li><p>함수 타입에 타입 파라미터가 없어야 한다.</p></li><li><p>람다의 인자의 수는 함수 타입의 인자 타입의 수와 같아야 한다.</p></li><li><p>인자 타입이 명시된 람다식의 인자 타입은 함수 타입의 파라미터 타입과 같아야 한다.</p></li><li><p>람다식의 인자 타입이 함수 타입의 파라미터 타입과 같다고 간주되면,</p><ul><li>함수 타입의 결과값이 void 이면, 람다식의 body는 문장식이거나 void-호환 블럭이어야 한다.  </li><li>함수 타입의 결과값이 void가 아닌 R이라면,<ul><li>람다 body는 할당에 대해 R과 호환되는 식이거나,</li><li>람다 body는 값 호환이고, 각 결과식이 할당에 대해 R과 호환되어야 한다.</li></ul></li></ul></li></ul></blockquote><p>이 또한 크게 틀리지 않는 한에서 쉽게 풀어보면</p><blockquote><p>람다식 A가 함수형 인터페이스 B 대신 사용되려면, 다음 조건을 모두 만족해야 한다.</p><ul><li>B의 함수 타입에 타입 파라미터가 사용되고 있지 않아야 한다.</li><li>A의 인자 수와 B의 함수 타입의 인자 수가 같아야 한다.</li><li>A의 인자 타입과 B의 함수 타입의 인자 타입이 같아야 한다.<ul><li>A가 인자 타입이 명시되지 않은 람다라면, 인자의 타입 추론 결과가 B의 함수 타입의 인자 타입과 같아야 한다.</li></ul></li><li>A의 반환 타입은 B의 함수 타입의 반환 타입에 할당될 수 있어야 한다.</li></ul></blockquote><p>글로만 보면 별로 와닿지 않으니 코드로 요점만 짚어보면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer가 Object를 상속하고 있으므로</span></span><br><span class="line"><span class="comment">// Object obj = new Integer(3); 은 가능하지만,</span></span><br><span class="line"><span class="comment">// 아래와 같이 람다식의 인자 타입이 명시된 경우</span></span><br><span class="line"><span class="comment">// 함수 타입의 인자 타입과 람다식의 인자 타입은 할당 가능이 아니라 일치 해야만 한다.</span></span><br><span class="line">Consumer&lt;Object&gt; consumer1 = (Integer i) -&gt; System.out.println(i);  <span class="comment">// 컴파일 에러(Incompatible parameter type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 람다식의 인자 타입이 명시되지 않으면 추론에 의해 아래와 같은 람다 사용이 가능하다.</span></span><br><span class="line">Consumer&lt;Object&gt; consumer2 = (i) -&gt; System.out.println(i);  <span class="comment">// 이건 가능(i가 Object로 추론됨)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 람다식의 반환 타입 Integer은 Object에 할당가능하므로 아래와 같은 람다 사용이 가능하다.</span></span><br><span class="line">Callable&lt;Object&gt; callable1 = () -&gt; <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 타입의 반환 타입이 void인 Runnable에 statement expression이 아닌 단순한 값 3은 사용 불가</span></span><br><span class="line">Runnable runnable1 = () -&gt; <span class="number">3</span>;  <span class="comment">// 컴파일 에러(Bad return type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable의 함수 타입의 반환 타입은 void지만, statement expression에 해당하는 인스턴스 생성식은 사용 가능</span></span><br><span class="line">Runnable runnable2 = () -&gt; <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 타입에 타입 파라미터가 있는 경우 람다를 쓸 수 없다.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lister</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Lister lister = () -&gt; ...어쩌라고... <span class="comment">// 람다식은 언어 차원에서 타입 파라미터가 지원되지 않는다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 타입에 throws가 있는 경우</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WithThrows</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">makeTrouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 함수 타입에 throws IOException 이 있으므로</span></span><br><span class="line"><span class="comment">// 아래와 같이 body에서 IOException을 던지는 람다 사용 가능</span></span><br><span class="line">WithThrows withThrows1 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 함수 타입의 throws로 지정된 IOException을 상속한 EOFException을 던지는 람다도 사용 가능</span></span><br><span class="line">WithThrows withThrows2 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 함수 타입의 throws로 지정된 IOException을 상속하지 않은 예외를 던지는 람다는 사용 불가</span></span><br><span class="line">WithThrows withThrows3 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();  <span class="comment">// 컴파일 에러(Unhandled exception)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// body에서 Unchecked Exception을 던지는 람다는 함수 타입의 예외 타입과 관계 없이 사용 가능 </span></span><br><span class="line">WithThrows withThrows4 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// body에서 Unchecked Exception을 던지는 람다는 함수 타입에 throws 가 없더라도 사용 가능</span></span><br><span class="line">Runnable runnable3 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    System.out.println(<span class="string">"Unchecked Exception in a lambda body is OK"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="메서드-레퍼런스-타입과-함수-타입의-합동"><a href="#메서드-레퍼런스-타입과-함수-타입의-합동" class="headerlink" title="메서드 레퍼런스 타입과 함수 타입의 합동"></a>메서드 레퍼런스 타입과 함수 타입의 합동</h3><p>메서드 레퍼런스 타입과 함수 타입의 합동은 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.13.2" target="_blank" rel="noopener">JLS 15.13.2</a>에 설명되어 있다. 분량 상 원문 생략하고 간단하게 합동 조건을 요약하면,</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.13.2" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.13.2</a></p><p>메서드 레퍼런스 타입과 함수 타입이 합동이려면 다음의 모든 조건을 만족해야 한다.</p><ul><li><p>함수 타입이 컴파일 시점에 메서드 레퍼런스가 지칭하는 메서드의 선언부를 식별할 수 있어야 한다.</p></li><li><p>다음 둘 중의 하나가 참이어야 한다.</p><ul><li><p>함수 타입의 결과값이 void 여야 한다.</p></li><li><p>함수 타입의 결과값이 R이라면, 함수 타입이 컴파일 시점에 식별한 메서드 레퍼런스의 선언부에 명시된 결과값의 타입이 할당에 대해 R과 호환되어야 한다.</p></li></ul></li></ul></blockquote><p>역시 크게 틀리지 않는 선에서 쉽게 풀어보면</p><blockquote><p>메서드 레퍼런스 A가 함수형 인터페이스 B 대신 사용되려면, 다음 조건을 모두 만족해야 한다.</p><ul><li><p>B의 함수 타입이 컴파일 시점에 메서드 레퍼런스가 가리키는 메서드의 선언부를 식별할 수 있어야 한다.</p></li><li><p>함수 타입의 반환값이 void 이거나, </p></li><li>반환값이 void가 아니라면, 컴파일 시점에 메서드 레퍼런스가 가리키는 메서드 선언부에 명시된 반환 타입이 함수 타입의 반환 타입에 할당될 수 있어야 한다.</li></ul></blockquote><p>글로만 보면 별로 와닿지 않으니 역시 코드로 요점만 짚어보면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 타입의 반환 타입이 void이고, 메서드 레퍼런스의 반환 타입도 void</span></span><br><span class="line">Runnable runnable4 = System.out::println;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 타입의 반환 타입이 void이면, 반환 타입이 void가 아닌 메서드 레퍼런스도 사용 가능</span></span><br><span class="line">Integer integer2 = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">Runnable runnable6 = integer2::doubleValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 타입에 타입 파라미터가 있는 경우에도 메서드 레퍼런스 사용 가능</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lister</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Lister lister1 = ArrayList::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 타입의 반환 타입이 void가 아니고, 반환 타입이 함수 타입의 반환 타입에 할당 불가능한 레퍼런스는 사용 불가</span></span><br><span class="line">Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Callable&lt;Integer&gt; callable2 = integer1::doubleValue;  <span class="comment">// 컴파일 에러(Bad return type)</span></span><br><span class="line"><span class="comment">// 함수 타입의 반환 타입이 void가 아니고, 반환 타입이 함수 타입의 반환 타입에 할당 가능한 메서드 레퍼런스는 가능</span></span><br><span class="line">Callable&lt;Object&gt; callable3 = integer1::doubleValue;</span><br></pre></td></tr></table></figure><h2 id="람다와-메서드-레퍼런스의-차이"><a href="#람다와-메서드-레퍼런스의-차이" class="headerlink" title="람다와 메서드 레퍼런스의 차이"></a>람다와 메서드 레퍼런스의 차이</h2><p>둘 모두 타입이 맞으면 함수형 인터페이스가 사용될 자리에 들어갈 수 있다는 점은 같다.</p><p>하지만 메서드 레퍼런스는 타입 파라미터가 있는 제네릭 메서드를 대신해서 사용될 수 있는데, 람다는 타입 파라미터를 선언할 수 있는 문법이 지원되지 않으므로 제네릭 메서드를 대신해서 사용할 수 없다.</p><p>좀 추상적이니 구체적인 코드로 보면 다음과 같은 차이가 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ListFactory</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 람다는 이게 안된다</span></span><br><span class="line">ListFactory lf1 = () -&gt; <span class="keyword">new</span> ArrayList();  <span class="comment">// 컴파일 에러(Target method is generic)</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 메서드 레퍼런스는 이게 가능하다.</span></span><br><span class="line">ListFactory lf2  = ArrayList::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; ls = lf2.make();</span><br><span class="line">List&lt;Number&gt; ln = lf2.make();</span><br></pre></td></tr></table></figure><h2 id="람다의-void-호환성"><a href="#람다의-void-호환성" class="headerlink" title="람다의 void 호환성"></a>람다의 void 호환성</h2><p>람다의 void 호환성은 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3" target="_blank" rel="noopener">JLS 15.27.3</a>의 마지막 부분에 나와 있다.</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3</a></p><p>람다의 body가 statement expression이면, 그 람다의 반환 타입이 (무엇이든 상관없이) void인 함수 타입과 호환 된다.</p></blockquote><p>statement expression의 예는 다음과 같다.</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-StatementExpression" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-StatementExpression</a></p><ul><li><p>할당</p></li><li><p>전위덧셈(++a)</p></li><li><p>전위뺄셈(–a)</p></li><li><p>후위덧셈(a++)</p></li><li><p>후위뺄셈(a–)</p></li><li><p>메서드 호출</p></li><li><p>클래스 인스턴스 생성식(new 등..)</p></li></ul></blockquote><p>코드로 살펴보자면, 다음과 같은 일이 가능하다는 소리다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list.add()는 boolean을 반환하지만 메서드 호출이므로,</span></span><br><span class="line"><span class="comment">// 반환 타입이 void인 accept(T t) 메서드를 가진 Consumer&lt;T&gt;에 할당 가능</span></span><br><span class="line">Consumer&lt;String&gt; b = s -&gt; list.add(s);</span><br></pre></td></tr></table></figure><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><ul><li><p><strong>메서드의 타입</strong>은 <strong>타입 파라미터, 인자 타입, 반환 타입, 예외 타입</strong>으로 구성된다.</p></li><li><p><strong>함수 타입</strong>은 함수형 인터페이스 I의 함수 타입은 I의 추상 메서드를 override 하는데 사용되는 메서드 타입을 의미하며, <strong>함수 타입의 구성 요소는 메서드 타입의 구성 요소와 같다</strong>.</p></li><li><p>따라서 <strong>타입 파라미터, 인자 타입, 반환 타입, 예외 타입</strong>의 호환성 검사를 통해, 어떤 람다나 메서드 레퍼런스가 어떤 함수형 인터페이스 대신 사용될 수 있는지 판단할 수 있다.</p></li><li><p>타입 파라미터의 호환성</p><ul><li>함수 타입에 타입 파라미터가 있으면 람다는 호환되지 않고, 메서드 레퍼런스만 호환 가능하다.</li><li>타입 파라미터의 호환성은 제네릭을 참고한다. </li></ul></li><li><p>인자 타입의 호환성</p><ul><li><p>람다식의 인자 타입이 명시적이면, 함수 타입의 인자 타입과 동일해야 한다.</p></li><li><p>명시적이지 않은 인자 타입은 함수 타입의 인자 타입으로 추론될 수 있어야 한다.</p></li></ul></li><li><p>반환 타입의 호환성</p><ul><li><p>함수 타입의 반환 타입이 void가 아니면, 람다식이나 메서드 레퍼런스의 반환 타입이 함수 타입의 반환 타입에 할당 가능해야 한다.</p></li><li><p>함수 타입의 반환 타입이 void이면</p><ul><li><p>람다식의 body가 할당, 전위덧셈, 전위뺄셈, 전위덧셈, 전위뺄셈, 메서드호출, 클래스인스턴스생성, 이렇게 7개 중의 하나에 해당한다면 void 호환성이 적용된다.</p></li><li><p>메서드 레퍼런스는 반환 타입에 무관하게 호환된다.</p></li></ul></li></ul></li><li><p>예외 타입의 호환성</p><ul><li><p>람다식이나 메서드 레퍼런스에서 던져지는 예외 타입은 함수 타입의 예외 타입에 할당 가능해야 한다.</p></li><li><p>람다식이나 메서드 레퍼런스에서 사용되는 Unchecked 예외는 예외 타입 호환성과 무관하다.</p></li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;자바는 아직 함수가 독립적으로 어떤 값에 할당되거나, 어떤 함수의 인자로 사용되거나, 반환값으로 사용될 수 없다. &lt;/p&gt;
&lt;p&gt;대신에 Java8에서부터는 추상 메서드를 한 개만 가지고 있는 함수형 인터페이스라는 것을 언어의 기능으로 추가해서 할
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Java8" scheme="http://homoefficio.github.io/tags/Java8/"/>
    
      <category term="자바8" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%948/"/>
    
      <category term="JLS" scheme="http://homoefficio.github.io/tags/JLS/"/>
    
      <category term="Lambda" scheme="http://homoefficio.github.io/tags/Lambda/"/>
    
      <category term="Method Reference" scheme="http://homoefficio.github.io/tags/Method-Reference/"/>
    
      <category term="Functional Interface" scheme="http://homoefficio.github.io/tags/Functional-Interface/"/>
    
      <category term="Method Type" scheme="http://homoefficio.github.io/tags/Method-Type/"/>
    
      <category term="Function Type입" scheme="http://homoefficio.github.io/tags/Function-Type%EC%9E%85/"/>
    
      <category term="자바 스펙" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%8E%99/"/>
    
      <category term="람다" scheme="http://homoefficio.github.io/tags/%EB%9E%8C%EB%8B%A4/"/>
    
      <category term="메서드 레퍼런스" scheme="http://homoefficio.github.io/tags/%EB%A9%94%EC%84%9C%EB%93%9C-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4/"/>
    
      <category term="함수형 인터페이스" scheme="http://homoefficio.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
      <category term="메서드 타입" scheme="http://homoefficio.github.io/tags/%EB%A9%94%EC%84%9C%EB%93%9C-%ED%83%80%EC%9E%85/"/>
    
      <category term="함수 타입" scheme="http://homoefficio.github.io/tags/%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85/"/>
    
  </entry>
  
  <entry>
    <title>Blocking-NonBlocking-Synchronous-Asynchronous</title>
    <link href="http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/"/>
    <id>http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/</id>
    <published>2017-02-19T04:16:32.000Z</published>
    <updated>2018-10-13T15:49:56.182Z</updated>
    
    <content type="html"><![CDATA[<p>꽤 자주 접하는 용어다. 특히나 요즘들어 더 자주 접하게 되는데, 얼추 알고는 있고 알고 있는게 틀린 것도 아니지만, 막상 명확하게 구분해서 설명하라면 또 만만치가 않은..</p><p>그래서 찾아보면 또 대충 뭔소린지 알아들을 것 같다가도, 구분해서 설명하라면 머뭇거리게 되긴 마찬가지다.</p><p>자료마다 미세하나마 조금씩 차이가 있는 것들도 많아서, 정확하고 유일한 구분법은 사실 없는 것 같다. 그리고 이렇게라도 꼭 구분해야만 하는 것인가 하는 생각도 들지만, 그래도 ‘나의 언어로 구분하고 설명해보는 것’을 목표로 한 번 정리해보자.</p><h1 id="IBM-developerWorks의-2-2-매트릭스"><a href="#IBM-developerWorks의-2-2-매트릭스" class="headerlink" title="IBM developerWorks의 2:2 매트릭스"></a>IBM developerWorks의 2:2 매트릭스</h1><p>이 주제로 자료를 찾아본 사람들은 아마 아래의 그림을 한 번쯤은 봤을 것이다.</p><p><img src="https://www.ibm.com/developerworks/library/l-async/figure1.gif" alt="IBM developerWorks의 단순화된 리눅스 I/O 모델 매트릭스"></p><p>위 그림만으로도 딱 와닿는다면 이미 Blocking-NonBlocking-Synchronous-Asynchronous의 구분에 대한 감이 있다고 볼 수 있으므로, 이 글은 더 이상 읽을 필요가 없다. ^^</p><p>와닿지 않는다면 조금 더 읽어보자. 하지만 앞으로 전개될 내용을 보면서, 이젠 너무 오래되어 버린 위의 IBM 그림(특히 I/O Multiplexing이 Blocking-Async로 구분되어 있는 점)에 구애 받을 필요는 없다. </p><h1 id="익숙한-것"><a href="#익숙한-것" class="headerlink" title="익숙한 것"></a>익숙한 것</h1><p>일단 대충 알기로 Blocking과 Synchronous 둘이 비슷하고, Non-blocking과 Asynchronous 둘이 비슷하다. 그래서 대부분 아래 그림이 표시하는 개념을 알고 있다.</p><p><img src="http://i.imgur.com/iSafBIF.png" alt="Imgur"></p><p>익숙해서 그런지 구체적인 예도 비교적 쉽게 떠올릴 수 있다.</p><p><img src="http://i.imgur.com/06P0Q6m.png" alt="Imgur"></p><h1 id="낯선-것"><a href="#낯선-것" class="headerlink" title="낯선 것"></a>낯선 것</h1><p>비슷해 보이는 것 둘씩 묶어보는 건 앞에서 살펴본 것처럼 꽤나 익숙하다. 문제는 비슷해 보이지 않는 걸 둘씩 묶어보는 건데, 이건 사례는 둘째치고 그림조차 잘 그려지지 않는다. </p><p>먼저 Sync-NonBlocking을 생각해보자. 사실 Sync는 Blocking과 비슷한데, Blocking의 반대인 NonBlocking이랑 공존한다는 것 자체가 성립이 안되는 거 아닌가?</p><p>Async-Blocking도 마찬가지다. Async는 NonBlocking과 비슷한데, NonBlocking의 반대인 Blocking이랑 공존한다는 것 자체가 성립이 안되는 거 아닌가?</p><h1 id="다른-관심사"><a href="#다른-관심사" class="headerlink" title="다른 관심사"></a>다른 관심사</h1><p>Blocking-Sync가 비슷하고, NonBlocking-Async가 비슷하지만, Blocking/NonBlocking과 Sync/Async이 2:2 매트릭스 그림에서 각각 다른 축에 자리잡는 데는 이유가 있다. 두 그룹은 관심사가 다르다. </p><h2 id="Blocking-NonBlocking"><a href="#Blocking-NonBlocking" class="headerlink" title="Blocking/NonBlocking"></a>Blocking/NonBlocking</h2><blockquote><p><strong>Blocking/NonBlocking은 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사</strong>다. </p></blockquote><p>호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 NonBlocking이다.</p><p>그렇지 않고 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 Blocking이다.</p><h2 id="Synchronous-Asynchronous"><a href="#Synchronous-Asynchronous" class="headerlink" title="Synchronous/Asynchronous"></a>Synchronous/Asynchronous</h2><blockquote><p><strong>Synchronous/Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사</strong>다.</p></blockquote><p>호출되는 함수에게 callback을 전달해서, 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않으면 Asynchronous다.</p><p>호출하는 함수가 호출되는 함수의 작업 완료 후 리턴을 기다리거나, 또는 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수 스스로 계속 확인하며 신경쓰면 Synchronous다.</p><h1 id="비슷한-동작-다른-관심사"><a href="#비슷한-동작-다른-관심사" class="headerlink" title="비슷한 동작, 다른 관심사"></a>비슷한 동작, 다른 관심사</h1><p>앞에서 막연하게 비슷하다고 했던 것은 조금 구체적으로 말하면 동작이 비슷한 것이었다. Blocking이나 Sync는 막거나 기다리거나 하는 등 둘 모두 뭔가 비효율적으로 동작하는 느낌인 반면에, NonBlocking이나 Async는 막지도 않고 완료되면 알아서 처리하는 등 둘 모두 뭔가 효율적으로 동작하는 느낌이다.</p><p>이제 동작은 비슷하지만 관심사가 다르다는 점을 염두에 두고 낯선 조합을 살펴보자.</p><h2 id="NonBlocking-Sync"><a href="#NonBlocking-Sync" class="headerlink" title="NonBlocking-Sync"></a>NonBlocking-Sync</h2><p>앞에서 살펴본대로 조합해보면 NonBlocking-Sync는 호출되는 함수는 바로 리턴하고, 호출하는 함수는 작업 완료 여부를 신경쓰는 것이다. 신경쓰는 방법이 기다리거나 물어보거나 두 가지가 있었는데, NonBlocking 함수를 호출했다면 사실 기다릴 필요는 없고 물어보는 일이 남는다. </p><p>즉, NonBlocking 메서드 호출 후 바로 반환 받아서 다른 작업을 할 수 있게 되지만, 메서드 호출에 의해 수행되는 작업이 완료된 것은 아니며, 호출하는 메서드가 호출되는 메서드 쪽에 작업 완료 여부를 계속 문의한다. </p><p>그림을 그려보면 다음과 같다.</p><p><img src="http://i.imgur.com/a8xZ9No.png" alt="Imgur"></p><p>이런 케이스가 뭐가 있을까 생각해보니 <code>future.isDone()</code>이 이것과 비슷한 것 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future ft = asyncFileChannel.read(~~~);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!ft.isDone()) &#123;</span><br><span class="line">    <span class="comment">// isDone()은 asyncChannle.read() 작업이 완료되지 않았다면 false를 바로 리턴해준다.</span></span><br><span class="line">    <span class="comment">// isDone()은 물어보면 대답을 해줄 뿐 작업 완료를 스스로 신경쓰지 않고,</span></span><br><span class="line">    <span class="comment">//     isDone()을 호출하는 쪽에서 계속 isDone()을 호출하면서 작업 완료를 신경쓴다.</span></span><br><span class="line">    <span class="comment">// asyncChannle.read()이 완료되지 않아도 여기에서 다른 작업 수행 가능 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 작업이 완료되면 작업 결과에 따른 다른 작업 처리</span></span><br></pre></td></tr></table></figure><p>참고로 위 코드는 NonBlocking-Sync라는 특성 이해에 집중할 수 있도록 간략화한 예제고, 실무적으로는 <code>Future</code>보다는 <code>CompletableFuture</code>를 쓰거나, <code>Future</code>를 쓴다면 위의 while 블록은 별도의 쓰레드로 빼서 실행하는 것이 좋다.</p><h2 id="Blocking-Async"><a href="#Blocking-Async" class="headerlink" title="Blocking-Async"></a>Blocking-Async</h2><p>이제 마지막 조각인 Blocking-Async다.</p><p>앞에서 살펴본대로 조합해보면 Blocking-Async는 호출되는 함수가 바로 리턴하지 않고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않는 것이다.</p><p>그림을 그려보면 다음과 같다.</p><p><img src="http://i.imgur.com/zKF0CgK.png" alt="Imgur"></p><p>이런 사례는 사실 생각해봐도 금방 떠오르는 게 없다. 어차피 Blocking되어 대기하는 것 외에는 다른 일도 못 하게된 마당에, 그냥 작업 끝날 때까지 기다렸다가 결과를 반환 받아서 처리하는 Blocking-Sync 방식과 성능적으로 거의 차이가 나지 않을 것 같은 방식이라서가 아닐까..</p><p>글을 올리고 보니 다른 분께서 좋은 의견을 주셨다. Blocking-Async는 별로 이점이 없어서 일부러 이 방식을 사용할 필요가 없기는 한데, 의도하지 않게 Blocking-Async로 동작하는 경우가 있다고 한다. 원래는 NonBlocking-Async를 추구하다가 의도와는 다르게 실제로는 Blocking-Async가 되어버리는 경우라고 하는데 그것은 바로..</p><p><strong>Blocking-Async의 대표적인 케이스가 Node.js와 MySQL의 조합</strong>이라고 한다.</p><p>Node.js 쪽에서 callback 지옥을 헤치면서 Async로 전진해와도, 결국 DB 작업 호출 시에는 MySQL에서 제공하는 드라이버를 호출하게 되는데, 이 드라이버가 Blocking 방식이라고 한다. </p><p>이건 사실 Node.js 뿐아니라 Java의 JDBC도 마찬가지다. 다만 Node.js가 싱글 쓰레드 루프 기반이라 멀티 쓰레드 기반인 Java의 Servlet 컨테이너보다 문제가 더 두드러져 보일 뿐, Blocking-Async라는 근본 원인은 같다.</p><p>그래서 Blocking-Async는 이렇게 정리해도 좋을 것 같다.</p><blockquote><p>Blocking-Async는 별다른 장점이 없어서 일부러 사용할 필요는 없지만, </p><p><strong>NonBlocking-Async 방식을 쓰는데 그 과정 중에 하나라도 Blocking으로 동작하는 놈이 포함되어 있다면 의도하지 않게 Blocking-Async로 동작</strong>할 수 있다.</p></blockquote><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><ul><li><p><strong>Blocking/NonBlocking은 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사</strong></p><ul><li>바로 리턴하지 않으면 Blocking</li><li>바로 리턴하면 NonBlocking</li></ul></li><li><p><strong>Synchronous/Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사</strong></p><ul><li>함수의 작업 완료를 호출한 함수가 신경쓰면 Synchronous</li><li>함수의 작업 완료를 호출된 함수가 신경쓰면 Asynchronous</li></ul></li><li><p>성능 상으로 가장 유리한 모델은 Async-NonBlocking 모델이다.</p></li></ul></blockquote><p><img src="http://i.imgur.com/gKDoKbs.png" alt="Imgur"></p><h1 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h1><p>공유하면 좋은 건 피드백을 받을 수 있다는 것이다.</p><p>Nonblocking과 Async를 관심사 관점이 아니라 다음과 같이 동작 관점에서도 구분할 수 있다는 좋은 의견도 있었다.</p><blockquote><ul><li><p>NonBlocking은 제어문 수준에서 지체없이 반환하는 것</p></li><li><p>Asynchronous는 별도의 쓰레드로 빼서 실행하고, 완료되면 호출하는 측에 알려주는 것</p></li></ul></blockquote><p>다음과 같이 입장(?)을 통해 구분한다는 의견도 좋아 보인다.</p><blockquote><ul><li>Blocking/NonBlocking은 호출한 입장에서의 특징</li><li>Sync/Async는 처리되는 방식의 특징</li></ul></blockquote><h2 id="I-O-Multiplexing"><a href="#I-O-Multiplexing" class="headerlink" title="I/O Multiplexing"></a>I/O Multiplexing</h2><p>아래 댓글에도 있지만, 페북 등 다른 채널을 통해서도 역시나 I/O Multiplexing에 대한 피드백이 많았다. 사실 어느 정도 예상을 하고 의도적으로 I/O Multiplexing에 대한 언급을 하지 않았는데, 그로 인해 오히려 의도하지 않은 부작용이 있는 것 같아서 지금이라도 언급을 하고 넘어가는 것이 좋을 것 같다.</p><p>결론부터 말하면, I/O Multiplexing이 IBM의 그림에서 Blocking-Async로 분류되어 있는 것에 동의하지 않는다.</p><p>일단 범위를 작게 해서 I/O Multiplexing 중에서 <code>select()</code> 호출 부분에만 국한해서 살펴보자.<br><a href="http://man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="noopener">리눅스 man페이지의 select</a>의 description에는 아래와 같이 기술되어 있다.</p><blockquote><p>select() and pselect() allow a program to monitor multiple file<br>descriptors, <strong>waiting</strong> until one or more of the file descriptors become<br>“ready” for some class of I/O operation (e.g., input possible).  A<br>file descriptor is considered ready if it is possible to perform a<br>corresponding I/O operation (e.g., read(2) without blocking, or a<br>sufficiently small write(2))</p><p>(대략) 하나 이상의 fd가 ready 상태가 될 때까지 wating, 즉, 기다린다. </p></blockquote><p>이렇게 보면 <strong>OS 수준에서 <code>select()</code> 자체는 기다리는 Sync 방식</strong>이라고 할 수 있다.</p><p>그럼 Blocking/NonBlocking은 어느쪽이냐 하는 문제가 남는데, 이는 구현에 따라 달라진다. Java를 예로 들면 API 문서에 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Selector.html#select--" target="_blank" rel="noopener">select()</a>는 Blocking 방식이라고 기술되어 있으며, <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Selector.html#selectNow--" target="_blank" rel="noopener">selectNow()</a>는 NonBlocking 방식이라고 기술되어 있다.</p><p>따라서 <strong>I/O Multiplexing 중에서 select의 호출만을 떼어서 말하면 일단 OS 수준에서 Sync 방식인 것은 자명하지만, Sync-Blocking인지 Sync-NonBlocking 인지는 구현 방식에 따라 달라지므로 어느 한 쪽이 맞다고 하기 어렵다</strong>.</p><p>하지만, 보통 I/O Multiplexing이라고 하면 미시적으로 select의 호출 부분만을 말하는 것이 아니라, select의 대상이 되는 channel과의 연계까지도 포함하여 언급하려는 의도가 있다고 볼 수 있다. 그리고 이 과정에서의 channel은 NonBlocking 채널을 말한다. </p><p>그 근거는 앞에서 인용한 리눅스 man 페이지의 내용 중에 ‘읽기에 대해 blocking이 없는 I/O 연산과, 충분히 작은 쓰기 I/O 연산을 수행할 수 있을 때, 해당 fd를 select 될 수 있는 ready 상태로 간주한다’는 내용이 있고, 실무적으로도 Java를 예로 들면 <code>channel.configureBlocking(false);</code>와 같이 채널을 NonBlocking으로 설정한다는 점이다.   </p><p>따라서 <strong>일반적으로 I/O Multiplexing은 Sync방식의 select와 NonBlocking 방식의 channel이 연계되는 Sync-NonBlocking 방식이라고 해도 틀리지 않게 된다</strong>.</p><h1 id="더-읽을-거리"><a href="#더-읽을-거리" class="headerlink" title="더 읽을 거리"></a>더 읽을 거리</h1><ul><li><a href="https://www.lightbend.com/blog/7-ways-washing-dishes-and-message-driven-reactive-systems" target="_blank" rel="noopener">https://www.lightbend.com/blog/7-ways-washing-dishes-and-message-driven-reactive-systems</a></li><li><a href="https://slipp.net/questions/367" target="_blank" rel="noopener">https://slipp.net/questions/367</a></li><li><a href="http://www.slideshare.net/unitimes/sync-asyncblockingnonblockingio" target="_blank" rel="noopener">http://www.slideshare.net/unitimes/sync-asyncblockingnonblockingio</a></li><li><a href="http://djkeh.github.io/articles/Boost-application-performance-using-asynchronous-IO-kor/" target="_blank" rel="noopener">http://djkeh.github.io/articles/Boost-application-performance-using-asynchronous-IO-kor/</a></li><li><a href="https://www.ibm.com/developerworks/library/l-async/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/library/l-async/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;꽤 자주 접하는 용어다. 특히나 요즘들어 더 자주 접하게 되는데, 얼추 알고는 있고 알고 있는게 틀린 것도 아니지만, 막상 명확하게 구분해서 설명하라면 또 만만치가 않은..&lt;/p&gt;
&lt;p&gt;그래서 찾아보면 또 대충 뭔소린지 알아들을 것 같다가도, 구
      
    
    </summary>
    
      <category term="Concepts" scheme="http://homoefficio.github.io/categories/Concepts/"/>
    
    
      <category term="IO" scheme="http://homoefficio.github.io/tags/IO/"/>
    
      <category term="Computer Science" scheme="http://homoefficio.github.io/tags/Computer-Science/"/>
    
      <category term="Blocking" scheme="http://homoefficio.github.io/tags/Blocking/"/>
    
      <category term="NonBlocking" scheme="http://homoefficio.github.io/tags/NonBlocking/"/>
    
      <category term="Synchronous" scheme="http://homoefficio.github.io/tags/Synchronous/"/>
    
      <category term="Asynchronous" scheme="http://homoefficio.github.io/tags/Asynchronous/"/>
    
      <category term="입출력" scheme="http://homoefficio.github.io/tags/%EC%9E%85%EC%B6%9C%EB%A0%A5/"/>
    
      <category term="넌블러킹" scheme="http://homoefficio.github.io/tags/%EB%84%8C%EB%B8%94%EB%9F%AC%ED%82%B9/"/>
    
      <category term="블러킹" scheme="http://homoefficio.github.io/tags/%EB%B8%94%EB%9F%AC%ED%82%B9/"/>
    
      <category term="동기" scheme="http://homoefficio.github.io/tags/%EB%8F%99%EA%B8%B0/"/>
    
      <category term="비동기" scheme="http://homoefficio.github.io/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/"/>
    
  </entry>
  
  <entry>
    <title>토비의-스프링-3장-템플릿</title>
    <link href="http://homoefficio.github.io/2017/01/28/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-3%EC%9E%A5-%ED%85%9C%ED%94%8C%EB%A6%BF/"/>
    <id>http://homoefficio.github.io/2017/01/28/토비의-스프링-3장-템플릿/</id>
    <published>2017-01-28T01:07:52.000Z</published>
    <updated>2018-10-13T15:49:56.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-03"><a href="#Chapter-03" class="headerlink" title="Chapter 03"></a>Chapter 03</h1><p>본 내용은 토비의 스프링 3 책의 내용을 정리한 것입니다.</p><p>토비의 스프링은 스프링 뿐아니라 객체 지향의 기본 원리, 테스팅, 예외 처리, 디자인 패턴 등 Java 개발자라면 반드시 알아야 하는 내용을 스토리 전개 방식으로 점진적으로 친절하게 설명해주는 명저입니다. </p><p>똑같은 내용으로 미국에서 영어로 출간되었다면 Jolt상을 받기에도 충분한 책이라고 생각합니다.</p><p>책의 절대적인 가격은 높아보이지만 웬만한 책 두어권 보는 것보다 이 한 권의 책을 여러번 보는 것이 비용 대비 효과가 훨씬 좋을 것입니다.<br>이 책을 읽고 아낄 수 있는 많은 시간, 높아질 몸값을 생각하면 충분히 투자할 가치가 있는 책입니다.</p><p><a href="http://www.acornpub.co.kr/book/toby-spring3-1-set" target="_blank" rel="noopener">http://www.acornpub.co.kr/book/toby-spring3-1-set</a></p><h2 id="DB-관련-자원-반납"><a href="#DB-관련-자원-반납" class="headerlink" title="DB 관련 자원 반납"></a>DB 관련 자원 반납</h2><p>DAO에서 DB Connection을 가져오는 부분을 DataSource 인터페이스로 분리하고, DataSource 구현체를 DI 받아오도록 개선했지만, JDBC 리소스의 반납 관련 예외 처리 코드가 여전히 DAO에 남아있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection c = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = getConnection();</span><br><span class="line">            ps = c.prepareStatement(<span class="string">"delete from users"</span>);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; ps.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; c.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultSet <span class="title">getAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection c = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = getConnection();</span><br><span class="line">            ps = c.prepareStatement(<span class="string">"select from users"</span>);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="keyword">return</span> rs;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; rs.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; ps.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; c.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="자원-반납-코드의-중복"><a href="#자원-반납-코드의-중복" class="headerlink" title="자원 반납 코드의 중복"></a>자원 반납 코드의 중복</h2><p>위와 같이 DAO 메서드마다 자원 반납 코드가 계속 중복된다.</p><p>그리고 DAO 메서드에는 다음과 같은 공통 흐름이 있다.</p><ol><li>dataSource에서 DB연결을 가져오고</li><li>쿼리 생성</li><li>쿼리 실행</li><li>예외 발생 시 던지기</li><li>모든 처리 후 자원 반납 처리</li></ol><p>여기에서 변하는 부분(전략)은 쿼리 생성, 나머지는 변하지 않는다(컨텍스트).</p><h3 id="전략-패턴을-통한-전략-분리"><a href="#전략-패턴을-통한-전략-분리" class="headerlink" title="전략 패턴을 통한 전략 분리"></a>전략 패턴을 통한 전략 분리</h3><p>변하지 않는 부분을 하나의 메서드(여기에서는 <code>jdbcContextWithStatementStrategy()</code>)로 빼내고, 변하는 부분을 <code>jdbcContextWithStatementStrategy()</code>에 인자로 주입하는 방식으로 컨텍스트(자원 반납 처리 부분)와 전략(쿼리 생성 부분)을 분리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">deleteAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 비즈 로직을 담고 있는 전략을 생성해서 컨텍스트에 주입해주고</span></span><br><span class="line">        <span class="comment">// 로직의 실행 및 뒤처리는 jdbcContextWithStatementStrategy에 위임</span></span><br><span class="line">        <span class="comment">// 자원 반납 등의 반복되는 코드를 jdbcContextWithStatementStrategy로 모아서 중복 제거</span></span><br><span class="line">        StatementStrategy strategy = <span class="keyword">new</span> DeleteAllStatement();</span><br><span class="line">        jdbcContextWithStatementStrategy(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 비즈 로직을 담고 있는 전략을 생성해서 컨텍스트에 주입해주고</span></span><br><span class="line">        <span class="comment">// 로직의 실행 및 뒤처리는 jdbcContextWithStatementStrategy에 위임</span></span><br><span class="line">        <span class="comment">// 자원 반납 등의 반복되는 코드를 jdbcContextWithStatementStrategy로 모아서 중복 제거</span></span><br><span class="line">        StatementStrategy strategy = <span class="keyword">new</span> SelectAllStatement();</span><br><span class="line">        jdbcContextWithStatementStrategy(strategy);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jdbcContextWithStatementStrategy</span><span class="params">(StatementStrategy strategy)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 비즈 로직 외에 변하지 않는 컨텍스트를 모아두고 재사용</span></span><br><span class="line">        Connection c = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = getConnection();</span><br><span class="line">            <span class="comment">// 주입 받은 비즈 로직으로 쿼리 생성</span></span><br><span class="line">            ps = strategy.makeStatement(c);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; ps.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; c.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function">PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection c)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteAllStatement</span> <span class="keyword">implements</span> <span class="title">StatementStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 실제 비즈 로직을 담는다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection c)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.prepareStatement(<span class="string">"delete from users"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectAllStatement</span> <span class="keyword">implements</span> <span class="title">StatementStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 실제 비즈 로직을 담는다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection c)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.prepareStatement(<span class="string">"select * from users"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>조금 더 최적화해서 전략을 익명 클래스로 바꿔보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    jdbcContextWithStatementStrategy(</span><br><span class="line">        <span class="keyword">new</span> StatementStrategy() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection c)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> c.prepareStatement(<span class="string">"delete from users"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> User user)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    jdbcContextWithStatementStrategy(</span><br><span class="line">        <span class="keyword">new</span> StatementStrategy() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection c)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                PreparedStatement ps = </span><br><span class="line">                    c.prepareStatement(<span class="string">"inser into users(id, name, password) values (?, ?, ?)"</span>);</span><br><span class="line">                <span class="comment">// 내부 클래스를 쓰면 outer의 변수인 user에 접근 가능</span></span><br><span class="line">                ps.setString(<span class="number">1</span>, user.getId());</span><br><span class="line">                ps.setString(<span class="number">2</span>, user.getName());</span><br><span class="line">                ps.setString(<span class="number">3</span>, user.getPassword());</span><br><span class="line">                <span class="keyword">return</span> ps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="메서드-였던-jdbcContextWithStatementStrategy를-JdbcContext-클래스로-분리"><a href="#메서드-였던-jdbcContextWithStatementStrategy를-JdbcContext-클래스로-분리" class="headerlink" title="메서드 였던 jdbcContextWithStatementStrategy를 JdbcContext 클래스로 분리"></a>메서드 였던 jdbcContextWithStatementStrategy를 JdbcContext 클래스로 분리</h3><p>DB 연결을 가져오고 DB 연결 자원을 반납하는 <code>jdbcContextWithStatementStrategy()</code>는 UserDao 뿐 아니라 다른 DAO에서도 사용될 수 있다.</p><p>재사용할 수 있도록 별도의 클래스로 분리하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcContext</span> </span>&#123;</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processStatement</span><span class="params">(StatementStrategy strategy)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection c = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = getConnection();</span><br><span class="line">            <span class="comment">// 주입 받은 비즈 로직으로 쿼리 생성</span></span><br><span class="line">            ps = strategy.makeStatement(c);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; ps.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; c.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    JdbcContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJdbcContext</span><span class="params">(JdbcContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 컨텍스트에 있는 템플릿 메서드에</span></span><br><span class="line">        <span class="comment">// 콜백 오브젝트 주입</span></span><br><span class="line">        <span class="keyword">this</span>.context.processStatement(</span><br><span class="line">            <span class="keyword">new</span> StatementStrategy() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection c)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> c.prepareStatement(<span class="string">"delete from users"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> User user)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 컨텍스트에 있는 템플릿 메서드에</span></span><br><span class="line">        <span class="comment">// 콜백 오브젝트 주입</span></span><br><span class="line">        <span class="keyword">this</span>.context.processStatement(</span><br><span class="line">            <span class="keyword">new</span> StatementStrategy() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection c)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                    PreparedStatement ps = </span><br><span class="line">                        c.prepareStatement(<span class="string">"inser into users(id, name, password) values (?, ?, ?)"</span>);</span><br><span class="line">                    <span class="comment">// 내부 클래스를 쓰면 outer의 변수인 user에 접근 가능</span></span><br><span class="line">                    ps.setString(<span class="number">1</span>, user.getId());</span><br><span class="line">                    ps.setString(<span class="number">2</span>, user.getName());</span><br><span class="line">                    ps.setString(<span class="number">3</span>, user.getPassword());</span><br><span class="line">                    <span class="keyword">return</span> ps;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>중복은 아직도 남아있다. 바로, 익명 클래스 생성 부분이다. 메서드로 빼서 최적화하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcContext</span> </span>&#123;</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeSql</span><span class="params">(<span class="keyword">final</span> String query)</span> </span>&#123;     </span><br><span class="line">        <span class="comment">// 쿼리 문자열만 받아서 익명 클래스 생성 후</span></span><br><span class="line">        <span class="comment">// 템플릿 메서드 호출       </span></span><br><span class="line">        processStatement(</span><br><span class="line">            <span class="keyword">new</span> StatementStrategy() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">makeStatement</span><span class="params">(Connection c)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> c.prepareStatement(query);</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 앞에서는 processStatement()가 public이었으나</span></span><br><span class="line">    <span class="comment">// 지금은 executeSql()이 public으로서 외부에 공개되고</span></span><br><span class="line">    <span class="comment">// processStatement()는 private으로 감춘다</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processStatement</span><span class="params">(StatementStrategy strategy)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection c = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = getConnection();</span><br><span class="line">            <span class="comment">// 주입 받은 비즈 로직으로 쿼리 생성</span></span><br><span class="line">            ps = strategy.makeStatement(c);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; ps.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123; <span class="keyword">try</span> &#123; c.close(); &#125; <span class="keyword">catch</span>(SQLException e) &#123;&#125; &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    JdbcContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJdbcContext</span><span class="params">(JdbcContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 컨텍스트에 단순히 쿼리 문자열만 넘겨주면 된다!!</span></span><br><span class="line">        <span class="keyword">this</span>.context.executeSql(<span class="string">"delete from users"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="클래스-다이어그램"><a href="#클래스-다이어그램" class="headerlink" title="클래스 다이어그램"></a>클래스 다이어그램</h3><p>지금까지 개선한 내용을 클래스 다이어그램으로 표시하면 다음과 같다.</p><p><img src="http://i.imgur.com/Lt8TH2a.png" alt="Imgur"></p><h2 id="Spring의-JdbcTemplate"><a href="#Spring의-JdbcTemplate" class="headerlink" title="Spring의 JdbcTemplate"></a>Spring의 JdbcTemplate</h2><p>Spring에서는 JdbcTemplate을 제공해서 앞에서 알아본 JdbcContext가 하는 역할을 편리하게 수행할 수 있게 해준다.</p><p>Spring JdbcTemplate은 <code>update()</code>, <code>queryForInt()</code>, <code>queryForObject()</code>, <code>query()</code> 등의 메서드를 지원하며, 실전에서는 JdbcTemplate를 확장한 NamedParameterJdbcTemplate을 주로 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJdbcTempate</span><span class="params">(JdbcTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 컨텍스트에 단순히 쿼리 문자열만 넘겨주면 된다!!</span></span><br><span class="line">        <span class="keyword">this</span>.template.update(<span class="string">"delete from users"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사실상 쿼리문만 명시해주면 DB 연결과 DB 연결 자원 반납은 더 이상 신경쓰지 않게 되었다. 초난감 DAO와 비교해보면 정말 많은 부분이 개선되었다.</p><p>하지만 곳곳에 있는 <code>throws SQLException</code>이 눈에 거슬린다.</p><p>4장에서는 예외를 처리하는 방법에 대해 알아본다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-03&quot;&gt;&lt;a href=&quot;#Chapter-03&quot; class=&quot;headerlink&quot; title=&quot;Chapter 03&quot;&gt;&lt;/a&gt;Chapter 03&lt;/h1&gt;&lt;p&gt;본 내용은 토비의 스프링 3 책의 내용을 정리한 것입니다.&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Spring" scheme="http://homoefficio.github.io/tags/Spring/"/>
    
      <category term="스프링" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81/"/>
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Template Callback Pattern" scheme="http://homoefficio.github.io/tags/Template-Callback-Pattern/"/>
    
      <category term="JdbcTemplate" scheme="http://homoefficio.github.io/tags/JdbcTemplate/"/>
    
      <category term="템플릿 콜백 패턴" scheme="http://homoefficio.github.io/tags/%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/"/>
    
  </entry>
  
  <entry>
    <title>토비의 스프링 - 1장</title>
    <link href="http://homoefficio.github.io/2017/01/26/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-1%EC%9E%A5/"/>
    <id>http://homoefficio.github.io/2017/01/26/토비의-스프링-1장/</id>
    <published>2017-01-25T15:58:22.000Z</published>
    <updated>2018-10-13T15:49:56.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h1><p>본 내용은 토비의 스프링 3 책의 내용을 정리한 것입니다.</p><p>토비의 스프링은 스프링 뿐아니라 객체 지향의 기본 원리, 테스팅, 예외 처리, 디자인 패턴 등 Java 개발자라면 반드시 알아야 하는 내용을 스토리 전개 방식으로 점진적으로 친절하게 설명해주는 명저입니다. </p><p>똑같은 내용으로 미국에서 영어로 출간되었다면 Jolt상을 받기에도 충분한 책이라고 생각합니다.</p><p>책의 절대적인 가격은 높아보이지만 웬만한 책 두어권 보는 것보다 이 한 권의 책을 여러번 보는 것이 비용 대비 효과가 훨씬 좋을 것입니다.<br>이 책을 읽고 아낄 수 있는 많은 시간, 높아질 몸값을 생각하면 충분히 투자할 가치가 있는 책입니다.</p><p><a href="http://www.acornpub.co.kr/book/toby-spring3-1-set" target="_blank" rel="noopener">http://www.acornpub.co.kr/book/toby-spring3-1-set</a></p><h2 id="초난감-DAO"><a href="#초난감-DAO" class="headerlink" title="초난감 DAO"></a>초난감 DAO</h2><p>DAO의 클래스 하나에서 DB연결, SQL, CRUD, DB연결자원반납을 다 책임진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost~~~"</span>, <span class="string">"id"</span>, <span class="string">"password"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crud1</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection c = getConnection();</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = c.prepareStatement(<span class="string">"update user set password = ? where id = ?"</span>);</span><br><span class="line">            ps.setString(<span class="number">1</span>, user.getPassword());</span><br><span class="line">            ps.setString(<span class="number">2</span>, user.getId());</span><br><span class="line"></span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; ps.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; c.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/PqTQZZo.png" alt="Imgur"></p><p>클래스 다이어그램은 참 단순 깨끗하지만, DAO가 북치고 장구치고 다하는 모양새다. SRP에 따라 DAO 클래스도 하나의 책임만을 가지도록 바꿔보자.</p><p>먼저 DB 연결 부분부터 분리해보자!</p><h2 id="템플릿-메서드-패턴을-이용한-DB-연결-부분-분리"><a href="#템플릿-메서드-패턴을-이용한-DB-연결-부분-분리" class="headerlink" title="템플릿 메서드 패턴을 이용한 DB 연결 부분 분리"></a>템플릿 메서드 패턴을 이용한 DB 연결 부분 분리</h2><p>아래와 같이 <code>getConnection()</code> 메서드를 <code>abstract</code>로 지정해서 DB 연결에 대한 구체적인 내용을 subclass에서 구현하게 한다. 이렇게 하면 DB 연결 내용을 UserDao에서 subclass로 분리해낼 수 있다.</p><p><code>crud1()</code> 메서드는 템플릿 메서드로서 subclass에서 구현할 <code>getConnection()</code>를 호출해서 DB 연결을 가져와서 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DB연결 부분은 subclass에서 결정 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crud1</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection c = getConnection();</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = c.prepareStatement(<span class="string">"update user set password = ? where id = ?"</span>);</span><br><span class="line">            ps.setString(<span class="number">1</span>, user.getPassword());</span><br><span class="line">            ps.setString(<span class="number">2</span>, user.getId());</span><br><span class="line"></span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; ps.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; c.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>템플릿 메서드 패턴을 이용한 DB 연결 분리를 정리하면 다음과 같다.</p><ul><li><code>getConnection()</code>을 <code>abstract</code>로 해서 DB연결 부분을 subclass로 분리</li><li>UserDao는 더이상 구체적인 DB연결 부분을 신경쓰지 않는다.</li></ul><p>클래스 다이어그램은 다음과 같다.</p><p><img src="http://i.imgur.com/RDvtJlU.png" alt="Imgur"></p><p>그런데 템플릿 메서드 패턴처럼 상속을 이용한 방법만 있는 것은 아니다.</p><h2 id="전략-패턴"><a href="#전략-패턴" class="headerlink" title="전략 패턴"></a>전략 패턴</h2><p>다음과 같이 전략 패턴을 사용하면 DB 연결 부분을 subclass가 아니라 인터페이스(여기에서는 DataSource)를 통해 외부의 객체로 분리할 수도 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDao</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crud1</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection c = getConnection();</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = c.prepareStatement(<span class="string">"update user set password = ? where id = ?"</span>);</span><br><span class="line">            ps.setString(<span class="number">1</span>, user.getPassword());</span><br><span class="line">            ps.setString(<span class="number">2</span>, user.getId());</span><br><span class="line"></span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; ps.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; c.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전략 패턴을 통한 DB 연결 부분 분리를 정리하면,</p><ul><li>DataSource 인터페이스를 통해 DB 연결의 구체적 내용을 외부로 분리해서 UserDao의 소스 코드 변경 없이도 dataSource를 다른 것으로 교체할 수 있다.</li><li>UserDao에 주입되는 DataSource 인터페이스의 구현체는 외부에서 주입받는다.</li></ul><p>전략 패턴을 적용한 클래스 다이어그램은 다음과 같다.</p><p><img src="http://i.imgur.com/aRJkn4k.png" alt="Imgur"></p><p>그렇다면 DB 연결의 구체적인 내용을 담고 있는 DataSource 구현체는 누가 주입해주나?</p><h2 id="Factory-Pattern"><a href="#Factory-Pattern" class="headerlink" title="Factory Pattern"></a>Factory Pattern</h2><p>호출 관계로만 보면 UserDao를 사용하는 UserDaoTest가 구체적인 DataSource 구현체의 생성과 주입을 모두 담당할 수도 있다. 하지만 그런 것은 단순히 테스트를 실행하는 UserDaoTest의 역할이 아니다. </p><p>따라서 상황에 맞는 객체를 선별해서 생성할 수 있는 팩토리를 두어 위임하는 것이 좋을 것 같다.</p><p>아래와 같이 UserDaoFactory에서 구체적인 DataSource(여기에서는 ADataSource)를 UserDao에 주입한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">getUserDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao(<span class="keyword">new</span> ADataSource()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserDao dao = <span class="keyword">new</span> DaoFactory().getUserDao();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전략 패턴에 더하여 팩토리 패턴을 적용한 클래스 다이어그램은 다음과 같다.</p><p><img src="http://i.imgur.com/k28BmGo.png" alt="Imgur"></p><p>다시 정리하면, </p><p>DaoFactory가 필요한 객체 생성(<code>new ADataSource()</code>, <code>new UserDao()</code>) 및 <strong>관계 설정</strong>(<code>userDao.setDataSource(new ADataSource())</code>)을 담당한다.</p><p>객체 지향은 결국 협업이고, 협업의 바탕은 관계 설정인데, 그 <strong>관계 설정을 Factory가 담당하는 것이다. 이렇게 보니 Factory가 중요하다.</strong> Factory를 제대로 만들어보자.</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>Factory에서 생성하는 객체들을 Bean이라 하면, Bean을 생성하고 관계를 맺어주는 것은 BeanFactory의 책임이다.</p><p>BeanFactory에 Bean을 Singleton 방식으로 관리하는 능력, 의존 관계 탐색 기능 등을 추가해서 BeanFactory의 기능을 확장한 것이 바로 <strong>ApplicationContext</strong>다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(DaoFactory.class);</span><br><span class="line">        UserDao dao = context.getBean(<span class="string">"userDao"</span>, UserDao.class);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext에서 Bean의 생성 및 관계 설정에 대한 정보를 application-context.xml로 분리할 수 있다. 이렇게 하면 ApplicationContext는 Bean을 물리적으로 생성하고 관계를 맺어주는 역할만을 담당하고, 그에 필요한 논리적인 정보는 외부(application-context.xml)로 분리할 수 있다. </p><p>ApplicationContext과 application-context.xml을 반영하면 클래스 다이어그램이 다음과 같이 변한다.</p><p><img src="http://i.imgur.com/jLqHgfo.png" alt="Imgur"></p><p>이렇게 해서 초난감 DAO에서 시작해서 Spring의 근간을 이루는 ApplicationContext까지 살펴봤다.</p><p>정리해보면,</p><blockquote><ol><li>DB 연결, SQL, CRUD, DB연결자원반납 기능을 모두 가진 초난감 DAO는 너무 많은 역할을 한 몸에 가지고 있다.</li><li>템플릿 메서드 패턴이나 전략 패턴으로 DB 연결을 외부로 분리할 수 있다.</li><li>역할에 따라 객체를 분리하면 분리된 객체 사이에 관계를 맺어줘야 객체 끼리 협력이 가능한데, 이런 역할을 ApplicationContext와 application-context.xml이 담당한다.</li></ol></blockquote><p>2장에서는 테스트에 대한 내용이 나오는데, 중요하지만 일단은 건너뛰고 3장에서 초난감 DAO에 여전히 남아 있는 DB 자원 반납 기능을 분리하는 방법을 알아본다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-1&quot;&gt;&lt;a href=&quot;#Chapter-1&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1&quot;&gt;&lt;/a&gt;Chapter 1&lt;/h1&gt;&lt;p&gt;본 내용은 토비의 스프링 3 책의 내용을 정리한 것입니다.&lt;/p&gt;
&lt;p&gt;토비
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Spring" scheme="http://homoefficio.github.io/tags/Spring/"/>
    
      <category term="스프링" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81/"/>
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="ApplicationContext" scheme="http://homoefficio.github.io/tags/ApplicationContext/"/>
    
      <category term="DAO" scheme="http://homoefficio.github.io/tags/DAO/"/>
    
      <category term="Strategy Pattern" scheme="http://homoefficio.github.io/tags/Strategy-Pattern/"/>
    
      <category term="애플리케이션 컨텍스트" scheme="http://homoefficio.github.io/tags/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"/>
    
      <category term="전략 패턴" scheme="http://homoefficio.github.io/tags/%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4/"/>
    
  </entry>
  
  <entry>
    <title>클래스 리터럴, 타입 토큰, 수퍼 타입 토큰</title>
    <link href="http://homoefficio.github.io/2016/11/30/%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%83%80%EC%9E%85-%ED%86%A0%ED%81%B0-%EC%88%98%ED%8D%BC-%ED%83%80%EC%9E%85-%ED%86%A0%ED%81%B0/"/>
    <id>http://homoefficio.github.io/2016/11/30/클래스-리터럴-타입-토큰-수퍼-타입-토큰/</id>
    <published>2016-11-29T17:04:22.000Z</published>
    <updated>2018-10-13T15:49:56.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="클래스-리터럴-타입-토큰-수퍼-타입-토큰"><a href="#클래스-리터럴-타입-토큰-수퍼-타입-토큰" class="headerlink" title="클래스 리터럴, 타입 토큰, 수퍼 타입 토큰"></a>클래스 리터럴, 타입 토큰, 수퍼 타입 토큰</h1><p>이 글은 <a href="https://gaming.youtube.com/tobyleetv/live" target="_blank" rel="noopener">토비님의 방송 채널</a>에서 소개해주신 <a href="https://www.youtube.com/watch?v=01sdXvZSjcI" target="_blank" rel="noopener">수퍼 타입 토큰</a>에 대한 내용을 바탕으로 <a href="https://docs.oracle.com/javase/tutorial/extra/generics/literals.html" target="_blank" rel="noopener">Oracle의 리터럴과 런타임 타입 토큰 튜토리얼</a>, 수퍼 타입 토큰 기법의 창시자로 알려진 <a href="http://gafter.blogspot.kr/2006/12/super-type-tokens.html" target="_blank" rel="noopener">Neal Gafter의 글</a>과 Jackson에 사용되고 있는 TypeReference 클래스의 소스 코드를 참고로 작성했다.  </p><h2 id="클래스-리터럴과-타입-토큰의-의미"><a href="#클래스-리터럴과-타입-토큰의-의미" class="headerlink" title="클래스 리터럴과 타입 토큰의 의미"></a>클래스 리터럴과 타입 토큰의 의미</h2><ul><li>클래스 리터럴(Class Literal)은 <code>String.class</code>, <code>Integer.class</code> 등을 말하며, <code>String.class</code>의 타입은 <code>Class&lt;String&gt;</code>, <code>Integer.class</code>의 타입은 <code>Class&lt;Integer&gt;</code>다.</li><li>타입 토큰(Type Token)은 쉽게 말해 타입을 나타내는 토큰이며, <strong>클래스 리터럴이 타입 토큰으로서 사용된다</strong>.</li><li><code>myMethod(Class&lt;?&gt; clazz)</code> 와 같은 메서드는 타입 토큰을 인자로 받는 메서드이며, <strong><code>method(String.class)</code>로 호출하면, <code>String.class</code>라는 클래스 리터럴을 타입 토큰 파라미터로 <code>myMethod</code>에 전달한다</strong>.</li></ul><h2 id="타입-토큰은-어디에-쓰나"><a href="#타입-토큰은-어디에-쓰나" class="headerlink" title="타입 토큰은 어디에 쓰나?"></a>타입 토큰은 어디에 쓰나?</h2><p>아하~~ 이거구나! 하고 금방 감이 오는 구체적인 사례로는 아래와 같은 ObjectMapper를 들 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLittleTelevision mlt = objectMapper.readValue(jsonString, MyLittleTelevision.class);  <span class="comment">// 아하~ 이거~~</span></span><br></pre></td></tr></table></figure><p>범용적으로 말하자면 <strong>타입 토큰은 타입 안전성이 필요한 곳에 사용된다</strong>.</p><h2 id="타입-안전성-적용-사례-Heterogeneous-Map"><a href="#타입-안전성-적용-사례-Heterogeneous-Map" class="headerlink" title="타입 안전성 적용 사례 - Heterogeneous Map"></a>타입 안전성 적용 사례 - Heterogeneous Map</h2><p>자바5에서 Generic이 나온 이후로 특정 타입을 가지는 Map은 <code>Map&lt;String, String&gt;</code> 같은 식으로 키와 밸류의 타입을 명시적으로 지정해서 타입 안전성을 확보할 수 있는데, 정해진 특정 타입이 아니라 다양한 타입을 지원해야 하는 Heterogeneous Map이 필요하다면 타입 안전성을 확보하기 위해 다른 방법이 필요하다. 이럴 때 타입 토큰을 이용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeTokenMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">SimpleTypeSafeMap</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Class&lt;T&gt; k, T v)</span> </span>&#123;</span><br><span class="line">                map.put(k, v);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; k)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> k.cast(map.get(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SimpleTypeSafeMap simpleTypeSafeMap = <span class="keyword">new</span> SimpleTypeSafeMap();</span><br><span class="line"></span><br><span class="line">        simpleTypeSafeMap.put(String.class, <span class="string">"abcde"</span>);</span><br><span class="line">        simpleTypeSafeMap.put(Integer.class, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 타입 토큰을 이용해서 별도의 캐스팅 없이도 타입 안전성이 확보된다.</span></span><br><span class="line">        String v1 = simpleTypeSafeMap.get(String.class);</span><br><span class="line">        Integer v2 = simpleTypeSafeMap.get(Integer.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(v1);</span><br><span class="line">        System.out.println(v2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앞에서 나온 <code>SimpleTypeSafeMap</code>에는 아쉬운 단점이 있는데, <strong><code>List&lt;String&gt;.class</code>와 같은 형식의 타입 토큰을 사용할 수 없다</strong>는 점이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeTokenMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SimpleTypeSafeMap simpleTypeSafeMap = <span class="keyword">new</span> SimpleTypeSafeMap();</span><br><span class="line"></span><br><span class="line">        simpleTypeSafeMap.put(String.class, <span class="string">"abcde"</span>);</span><br><span class="line">        simpleTypeSafeMap.put(Integer.class, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 타입 토큰을 이용해서 별도의 캐스팅 없이도 안전하다.</span></span><br><span class="line">        String v1 = simpleTypeSafeMap.get(String.class);</span><br><span class="line">        Integer v2 = simpleTypeSafeMap.get(Integer.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(v1);</span><br><span class="line">        System.out.println(v2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 아래와 같은 List&lt;String&gt;.class라는 클래스 리터럴은 언어에서 지원해주지 않으므로 사용 불가!!</span></span><br><span class="line"><span class="comment">//        typeSafeMap.put(List&lt;String&gt;.class, Arrays.asList("a", "b", "c"));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="수퍼-타입-토큰"><a href="#수퍼-타입-토큰" class="headerlink" title="수퍼 타입 토큰"></a>수퍼 타입 토큰</h2><p>수퍼 타입 토큰은 앞에서 살펴본 것처럼 <strong><code>List&lt;String&gt;.class</code>라는 클래스 리터럴이 존재할 수 없다는 한계를 뛰어넘을 수 있게 해주는 묘수</strong>라고 할 수 있다. Neal Gafter라는 사람이 <a href="http://gafter.blogspot.kr/2006/12/super-type-tokens.html" target="_blank" rel="noopener">http://gafter.blogspot.kr/2006/12/super-type-tokens.html</a> 에서 처음 고안한 방법으로 알려져 있다. 수퍼급의 타입 토큰이 아니라, <strong>수퍼 타입을 토큰으로 사용한다</strong>는 의미다.</p><p>수퍼 타입 토큰은 상속과 Reflection을 기발하게 조합해서 <code>List&lt;String&gt;.class</code> 같은, 원래는 사용할 수 없는 클래스 리터럴을 타입 토큰으로 사용하는 것과 같은 효과를 낼 수 있다.</p><p>앞에서 클래스 리터럴을 설명할 때, <code>String.class</code>의 타입이 <code>Class&lt;String&gt;</code>이라고 했었다. <code>Class&lt;String&gt;</code>이라는 타입 정보를 <code>String.class</code>라는 클래스 리터럴로 구할 수 있었던 덕분에 타입 안전성을 확보할 수 있었다.</p><p><code>List&lt;String&gt;.class</code>도 타입을 구할 수만 있다면 타입 안전성을 확보할 수 있다는 것은 마찬가지다. 다만, <code>Class&lt;String&gt;</code>와는 달리 <code>Class&lt;List&lt;String&gt;&gt;</code>라는 타입은 <code>List&lt;String&gt;.class</code> 같은 클래스 리터럴로 쉽게 구할 수 없다는 점이 다르다. 하지만 <strong>어떻게든 <code>Class&lt;List&lt;String&gt;&gt;</code>라는 타입을 구할 수 있다면, 우리는 타입 안전성을 확보할 수 있다</strong>.</p><h3 id="Class-getGenericSuperclass"><a href="#Class-getGenericSuperclass" class="headerlink" title="Class.getGenericSuperclass()"></a>Class.getGenericSuperclass()</h3><p>결론부터 말하면 우리의 구세주는 <code>Class</code>에 들어있는 <strong><code>public Type getGenericSuperclass()</code></strong> 이놈이다.</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getGenericSuperclass--" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getGenericSuperclass--</a> 의 설명을 요약해보면 다음과 같다.</p><blockquote><p><code>getGenericSuperclass()</code>는</p><ul><li>바로 위의 수퍼 클래스의 타입을 반환하며,</li><li>바로 위의 수퍼 클래스가 ParameterizedType이면, <strong>실제 타입 파라미터들을 반영한 타입을 반환해야 한다</strong>.</li><li>ParameterizedType에 대해서는 별도 문서를 참고하라.</li></ul></blockquote><p>오~ 뭔가 타입 파라미터들을 반영한 타입을 반환한단다. 우리는 <code>Class&lt;List&lt;String&gt;&gt;</code>라는 타입을 어떻게든 구하려고 하고 있었다. 그런데 <strong><code>getGenericSuperclass()</code> 이놈이 뭔가 파라미터 정보를 포함하는 타입을 반환한단다!!</strong></p><p>위의 설명을 조금 각색하면 다음과 같다.</p><blockquote><ul><li>어떤 객체 <code>sub</code>의 바로 위의 수퍼 클래스가 <code>List&lt;String&gt;</code>라는 파라미터를 사용하고 있는 ParameterizedType이면, </li><li><code>sub.getClass().getGenericSuperclass()</code>는 <strong><code>List&lt;String&gt;</code> 정보가 포함되어 있는 타입을 반환</strong>해야 한다.</li></ul></blockquote><p>앞에서 살펴본 것을 코드로 작성해보면, 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeTokenMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SimpleTypeSafeMap 부분 생략</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Super</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 수퍼 클래스에 사용되는 파라미터 타입을 이용한다. 그래서 수퍼 타입 토큰.</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span>&lt;<span class="title">List</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 파라미터 타입 정보가 포함된 수퍼 클래스의 타입 정보를 구한다.</span></span><br><span class="line">        Type typeOfGenericSuperclass = sub.getClass().getGenericSuperclass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ~~~$1Super&lt;java.util.List&lt;java.lang.String&gt;&gt; 라고 나온다!!</span></span><br><span class="line">        System.out.println(typeOfGenericSuperclass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ParameterizedType-getActualTypeArguments"><a href="#ParameterizedType-getActualTypeArguments" class="headerlink" title="ParameterizedType.getActualTypeArguments()"></a>ParameterizedType.getActualTypeArguments()</h3><p>위에 <code>getGenericSuperclass()</code>의 설명을 보면, <strong>수퍼 클래스가 ParameterizedType이면 타입 파라미터를 포함한 정보를 반환해야 한다</strong>고 했으며, ParameterizedType은 별도의 문서를 보라고 했다.</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ParameterizedType.html" target="_blank" rel="noopener">ParameterizedType의 API 문서</a> 를 보면 <code>Type[] getActualTypeArgumensts()</code>라는 메서드가 있다. 느낌이 팍 온다.. 앞의 코드를 조금 보완해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeTokenMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SimpleTypeSafeMap 부분 생략</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Super</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span>&lt;<span class="title">List</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Type typeOfGenericSuperclass = sub.getClass().getGenericSuperclass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ~~~$1Super&lt;java.util.List&lt;java.lang.String&gt;&gt; 라고 나온다!!</span></span><br><span class="line">        System.out.println(typeOfGenericSuperclass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 수퍼 클래스가 ParameterizedType 이므로 ParameterizedType으로 캐스팅 가능</span></span><br><span class="line">        <span class="comment">// ParameterizedType의 getActualTypeArguments()으로 실제 타입 파라미터의 정보를 구한다!!</span></span><br><span class="line">        Type actualType = ((ParameterizedType) typeOfGenericSuperclass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 심봤다! java.util.List&lt;java.lang.String&gt;가 나온다!!</span></span><br><span class="line">        System.out.println(actualType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>오.. 구했다. </p><blockquote><p>단순한 클래스 리터럴로는 구할 수 없었던 <code>Class&lt;List&lt;String&gt;&gt;</code>라는 타입 정보를,<br>껍데기 뿐이지만 한 없이 아름다운 수퍼 클래스와 위대한 구세주 <code>getGenericSuperclass()</code>, 그리고 <code>getActualTypeArguments()</code>를 이용해서 구했다.</p></blockquote><p>이제 게임 끝났네..</p><h3 id="아줌마-났어요"><a href="#아줌마-났어요" class="headerlink" title="아줌마 났어요~~"></a>아줌마 났어요~~</h3><p>그럼 바로 써보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeTokenMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">SimpleTypeSafeMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Class&lt;T&gt; k, T v)</span> </span>&#123;</span><br><span class="line">                map.put(k, v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; k)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> k.cast(map.get(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SimpleTypeSafeMap simpleTypeSafeMap = <span class="keyword">new</span> SimpleTypeSafeMap();</span><br><span class="line"></span><br><span class="line">        simpleTypeSafeMap.put(String.class, <span class="string">"abcde"</span>);</span><br><span class="line">        simpleTypeSafeMap.put(Integer.class, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 타입 토큰을 이용해서 별도의 캐스팅 없이도 안전하다.</span></span><br><span class="line">        String v1 = simpleTypeSafeMap.get(String.class);</span><br><span class="line">        Integer v2 = simpleTypeSafeMap.get(Integer.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(v1);</span><br><span class="line">        System.out.println(v2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 수퍼 타입 토큰을 써보자</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Super</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span>&lt;<span class="title">List</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line"></span><br><span class="line">        Type typeOfGenericSuperclass = sub.getClass().getGenericSuperclass();</span><br><span class="line"></span><br><span class="line">        System.out.println(typeOfGenericSuperclass);</span><br><span class="line"></span><br><span class="line">        Type actualType = ((ParameterizedType) typeOfGenericSuperclass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(actualType);</span><br><span class="line"></span><br><span class="line">        simpleTypeSafeMap.put(actualType, Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)); <span class="comment">// 여기서 에러!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>나긴 났는데.. 에러가 나네.. ㅋ 실행도 하기 전에 컴파일 에러다 ㅋㅋ</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Wrong <span class="number">1</span><span class="keyword">st</span> <span class="keyword">argument</span> <span class="built_in">type</span>. Found: <span class="string">'java.lang.reflect.Type'</span>, required: <span class="string">'java.lang.Class&lt;T&gt;'</span> less...</span><br><span class="line"></span><br><span class="line"><span class="keyword">put</span>(java.lang.Class<span class="symbol">&lt;T&gt;</span>, T) in SimpleTypeSafeMap cannot <span class="keyword">be</span> applied <span class="keyword">to</span></span><br><span class="line">(java.lang.reflect.Type, java.util.List<span class="symbol">&lt;T&gt;</span>)</span><br><span class="line"> </span><br><span class="line">reason: <span class="keyword">no</span> instance(s) of <span class="built_in">type</span> variable(s) T exist <span class="keyword">so</span> that Type conforms <span class="keyword">to</span> Class<span class="symbol">&lt;T&gt;</span></span><br></pre></td></tr></table></figure><p><code>SimpleTypeSafeMap</code>은 키로 <code>Class&lt;?&gt;</code>을 받는데, <code>java.lang.reflect.Type</code>를 넘겨주면 어쩌냐는 푸념이다.</p><p><code>Class&lt;?&gt;</code>만 받을 수 있는 <code>SimpleTypeSafeMap</code>은 이제 퇴장할 때가 된 것 같다. <code>Class&lt;?&gt;</code>보다 더 General한 <code>java.lang.reflect.Type</code> 같은 키도 받을 수 있도록 약간 고도화한 <code>TypeSafeMap</code>을 만날 때가 되었다. </p><p>그리고 빈 껍데기 였던 <code>Super&lt;T&gt;</code>도 이름을 <code>TypeReference&lt;T&gt;</code>로 바꾸고 고도화해보자.<br>먼저 <code>Super&lt;T&gt;</code>를 <code>TypeReference&lt;T&gt;</code>로 바꿔보자.</p><h3 id="TypeReference"><a href="#TypeReference" class="headerlink" title="TypeReference"></a>TypeReference<t></t></h3><p><code>Super&lt;T&gt;</code>를 <code>TypeReference&lt;T&gt;</code>로 바꾸는 것을 먼저하는 이유는 <code>TypeReference&lt;T&gt;</code>가 가진 정보가 <code>TypeSafeMap</code>의 키로 사용될 것이기 때문이다.</p><p>먼저 코드를 보고 설명을 이어가자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TypeReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Type superClassType = getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (!(superClassType <span class="keyword">instanceof</span> ParameterizedType)) &#123;  <span class="comment">// sanity check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"TypeReference는 항상 실제 타입 파라미터 정보와 함께 생성되어야 합니다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.type = ((ParameterizedType)superClassType).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>맨 위에서부터 순차적으로 살펴보자.</p><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p><code>TypeReference</code>를 <code>abstract</code>로 선언했는데, 이유는 <strong><code>new TypeReference&lt;List&lt;String&gt;&gt;()</code>이 아니라 항상 <code>new TypeReference&lt;List&lt;String&gt;&gt;() {}</code> 형식으로 생성하기 위해서다</strong>. 왜냐하면, 타입 파라미터 정보를 구하려면 수퍼 타입 토큰을 이용해야 하는데, <strong>수퍼 타입 토큰을 이용하려면 언제나 누군가의 수퍼 클래스로 존재해야 하기 때문</strong>이다.</p><p>잘 와닿지 않는다면 앞에서 단순하게 <code>Sub</code>와 <code>Super</code>를 이용했을 때의 코드를 살펴보면 느낌이 올 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span>&lt;<span class="title">List</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;&#125;</span><br><span class="line">Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">Type typeOfGenericSuperclass = sub.getClass().getGenericSuperclass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위의 세 줄을 한 줄로 쓰면 아래와 같다.</span></span><br><span class="line">Type typeOfGenericSuperclass = <span class="keyword">new</span> Super&lt;List&lt;String&gt;&gt;()&#123;&#125;.getClass().getGenericSuperclass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Super를 TypeReference로 바꾸면</span></span><br><span class="line">Type typeOfGenericSuperclass = <span class="keyword">new</span> TypeReference&lt;List&lt;String&gt;&gt;()&#123;&#125;.getClass().getGenericSuperclass();</span><br></pre></td></tr></table></figure><h4 id="타입-파라미터-정보를-담는-type"><a href="#타입-파라미터-정보를-담는-type" class="headerlink" title="타입 파라미터 정보를 담는 type"></a>타입 파라미터 정보를 담는 <code>type</code></h4><p>다음은 <code>Type type</code>이라는 인스턴스 변수다. 아래와 같이 생성자를 통해서 타입 파라미터의 타입 정보를 <code>type</code>에 담는다.</p><p>그리고 생성자가 항상 타입 파라미터와 함께 사용되도록, <code>ParameterizedType</code>를 이용해서 sanity check를 적용한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TypeReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Type superClassType = getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (!(superClassType <span class="keyword">instanceof</span> ParameterizedType)) &#123;  <span class="comment">// sanity check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"TypeReference는 항상 실제 타입 파라미터 정보와 함께 생성되어야 합니다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.type = ((ParameterizedType)superClassType).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TypeReference</code>는 준비가 되었다. 이제 <code>TypeSafeMap</code> 차례다.</p><h3 id="TypeSafeMap"><a href="#TypeSafeMap" class="headerlink" title="TypeSafeMap"></a>TypeSafeMap</h3><h4 id="키의-타입-변경"><a href="#키의-타입-변경" class="headerlink" title="키의 타입 변경"></a>키의 타입 변경</h4><p>먼저 사용했던 <code>SimpleTypeSafeMap</code>은 key로 <code>Class&lt;?&gt;</code> 타입만을 받을 수 있다는 제약 사항 때문에 퇴장했었다. 이를 개선한 <code>TypeSafeMap</code>은 <code>Class&lt;?&gt;</code>보다 더 일반화된 <code>java.lang.reflect.Type</code>을 key로 받는다.</p><p>먼저 <code>SimpleTypeSafeMap</code>의 이름을 <code>TypeSafeMap</code>으로 바꾸고, 내부의 <code>map</code>의 key로 사용되는 <code>Class&lt;?&gt;</code> 부분을 <code>Type</code>으로 바꾼다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeSafeMap</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//  private Map&lt;Class&lt;?&gt;, Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Type, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">// key로 사용되던 Class&lt;?&gt; 대신 Type으로 변경</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Class&lt;T&gt; k, T v)</span> </span>&#123;</span><br><span class="line">        map.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k.cast(map.get(k));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put-의-개선"><a href="#put-의-개선" class="headerlink" title="put()의 개선"></a>put()의 개선</h4><p><code>TypeSafeMap</code>의 <code>put()</code>에는 수퍼 타입을 추출할 수 있는 <code>TypeReference&lt;T&gt;</code>를 key로 받도록 바꾼다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeSafeMap</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//  private Map&lt;Class&lt;?&gt;, Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Type, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">// key로 사용되던 Class&lt;?&gt; 대신 Type으로 변경</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  public &lt;T&gt; void put(Class&lt;T&gt; k, T v) &#123;</span></span><br><span class="line"><span class="comment">//      map.put(k, v);</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(TypeReference&lt;T&gt; k, T v)</span> </span>&#123;  <span class="comment">// 수퍼 타입을 추출할 수 있는 TypeReference&lt;T&gt;를 인자로 받음</span></span><br><span class="line">        map.put(k.getType(), v);  <span class="comment">// key가 Type으로 바뀌었으므로 기존의 k 대신 k.getType()으로 변경</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k.cast(map.get(k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-의-개선"><a href="#get-의-개선" class="headerlink" title="get()의 개선"></a>get()의 개선</h4><p>key로 사용되는 <code>Type</code> 자리에는 타입 파라미터를 사용하지 않는 <code>String</code> 같은 일반 클래스도 올 수 있고, 타입 파라미터를 사용하는 <code>List&lt;String&gt;</code>같은 <code>ParameterizedType</code>의 클래스도 올 수 있다. 이 두 경우를 모두 처리하기 위해 다음과 같이 <code>get()</code>을 개선한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeSafeMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  private Map&lt;Class&lt;?&gt;, Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Type, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">// key로 사용되던 Class&lt;?&gt; 대신 Type으로 변경</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  public &lt;T&gt; void put(Class&lt;T&gt; k, T v) &#123;</span></span><br><span class="line"><span class="comment">//      map.put(k, v);</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(TypeReference&lt;T&gt; k, T v)</span> </span>&#123;  <span class="comment">// 수퍼 타입을 추출할 수 있는 TypeReference&lt;T&gt;를 인자로 받음</span></span><br><span class="line">        map.put(k.getType(), v);  <span class="comment">// key가 Type으로 바뀌었으므로 기존의 k 대신 k.getType()으로 변경</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  public &lt;T&gt; T get(Class&lt;T&gt; k) &#123;</span></span><br><span class="line"><span class="comment">//      return k.cast(map.get(k));</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(TypeReference&lt;T&gt; k)</span> </span>&#123;  <span class="comment">// key로 TypeReference&lt;T&gt;를 사용하도록 수정</span></span><br><span class="line">        <span class="keyword">if</span> (k.getType() <span class="keyword">instanceof</span> ParameterizedType)</span><br><span class="line">            <span class="keyword">return</span> ((Class&lt;T&gt;)((ParameterizedType)k.getType()).getRawType()).cast(map.get(k.getType()));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ((Class&lt;T&gt;)k.getType()).cast(map.get(k.getType()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>조금 복잡해 보이지만, <code>ParameterizedType</code>인 경우에는 <code>getRawType()</code>을 이용해서 키에 사용된 타입 파라미터의 타입으로 캐스팅 해주도록 개선한 것 뿐이다.</p><p>자, 이제 지금까지 해본 것을 한데 모아 보자.</p><h2 id="All-in-One"><a href="#All-in-One" class="headerlink" title="All in One"></a>All in One</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeTokenMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> Type type;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="title">TypeReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Type superClassType = getClass().getGenericSuperclass();</span><br><span class="line">                <span class="keyword">if</span> (!(superClassType <span class="keyword">instanceof</span> ParameterizedType)) &#123;  <span class="comment">// sanity check</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"TypeReference는 항상 실제 타입 파라미터 정보와 함께 생성되어야 합니다."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.type = ((ParameterizedType)superClassType).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> type;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TypeSafeMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> Map&lt;Type, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">// key로 사용되던 Class&lt;?&gt; 대신 Type으로 변경</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(TypeReference&lt;T&gt; k, T v)</span> </span>&#123;  <span class="comment">// 수퍼 타입을 추출할 수 있는 TypeReference&lt;T&gt;를 인자로 받음</span></span><br><span class="line">                map.put(k.getType(), v);  <span class="comment">// key가 Type으로 바뀌었으므로 기존의 k 대신 k.getType()으로 변경</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(TypeReference&lt;T&gt; k)</span> </span>&#123;  <span class="comment">// key로 TypeReference&lt;T&gt;를 사용하도록 수정</span></span><br><span class="line">                <span class="keyword">if</span> (k.getType() <span class="keyword">instanceof</span> ParameterizedType)</span><br><span class="line">                    <span class="keyword">return</span> ((Class&lt;T&gt;)((ParameterizedType)k.getType()).getRawType()).cast(map.get(k.getType()));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> ((Class&lt;T&gt;)k.getType()).cast(map.get(k.getType()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SimpleTypeSafeMap simpleTypeSafeMap = new SimpleTypeSafeMap();</span></span><br><span class="line">        TypeSafeMap typeSafeMap = <span class="keyword">new</span> TypeSafeMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// simpleTypeSafeMap.put(String.class, "abcde");</span></span><br><span class="line">        typeSafeMap.put(<span class="keyword">new</span> TypeReference&lt;String&gt;() &#123;&#125;, <span class="string">"abcde"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// simpleTypeSafeMap.put(Integer.class, 123);</span></span><br><span class="line">        typeSafeMap.put(<span class="keyword">new</span> TypeReference&lt;Integer&gt;() &#123;&#125;, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 드디어 List&lt;String&gt; 을 쓸 수 있다!!</span></span><br><span class="line">        <span class="comment">// new TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;를 사용해서 List&lt;String&gt;.class와 동일한 효과를!!</span></span><br><span class="line">        typeSafeMap.put(<span class="keyword">new</span> TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;, Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// List&lt;List&lt;String&gt;&gt; 처럼 중첩된 ParameterizedType도 사용 가능하다!!</span></span><br><span class="line">        typeSafeMap.put(<span class="keyword">new</span> TypeReference&lt;List&lt;List&lt;String&gt;&gt;&gt;() &#123;&#125;,</span><br><span class="line">                Arrays.asList(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>), Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map&lt;K, V&gt;도 된다.</span></span><br><span class="line">        Map&lt;String, String&gt; strMap1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        strMap1.put(<span class="string">"Key1"</span>, <span class="string">"Value1"</span>);</span><br><span class="line">        strMap1.put(<span class="string">"Key2"</span>, <span class="string">"Value2"</span>);</span><br><span class="line">        typeSafeMap.put(<span class="keyword">new</span> TypeReference&lt;Map&lt;String, String&gt;&gt;() &#123;&#125;, strMap1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 수퍼 타입 토큰을 이용해서 별도의 캐스팅 없이도 안전하다.</span></span><br><span class="line">        <span class="comment">// String v1 = typeSafeMap.get(String.class);</span></span><br><span class="line">        String v1 = typeSafeMap.get(<span class="keyword">new</span> TypeReference&lt;String&gt;() &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Integer v2 = typeSafeMap.get(Integer.class);</span></span><br><span class="line">        Integer v2 = typeSafeMap.get(<span class="keyword">new</span> TypeReference&lt;Integer&gt;() &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 바로 이거다!</span></span><br><span class="line">        <span class="comment">// List&lt;String&gt;.class 처럼 언어에서 지원해 주지 않는 클래스 리터럴을 사용하지 않고도</span></span><br><span class="line">        <span class="comment">// List&lt;String&gt;라는 타입을 쓸 수 있게 되었다.</span></span><br><span class="line">        List&lt;String&gt; listString = typeSafeMap.get(<span class="keyword">new</span> TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// List&lt;List&lt;String&gt;&gt; 처럼 중첩된 ParameterizedType도 사용 가능하다!!</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; listListString =</span><br><span class="line">                typeSafeMap.get(<span class="keyword">new</span> TypeReference&lt;List&lt;List&lt;String&gt;&gt;&gt;() &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map&lt;K, V&gt;도 된다.</span></span><br><span class="line">        Map&lt;String, String&gt; strMap = typeSafeMap.get(<span class="keyword">new</span> TypeReference&lt;Map&lt;String, String&gt;&gt;() &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(v1);</span><br><span class="line">        System.out.println(v2);</span><br><span class="line">        System.out.println(listString);</span><br><span class="line">        System.out.println(listListString);</span><br><span class="line">        System.out.println(strMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring의-ParameterizedTypeReference"><a href="#Spring의-ParameterizedTypeReference" class="headerlink" title="Spring의 ParameterizedTypeReference"></a>Spring의 ParameterizedTypeReference</h2><p>전지전능하신 Spring느님께서는 <code>ParameterizedTypeReference</code>라는 클래스를 우리에게 하사하시었다.</p><p><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/ParameterizedTypeReference.html" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/ParameterizedTypeReference.html</a></p><p>허무하지만 앞에서 알아본 건 걍 공부했다 치고, 실전에서는 앞에서 만든 <code>TypeReference</code> 대신 <code>ParameterizedTypeReference</code>를 사용하자. ㅋㅋ   </p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><blockquote><ul><li>타입 안전성을 확보하려면 타입 정보가 필요하다.</li><li>일반적인 클래스의 타입 정보는 <code>String.class</code>, <code>Integer.class</code>와 같은 클래스 리터럴로 쉽게 구할 수 있다.</li><li><code>List&lt;String&gt;.class</code> 같은 클래스 리터럴은 언어에서 지원해주지 않으므로 사용할 수 없다.</li><li>수퍼 타입 토큰 기법을 사용하면 클래스 리터럴로 쉽게 구할 수 없는, <code>List&lt;String&gt;</code> 형태의 타입 정보를 구할 수 있다.</li><li>따라서 <code>List&lt;String&gt;.class</code>라는 클래스 리터럴을 쓸 수 없더라도, <code>List&lt;String&gt;</code>라는 타입을 쓸 수 있어서 타입 안전성을 확보할 수 있다.</li><li>수퍼 타입 토큰 기법은 Spring이 <code>ParameterizedTypeReference</code>를 통해 제공해주고 있으므로 써주자. </li></ul></blockquote><h2 id="더-읽을-거리"><a href="#더-읽을-거리" class="headerlink" title="더 읽을 거리"></a>더 읽을 거리</h2><ul><li><a href="https://www.youtube.com/watch?v=01sdXvZSjcI" target="_blank" rel="noopener">토비님 방송 - 수퍼 타입 토큰 1</a></li><li><a href="https://www.youtube.com/watch?v=y_uGSqpE4So" target="_blank" rel="noopener">토비님 방송 - 수퍼 타입 토큰 2</a></li><li><a href="https://docs.oracle.com/javase/tutorial/extra/generics/literals.html" target="_blank" rel="noopener">Oracle의 리터럴과 런타임 타입 토큰 튜토리얼</a></li><li><a href="http://gafter.blogspot.kr/2006/12/super-type-tokens.html" target="_blank" rel="noopener">Neal Gafter의 글</a></li><li><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/ParameterizedTypeReference.html" target="_blank" rel="noopener">Spring ParameterizedTypeReference</a></li></ul><h2 id="더-생각할-거리"><a href="#더-생각할-거리" class="headerlink" title="더 생각할 거리"></a>더 생각할 거리</h2><ul><li><code>TypeReference&lt;T&gt;</code> 뿐아니라 <code>BiTypeReference&lt;T, U&gt;</code>, <code>TriTypeReference&lt;T, U, V&gt;</code>, … 도 가능할까?</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;클래스-리터럴-타입-토큰-수퍼-타입-토큰&quot;&gt;&lt;a href=&quot;#클래스-리터럴-타입-토큰-수퍼-타입-토큰&quot; class=&quot;headerlink&quot; title=&quot;클래스 리터럴, 타입 토큰, 수퍼 타입 토큰&quot;&gt;&lt;/a&gt;클래스 리터럴, 타입 토큰, 수퍼
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Generic Type" scheme="http://homoefficio.github.io/tags/Generic-Type/"/>
    
      <category term="Parameterized Type" scheme="http://homoefficio.github.io/tags/Parameterized-Type/"/>
    
      <category term="Type Parameter" scheme="http://homoefficio.github.io/tags/Type-Parameter/"/>
    
      <category term="Class Literal" scheme="http://homoefficio.github.io/tags/Class-Literal/"/>
    
      <category term="Type Token" scheme="http://homoefficio.github.io/tags/Type-Token/"/>
    
      <category term="Super Type Token" scheme="http://homoefficio.github.io/tags/Super-Type-Token/"/>
    
      <category term="Type Safety" scheme="http://homoefficio.github.io/tags/Type-Safety/"/>
    
      <category term="TypeReference" scheme="http://homoefficio.github.io/tags/TypeReference/"/>
    
      <category term="ParameterizedTypeReference" scheme="http://homoefficio.github.io/tags/ParameterizedTypeReference/"/>
    
      <category term="제네릭" scheme="http://homoefficio.github.io/tags/%EC%A0%9C%EB%84%A4%EB%A6%AD/"/>
    
      <category term="타입 파라미터" scheme="http://homoefficio.github.io/tags/%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0/"/>
    
      <category term="클래스 리터럴" scheme="http://homoefficio.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A6%AC%ED%84%B0%EB%9F%B4/"/>
    
      <category term="타입 토큰" scheme="http://homoefficio.github.io/tags/%ED%83%80%EC%9E%85-%ED%86%A0%ED%81%B0/"/>
    
      <category term="수퍼 타입 토큰" scheme="http://homoefficio.github.io/tags/%EC%88%98%ED%8D%BC-%ED%83%80%EC%9E%85-%ED%86%A0%ED%81%B0/"/>
    
      <category term="타입 안전성" scheme="http://homoefficio.github.io/tags/%ED%83%80%EC%9E%85-%EC%95%88%EC%A0%84%EC%84%B1/"/>
    
  </entry>
  
  <entry>
    <title>Spring에서 JSON에 XSS 방지 처리 하기</title>
    <link href="http://homoefficio.github.io/2016/11/21/Spring%EC%97%90%EC%84%9C-JSON%EC%97%90-XSS-%EB%B0%A9%EC%A7%80-%EC%B2%98%EB%A6%AC-%ED%95%98%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2016/11/21/Spring에서-JSON에-XSS-방지-처리-하기/</id>
    <published>2016-11-21T14:32:08.000Z</published>
    <updated>2018-10-13T15:49:56.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring에서-JSON에-XSS-방지-처리-하기"><a href="#Spring에서-JSON에-XSS-방지-처리-하기" class="headerlink" title="Spring에서 JSON에 XSS 방지 처리 하기"></a>Spring에서 JSON에 XSS 방지 처리 하기</h1><h2 id="고마운-lucy-xss-servlet-filter의-한계"><a href="#고마운-lucy-xss-servlet-filter의-한계" class="headerlink" title="고마운 lucy-xss-servlet-filter의 한계"></a>고마운 lucy-xss-servlet-filter의 한계</h2><p>XSS(Cross Site Scripting) 방지를 위해 널리 쓰이는 훌륭한 <a href="https://github.com/naver/lucy-xss-servlet-filter" target="_blank" rel="noopener">lucy-xss-servlet-filter</a>는 Servlet Filter 단에서 <code>&lt;</code> 등의 특수 문자를 <code>&amp;lt;</code> 등으로 변환해주며, 여러 가지 관련 설정을 편리하게 지정할 수 있어 정말 좋다.</p><p>그런데 그 처리가 <strong>form-data에 대해서만 적용되고 Request Raw Body로 넘어가는 JSON에 대해서는 처리해주지 않는다</strong>는 단점이 있다. 그래서 JSON을 주고 받는 API 서버의 경우에는 직접 처리를 해줘야 한다.</p><p><code>lucy-xss-servlet-filter</code>를 수정해서 JSON도 처리하도록 만드는 방법도 있겠지만, 여기에서는 Response를 클라이언트로 내보내는 단계에서 처리하는 방법을 알아본다.</p><h2 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h2><p>Response 쪽에서 공통적으로 처리해줘야할 일이 있다면 금방 떠오르는 것이 <code>HanderInterceptor</code>의 <code>postHandle()</code>이다. 이 메서드의 파라미터는 <code>HttpServletRequest request</code>, <code>HttpServletResponse response</code>, <code>Object handler</code>, <code>ModelAndView modelAndView</code>이고, <code>response</code>에서 Response Body를 꺼내서, <code>&lt;</code> =&gt; <code>&amp;lt;</code> 등의 변환 처리를 하고 다시 <code>response</code>에 넣어주면 될 것 같다.</p><p>하지만 <code>response</code>에서 Response Body를 끄집어 내는 것도 쉽지 않고, 그 내용을 바꿔서 다시 집어넣는 것도 여의치 않다. 다른 방법이 필요하다.</p><h2 id="MessageConverter"><a href="#MessageConverter" class="headerlink" title="MessageConverter"></a>MessageConverter</h2><p>다음으로 생각나는 것은 <code>MessageConverter</code>다. 어차피 결국에는 Jackson 같은 Mapper를 통해 JSON 문자열로 Response에 담겨지므로, <strong>Mapper가 JSON 문자열을 생성할 때 XSS 방지 처리</strong>를 해주면 될 것 같다.</p><p>찾아보니 역시나 <a href="http://stackoverflow.com/questions/25403676/initbinder-with-requestbody-escaping-xss-in-spring-3-2-4" target="_blank" rel="noopener">http://stackoverflow.com/questions/25403676/initbinder-with-requestbody-escaping-xss-in-spring-3-2-4</a> 이런 자료가 있다. 좀 오래된 버전이고 군더더기도 있어서 Jackson 2.#, SpringBoot 1.# 버전 기준으로 깔끔하게, 그리고 <strong>커스터마이징 할 수 있는 부분을 추가</strong>해서 정리해봤다.</p><p>큰 흐름은 다음과 같다.</p><blockquote><ol><li>처리할 특수 문자 지정</li><li>특수 문자 인코딩 값 지정</li><li>ObjectMapper에 특수 문자 처리 기능 적용</li><li>MessageConverter에 ObjectMapper 설정</li><li>WebMvcConfigurerAdapter에 MessageConverter 추가</li></ol></blockquote><h3 id="처리할-특수-문자-지정"><a href="#처리할-특수-문자-지정" class="headerlink" title="처리할 특수 문자 지정"></a>처리할 특수 문자 지정</h3><p>XSS 방지 처리할 특수 문자를 다음과 같이 <code>CharacterEscapes</code>를 상속한 클래스를 직접 만들어서 지정해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.SerializableString;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.io.CharacterEscapes;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.io.SerializedString;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.text.translate.AggregateTranslator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.text.translate.CharSequenceTranslator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.text.translate.EntityArrays;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.text.translate.LookupTranslator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HTMLCharacterEscapes</span> <span class="keyword">extends</span> <span class="title">CharacterEscapes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] asciiEscapes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CharSequenceTranslator translator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HTMLCharacterEscapes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. XSS 방지 처리할 특수 문자 지정</span></span><br><span class="line">        asciiEscapes = CharacterEscapes.standardAsciiEscapesForJSON();</span><br><span class="line">        asciiEscapes[<span class="string">'&lt;'</span>] = CharacterEscapes.ESCAPE_CUSTOM;</span><br><span class="line">        asciiEscapes[<span class="string">'&gt;'</span>] = CharacterEscapes.ESCAPE_CUSTOM;</span><br><span class="line">        asciiEscapes[<span class="string">'&amp;'</span>] = CharacterEscapes.ESCAPE_CUSTOM;</span><br><span class="line">        asciiEscapes[<span class="string">'\"'</span>] = CharacterEscapes.ESCAPE_CUSTOM;</span><br><span class="line">        asciiEscapes[<span class="string">'('</span>] = CharacterEscapes.ESCAPE_CUSTOM;</span><br><span class="line">        asciiEscapes[<span class="string">')'</span>] = CharacterEscapes.ESCAPE_CUSTOM;</span><br><span class="line">        asciiEscapes[<span class="string">'#'</span>] = CharacterEscapes.ESCAPE_CUSTOM;</span><br><span class="line">        asciiEscapes[<span class="string">'\''</span>] = CharacterEscapes.ESCAPE_CUSTOM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. XSS 방지 처리 특수 문자 인코딩 값 지정</span></span><br><span class="line">        translator = <span class="keyword">new</span> AggregateTranslator(</span><br><span class="line">            <span class="keyword">new</span> LookupTranslator(EntityArrays.BASIC_ESCAPE()),  <span class="comment">// &lt;, &gt;, &amp;, " 는 여기에 포함됨</span></span><br><span class="line">            <span class="keyword">new</span> LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()),</span><br><span class="line">            <span class="keyword">new</span> LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()),</span><br><span class="line">            <span class="comment">// 여기에서 커스터마이징 가능</span></span><br><span class="line">            <span class="keyword">new</span> LookupTranslator(</span><br><span class="line">                <span class="keyword">new</span> String[][]&#123;</span><br><span class="line">                    &#123;<span class="string">"("</span>,  <span class="string">"&amp;#40;"</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">")"</span>,  <span class="string">"&amp;#41;"</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">"#"</span>,  <span class="string">"&amp;#35;"</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">"\'"</span>, <span class="string">"&amp;#39;"</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getEscapeCodesForAscii() &#123;</span><br><span class="line">        <span class="keyword">return</span> asciiEscapes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SerializableString <span class="title">getEscapeSequence</span><span class="params">(<span class="keyword">int</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SerializedString(translator.translate(Character.toString((<span class="keyword">char</span>) ch)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 참고 - 커스터마이징이 필요없다면 아래와 같이 Apache Commons Lang3에서 제공하는 메서드를 써도 된다.</span></span><br><span class="line">        <span class="comment">// return new SerializedString(StringEscapeUtils.escapeHtml4(Character.toString((char) ch)));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ObjectMapper에-특수-문자-처리-기능-적용-후-MessageConverter-등록"><a href="#ObjectMapper에-특수-문자-처리-기능-적용-후-MessageConverter-등록" class="headerlink" title="ObjectMapper에 특수 문자 처리 기능 적용 후 MessageConverter 등록"></a>ObjectMapper에 특수 문자 처리 기능 적용 후 MessageConverter 등록</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebMvcConfigurerAdapter <span class="title">controlTowerWebConfigurerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.configureMessageConverters(converters);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. WebMvcConfigurerAdapter에 MessageConverter 추가</span></span><br><span class="line">            converters.add(htmlEscapingConveter());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> HttpMessageConverter&lt;?&gt; htmlEscapingConveter() &#123;</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            <span class="comment">// 3. ObjectMapper에 특수 문자 처리 기능 적용</span></span><br><span class="line">            objectMapper.getFactory().setCharacterEscapes(<span class="keyword">new</span> HTMLCharacterEscapes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. MessageConverter에 ObjectMapper 설정</span></span><br><span class="line">            MappingJackson2HttpMessageConverter htmlEscapingConverter =</span><br><span class="line">                    <span class="keyword">new</span> MappingJackson2HttpMessageConverter();</span><br><span class="line">            htmlEscapingConverter.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> htmlEscapingConverter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><blockquote><p><code>lucy-xss-servlet-filter</code>는 JSON에 대한 XSS는 처리해주지 않는다.</p><ul><li>따라서, JSON에 대한 XSS가 필요하다면</li><li>Jackson의 <code>com.fasterxml.jackson.core.io.CharacterEscapes</code>를 상속하는 클래스 A를 직접 만들어서 처리해야 할 특수문자를 지정하고,</li><li><code>ObjectMapper</code>에 <code>A</code>를 설정하고,</li><li><code>ObjectMapper</code>를 MessageConverter에 등록해서 Response가 클라이언트에 나가기 전에 XSS 방지 처리 해준다.</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring에서-JSON에-XSS-방지-처리-하기&quot;&gt;&lt;a href=&quot;#Spring에서-JSON에-XSS-방지-처리-하기&quot; class=&quot;headerlink&quot; title=&quot;Spring에서 JSON에 XSS 방지 처리 하기&quot;&gt;&lt;/a&gt;Sprin
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Spring" scheme="http://homoefficio.github.io/tags/Spring/"/>
    
      <category term="스프링" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81/"/>
    
      <category term="XSS" scheme="http://homoefficio.github.io/tags/XSS/"/>
    
      <category term="JSON" scheme="http://homoefficio.github.io/tags/JSON/"/>
    
      <category term="lucy-xss-servlet-filter" scheme="http://homoefficio.github.io/tags/lucy-xss-servlet-filter/"/>
    
      <category term="Cross Site Scripting" scheme="http://homoefficio.github.io/tags/Cross-Site-Scripting/"/>
    
      <category term="MessageConverter" scheme="http://homoefficio.github.io/tags/MessageConverter/"/>
    
      <category term="보안" scheme="http://homoefficio.github.io/tags/%EB%B3%B4%EC%95%88/"/>
    
      <category term="크로스 사이트 스크립팅" scheme="http://homoefficio.github.io/tags/%ED%81%AC%EB%A1%9C%EC%8A%A4-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8C%85/"/>
    
  </entry>
  
</feed>
